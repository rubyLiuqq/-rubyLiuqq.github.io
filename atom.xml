<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-20T15:40:37.077Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>rubyliuqq</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>webpack流程</title>
    <link href="http://yoursite.com/2018/10/20/%5B%E6%9E%84%E5%BB%BA%5D%20webpack%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/10/20/[构建] webpack流程/</id>
    <published>2018-10-20T14:49:14.000Z</published>
    <updated>2018-10-20T15:40:37.077Z</updated>
    
    <content type="html"><![CDATA[<h2 id="流程概括"><a href="#流程概括" class="headerlink" title="流程概括"></a>流程概括</h2><p>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p><p>1、<code>初始化参数</code>：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；<br>2、<code>开始编译</code>：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；<br>3、<code>确定入口</code>：根据配置中的 entry 找出所有的入口文件；<br>4、<code>编译模块</code>：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；<br>5、<code>完成模块编译</code>：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；<br>6、<code>输出资源</code>：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；<br>7、<code>输出完成</code>：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</p><p>在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</p><h2 id="流程细节"><a href="#流程细节" class="headerlink" title="流程细节"></a>流程细节</h2><p>Webpack 的构建流程可以分为以下三大阶段：<br>1、<code>初始化</code>：启动构建，读取与合并配置参数，加载 <code>Plugin</code>，实例化<code>Compiler</code>。<br>2、<code>编译</code>：从 <code>Entry</code> 发出，针对每个 <code>Module</code> 串行调用对应的 <code>Loader</code> 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理。<br>3、<code>输出</code>：对编译后的 Module 组合成 <code>Chunk</code>，把 Chunk 转换成文件，输出到文件系统。</p><p>在每个大阶段中又会发生很多事件，Webpack 会把这些事件广播出来供给 Plugin 使用，下面来一一介绍。</p><h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><table><thead><tr><th>事件名</th><th>解释</th></tr></thead><tbody><tr><td>初始化参数</td><td>从配置文件和 Shell 语句中读取与合并参数，得出最终的参数。 这个过程中还会执行配置文件中的插件实例化语句 <code>new Plugin()</code>。</td></tr><tr><td>实例化 <code>Compiler</code></td><td>用上一步得到的参数初始化 <code>Compiler</code> 实例，<code>Compiler</code> 负责文件监听和启动编译。<code>Compiler</code> 实例中包含了完整的 Webpack 配置，全局只有一个 <code>Compiler</code> 实例。</td></tr><tr><td>加载插件</td><td>依次调用插件的 <code>apply</code> 方法，让插件可以监听后续的所有事件节点。同时给插件传入 <code>compiler</code> 实例的引用，以方便插件通过 <code>compiler</code> 调用 Webpack 提供的 API。</td></tr><tr><td><code>environment</code></td><td>开始应用 Node.js 风格的文件系统到 <code>compiler</code> 对象，以方便后续的文件寻找和读取。</td></tr><tr><td><code>entry-option</code></td><td>读取配置的 <code>Entrys</code>，为每个 <code>Entry</code> 实例化一个对应的 <code>EntryPlugin</code>，为后面该 <code>Entry</code> 的递归解析工作做准备。</td></tr><tr><td><code>after-plugins</code></td><td>调用完所有内置的和配置的插件的 <code>apply</code> 方法。</td></tr><tr><td><code>after-resolvers</code></td><td>根据配置初始化完 <code>resolver</code>，<code>resolver</code>负责在文件系统中寻找指定路径的文件。</td></tr></tbody></table><h3 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h3><table><thead><tr><th>事件名</th><th>解释</th></tr></thead><tbody><tr><td><code>run</code></td><td>启动一次新的编译。</td></tr><tr><td><code>watch-run</code></td><td>和 run 类似，区别在于它是在监听模式下启动的编译，在这个事件中可以获取到是哪些文件发生了变化导致重新启动一次新的编译。</td></tr><tr><td><code>compile</code></td><td>该事件是为了告诉插件一次新的编译将要启动，同时会给插件带上 compiler 对象。</td></tr><tr><td><code>compilation</code></td><td>当 Webpack 以开发模式运行时，每当检测到文件变化，一次新的 <code>Compilation</code> 将被创建。一个 <code>Compilation</code> 对象包含了当前的模块资源、编译生成资源、变化的文件等。<code>Compilation</code> 对象也提供了很多事件回调供插件做扩展。</td></tr><tr><td><code>make</code></td><td>一个新的 <code>Compilation</code> 创建完毕，即将从 <code>Entry</code> 开始读取文件，根据文件类型和配置的 Loader 对文件进行编译，编译完后再找出该文件依赖的文件，递归的编译和解析。</td></tr><tr><td><code>after-compile</code></td><td>一次 Compilation 执行完成。</td></tr><tr><td><code>invalid</code></td><td>当遇到文件不存在、文件编译错误等异常时会触发该事件，该事件不会导致 Webpack 退出。</td></tr></tbody></table><p>在编译阶段中，最重要的要数 compilation 事件了，因为在 compilation 阶段调用了 Loader 完成了每个模块的转换操作，在 compilation 阶段又包括很多小的事件，它们分别是：</p><table><thead><tr><th>事件名</th><th>解释</th></tr></thead><tbody><tr><td><code>build-module</code></td><td>使用对应的 Loader 去转换一个模块。</td></tr><tr><td><code>normal-module-loader</code></td><td>在用 Loader 对一个模块转换完后，使用 acorn 解析转换后的内容，输出对应的抽象语法树（AST），以方便 Webpack 后面对代码的分析。</td></tr><tr><td><code>program</code></td><td>从配置的入口模块开始，分析其 AST，当遇到 require 等导入其它模块语句时，便将其加入到依赖的模块列表，同时对新找出的依赖模块递归分析，最终搞清所有模块的依赖关系。</td></tr><tr><td><code>seal</code></td><td>所有模块及其依赖的模块都通过 Loader 转换完成后，根据依赖关系开始生成 Chunk。</td></tr></tbody></table><h3 id="输出阶段"><a href="#输出阶段" class="headerlink" title="输出阶段"></a>输出阶段</h3><table><thead><tr><th>事件名</th><th>解释</th></tr></thead><tbody><tr><td><code>should-emit</code></td><td>所有需要输出的文件已经生成好，询问插件哪些文件需要输出，哪些不需要。</td></tr><tr><td><code>emit</code></td><td>确定好要输出哪些文件后，执行文件输出，可以在这里获取和修改输出内容。</td></tr><tr><td><code>after-emit</code></td><td>文件输出完毕。</td></tr><tr><td><code>done</code></td><td>成功完成一次完成的编译和输出流程。</td></tr><tr><td><code>failed</code></td><td>如果在编译和输出流程中遇到异常导致 Webpack 退出时，就会直接跳转到本步骤，插件可以在本事件中获取到具体的错误原因。</td></tr></tbody></table><h2 id="输出文件分析"><a href="#输出文件分析" class="headerlink" title="输出文件分析"></a>输出文件分析</h2><p>bundle.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line">    <span class="comment">// webpackBootstrap 启动函数</span></span><br><span class="line">    <span class="comment">// modules 即为存放所有模块的数组，数组中的每一个元素都是一个函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">modules</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 安装过的模块都存放在这里面</span></span><br><span class="line">        <span class="comment">// 作用是把已经加载过的模块缓存在内存中，提升性能</span></span><br><span class="line">        <span class="keyword">var</span> installedModules = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去数组中加载一个模块，moduleId 为要加载模块在数组中的 index</span></span><br><span class="line">        <span class="comment">// 作用和 Node.js 中 require 语句相似</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 如果需要加载的模块已经被加载过，就直接从内存缓存中返回</span></span><br><span class="line">            <span class="keyword">if</span> (installedModules[moduleId]) &#123;</span><br><span class="line">                <span class="keyword">return</span> installedModules[moduleId].exports;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果缓存中不存在需要加载的模块，就新建一个模块，并把它存在缓存中</span></span><br><span class="line">            <span class="keyword">var</span> <span class="built_in">module</span> = installedModules[moduleId] = &#123;</span><br><span class="line">                <span class="comment">// 模块在数组中的 index</span></span><br><span class="line">                i: moduleId,</span><br><span class="line">                <span class="comment">// 该模块是否已经加载完毕</span></span><br><span class="line">                l: <span class="literal">false</span>,</span><br><span class="line">                <span class="comment">// 该模块的导出值</span></span><br><span class="line">                exports: &#123;&#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从 modules 中获取 index 为 moduleId 的模块对应的函数</span></span><br><span class="line">            <span class="comment">// 再调用这个函数，同时把函数需要的参数传入</span></span><br><span class="line">            modules[moduleId].call(<span class="built_in">module</span>.exports, <span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line">            <span class="comment">// 把这个模块标记为已加载</span></span><br><span class="line">            <span class="built_in">module</span>.l = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 返回这个模块的导出值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Webpack 配置中的 publicPath，用于加载被分割出去的异步代码</span></span><br><span class="line">        __webpack_require__.p = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 __webpack_require__ 去加载 index 为 0 的模块，并且返回该模块导出的内容</span></span><br><span class="line">        <span class="comment">// index 为 0 的模块就是 main.js 对应的文件，也就是执行入口模块</span></span><br><span class="line">        <span class="comment">// __webpack_require__.s 的含义是启动模块对应的 index</span></span><br><span class="line">        <span class="keyword">return</span> __webpack_require__(__webpack_require__.s = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;)(</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有的模块都存放在了一个数组里，根据每个模块在数组的 index 来区分和定位模块</span></span><br><span class="line">    [</span><br><span class="line">        <span class="comment">/* 0 */</span></span><br><span class="line">        (<span class="function"><span class="keyword">function</span> (<span class="params">module, exports, __webpack_require__</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 通过 __webpack_require__ 规范导入 show 函数，show.js 对应的模块 index 为 1</span></span><br><span class="line">            <span class="keyword">const</span> show = __webpack_require__(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 执行 show 函数</span></span><br><span class="line">            show(<span class="string">'Webpack'</span>);</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="comment">/* 1 */</span></span><br><span class="line">        (<span class="function"><span class="keyword">function</span> (<span class="params">module, exports</span>) </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">window</span>.document.getElementById(<span class="string">'app'</span>).innerText = <span class="string">'Hello,'</span> + content;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 通过 CommonJS 规范导出 show 函数</span></span><br><span class="line">            <span class="built_in">module</span>.exports = show;</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>以上看上去复杂的代码其实是一个立即执行函数，可以简写为如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模拟 require 语句</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行存放所有模块数组中的第0个模块</span></span><br><span class="line">  __webpack_require__(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;)([<span class="comment">/*存放所有模块的数组*/</span>])</span><br></pre></td></tr></table></figure></p><p>bundle.js 能直接运行在浏览器中的原因在于输出的文件中通过 <code>__webpack_require__</code> 函数定义了一个可以在浏览器中执行的加载函数来模拟 Node.js 中的 require 语句。</p><p>原来一个个独立的模块文件被合并到了一个单独的 bundle.js 的原因在于浏览器不能像 Node.js 那样快速地去本地加载一个个模块文件，而必须通过网络请求去加载还未得到的文件。<br>如果模块数量很多，加载时间会很长，因此把所有模块都存放在了数组中，执行一次网络加载。</p><p>如果仔细分析 _<code>_webpack_require__</code> 函数的实现，还有发现 Webpack 做了缓存优化： <strong>执行加载过的模块不会再执行第二次，执行结果会缓存在内存中，当某个模块第二次被访问时会直接去内存中读取被缓存的返回值。</strong></p><h3 id="分割代码时的输出"><a href="#分割代码时的输出" class="headerlink" title="分割代码时的输出"></a>分割代码时的输出</h3><p>把源码中的 main.js 修改为如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步加载 show.js</span></span><br><span class="line"><span class="keyword">import</span>(<span class="string">'./show'</span>).then(<span class="function">(<span class="params">show</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 执行 show 函数</span></span><br><span class="line">  show(<span class="string">'Webpack'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>重新构建后会输出两个文件，分别是执行入口文件 bundle.js 和 异步加载文件 0.bundle.js。</p><p>其中 0.bundle.js 内容如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载在本文件(0.bundle.js)中包含的模块</span></span><br><span class="line">webpackJsonp(</span><br><span class="line">  <span class="comment">// 在其它文件中存放着的模块的 ID</span></span><br><span class="line">  [<span class="number">0</span>],</span><br><span class="line">  <span class="comment">// 本文件所包含的模块</span></span><br><span class="line">  [</span><br><span class="line">    <span class="comment">// show.js 所对应的模块</span></span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">module, exports</span>) </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">window</span>.document.getElementById(<span class="string">'app'</span>).innerText = <span class="string">'Hello,'</span> + content;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">module</span>.exports = show;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>bundle.js 内容如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">modules</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/***</span></span><br><span class="line"><span class="comment">   * webpackJsonp 用于从异步加载的文件中安装模块。</span></span><br><span class="line"><span class="comment">   * 把 webpackJsonp 挂载到全局是为了方便在其它文件中调用。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param chunkIds 异步加载的文件中存放的需要安装的模块对应的 Chunk ID</span></span><br><span class="line"><span class="comment">   * @param moreModules 异步加载的文件中存放的需要安装的模块列表</span></span><br><span class="line"><span class="comment">   * @param executeModules 在异步加载的文件中存放的需要安装的模块都安装成功后，需要执行的模块对应的 index</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="built_in">window</span>[<span class="string">"webpackJsonp"</span>] = <span class="function"><span class="keyword">function</span> <span class="title">webpackJsonpCallback</span>(<span class="params">chunkIds, moreModules, executeModules</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 把 moreModules 添加到 modules 对象中</span></span><br><span class="line">    <span class="comment">// 把所有 chunkIds 对应的模块都标记成已经加载成功 </span></span><br><span class="line">    <span class="keyword">var</span> moduleId, chunkId, i = <span class="number">0</span>, resolves = [], result;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; chunkIds.length; i++) &#123;</span><br><span class="line">      chunkId = chunkIds[i];</span><br><span class="line">      <span class="keyword">if</span> (installedChunks[chunkId]) &#123;</span><br><span class="line">        resolves.push(installedChunks[chunkId][<span class="number">0</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">      installedChunks[chunkId] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (moduleId <span class="keyword">in</span> moreModules) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(moreModules, moduleId)) &#123;</span><br><span class="line">        modules[moduleId] = moreModules[moduleId];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (resolves.length) &#123;</span><br><span class="line">      resolves.shift()();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 缓存已经安装的模块</span></span><br><span class="line">  <span class="keyword">var</span> installedModules = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储每个 Chunk 的加载状态；</span></span><br><span class="line">  <span class="comment">// 键为 Chunk 的 ID，值为0代表已经加载成功</span></span><br><span class="line">  <span class="keyword">var</span> installedChunks = &#123;</span><br><span class="line">    <span class="number">1</span>: <span class="number">0</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模拟 require 语句，和上面介绍的一致</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ... 省略和上面一样的内容</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 用于加载被分割出去的，需要异步加载的 Chunk 对应的文件</span></span><br><span class="line"><span class="comment">   * @param chunkId 需要异步加载的 Chunk 对应的 ID</span></span><br><span class="line"><span class="comment">   * @returns &#123;Promise&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  __webpack_require__.e = <span class="function"><span class="keyword">function</span> <span class="title">requireEnsure</span>(<span class="params">chunkId</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 从上面定义的 installedChunks 中获取 chunkId 对应的 Chunk 的加载状态</span></span><br><span class="line">    <span class="keyword">var</span> installedChunkData = installedChunks[chunkId];</span><br><span class="line">    <span class="comment">// 如果加载状态为0表示该 Chunk 已经加载成功了，直接返回 resolve Promise</span></span><br><span class="line">    <span class="keyword">if</span> (installedChunkData === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        resolve();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// installedChunkData 不为空且不为0表示该 Chunk 正在网络加载中</span></span><br><span class="line">    <span class="keyword">if</span> (installedChunkData) &#123;</span><br><span class="line">      <span class="comment">// 返回存放在 installedChunkData 数组中的 Promise 对象</span></span><br><span class="line">      <span class="keyword">return</span> installedChunkData[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// installedChunkData 为空，表示该 Chunk 还没有加载过，去加载该 Chunk 对应的文件</span></span><br><span class="line">    <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      installedChunkData = installedChunks[chunkId] = [resolve, reject];</span><br><span class="line">    &#125;);</span><br><span class="line">    installedChunkData[<span class="number">2</span>] = promise;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 DOM 操作，往 HTML head 中插入一个 script 标签去异步加载 Chunk 对应的 JavaScript 文件</span></span><br><span class="line">    <span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">    script.charset = <span class="string">'utf-8'</span>;</span><br><span class="line">    script.async = <span class="literal">true</span>;</span><br><span class="line">    script.timeout = <span class="number">120000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件的路径为配置的 publicPath、chunkId 拼接而成</span></span><br><span class="line">    script.src = __webpack_require__.p + <span class="string">""</span> + chunkId + <span class="string">".bundle.js"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置异步加载的最长超时时间</span></span><br><span class="line">    <span class="keyword">var</span> timeout = setTimeout(onScriptComplete, <span class="number">120000</span>);</span><br><span class="line">    script.onerror = script.onload = onScriptComplete;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 script 加载和执行完成时回调</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onScriptComplete</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 防止内存泄露</span></span><br><span class="line">      script.onerror = script.onload = <span class="literal">null</span>;</span><br><span class="line">      clearTimeout(timeout);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 去检查 chunkId 对应的 Chunk 是否安装成功，安装成功时才会存在于 installedChunks 中</span></span><br><span class="line">      <span class="keyword">var</span> chunk = installedChunks[chunkId];</span><br><span class="line">      <span class="keyword">if</span> (chunk !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chunk) &#123;</span><br><span class="line">          chunk[<span class="number">1</span>](<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Loading chunk '</span> + chunkId + <span class="string">' failed.'</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        installedChunks[chunkId] = <span class="literal">undefined</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    head.appendChild(script);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载并执行入口模块，和上面介绍的一致</span></span><br><span class="line">  <span class="keyword">return</span> __webpack_require__(__webpack_require__.s = <span class="number">0</span>);</span><br><span class="line">&#125;)</span><br><span class="line">(</span><br><span class="line">  <span class="comment">// 存放所有没有经过异步加载的，随着执行入口文件加载的模块</span></span><br><span class="line">  [</span><br><span class="line">    <span class="comment">// main.js 对应的模块</span></span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">module, exports, __webpack_require__</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 通过 __webpack_require__.e 去异步加载 show.js 对应的 Chunk</span></span><br><span class="line">      __webpack_require__.e(<span class="number">0</span>).then(__webpack_require__.bind(<span class="literal">null</span>, <span class="number">1</span>)).then(<span class="function">(<span class="params">show</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 执行 show 函数</span></span><br><span class="line">        show(<span class="string">'Webpack'</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>这里的 bundle.js 和上面所讲的 bundle.js 非常相似，区别在于：<br>1、多了一个 <code>__webpack_require__.e</code> 用于加载被分割出去的，需要异步加载的 Chunk 对应的文件;<br>2、多了一个 <code>webpackJsonp</code> 函数用于从异步加载的文件中安装模块。</p><p>在使用了 CommonsChunkPlugin 去提取公共代码时输出的文件和使用了异步加载时输出的文件是一样的，都会有 <strong>webpack_require</strong>.e 和 webpackJsonp。 原因在于提取公共代码和异步加载本质上都是代码分割。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;流程概括&quot;&gt;&lt;a href=&quot;#流程概括&quot; class=&quot;headerlink&quot; title=&quot;流程概括&quot;&gt;&lt;/a&gt;流程概括&lt;/h2&gt;&lt;p&gt;Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：&lt;/p&gt;
&lt;p&gt;1、&lt;code&gt;初始化参数&lt;/c
      
    
    </summary>
    
      <category term="构建" scheme="http://yoursite.com/categories/%E6%9E%84%E5%BB%BA/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>vue官网阅读</title>
    <link href="http://yoursite.com/2018/10/19/%5BVue%5DVue%E5%AE%98%E7%BD%91/"/>
    <id>http://yoursite.com/2018/10/19/[Vue]Vue官网/</id>
    <published>2018-10-19T08:38:36.000Z</published>
    <updated>2018-10-21T04:10:01.660Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Vue实例"><a href="#一、Vue实例" class="headerlink" title="一、Vue实例"></a>一、Vue实例</h2><p>只有当实例被创建时 data 中存在的属性才是响应式的。<br>vm.b = ‘hi’;  // 对 b 的改动将不会触发任何视图的更新。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: data</span><br><span class="line">&#125;);</span><br><span class="line">vm.a == data.a <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="comment">// 设置属性也会影响到原始数据</span></span><br><span class="line">vm.a = <span class="number">2</span></span><br><span class="line">data.a <span class="comment">// =&gt; 2</span></span><br><span class="line"><span class="comment">// 反之亦然</span></span><br><span class="line">data.a = <span class="number">3</span></span><br><span class="line">vm.a <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure></p><p><code>Object.freeze()</code>会阻止修改现有的属性，也意味着响应系统无法再追踪变化。</p><h4 id="实例提供的属性和方法"><a href="#实例提供的属性和方法" class="headerlink" title="实例提供的属性和方法"></a>实例提供的属性和方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example'</span>,</span><br><span class="line">  data: data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.$data === data <span class="comment">// =&gt; true</span></span><br><span class="line">vm.$el === <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>) <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// $watch 是一个实例方法</span></span><br><span class="line">vm.$watch(<span class="string">'a'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">newValue, oldValue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这个回调将在 `vm.a` 改变后调用</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="二、模板语法-修饰符"><a href="#二、模板语法-修饰符" class="headerlink" title="二、模板语法 - 修饰符"></a>二、模板语法 - 修饰符</h2><p>修饰符 (Modifiers) 是以半角句号 <code>.</code> 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。<br>例如，<code>.prevent</code> 修饰符告诉 <code>v-on</code> 指令对于触发的事件调用 <code>event.preventDefault()</code>：</p><form v-on:submit.prevent="onSubmit">…</form><h2 id="三、计算属性和侦听器"><a href="#三、计算属性和侦听器" class="headerlink" title="三、计算属性和侦听器"></a>三、计算属性和侦听器</h2><h4 id="1、计算属性缓存computed-vs-方法methods"><a href="#1、计算属性缓存computed-vs-方法methods" class="headerlink" title="1、计算属性缓存computed vs 方法methods"></a>1、计算属性缓存computed vs 方法methods</h4><p>可以将同一函数定义为一个方法methods而不是一个计算属性computed。两种方式的最终结果确实是完全相同的。<br>然而，不同的是<code>计算属性是基于它们的依赖进行缓存的</code>，只在相关依赖发生改变时它们才会重新求值。</p><h4 id="2、计算属性computed-vs-侦听属性watch"><a href="#2、计算属性computed-vs-侦听属性watch" class="headerlink" title="2、计算属性computed vs 侦听属性watch"></a>2、计算属性computed vs 侦听属性watch</h4><h4 id="计算属性的-setter"><a href="#计算属性的-setter" class="headerlink" title="计算属性的 setter"></a>计算属性的 setter</h4><p>计算属性默认只有 getter ，不过在需要时也可以提供一个 setter ：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> names = newValue.split(<span class="string">' '</span>)</span><br><span class="line">      <span class="keyword">this</span>.firstName = names[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">this</span>.lastName = names[names.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></p><p>现在再运行 <code>vm.fullName = &#39;John Doe&#39;</code> 时，<code>setter</code> 会被调用，<code>vm.firstName</code> 和 <code>vm.lastName</code> 也会相应地被更新。</p><h4 id="3、侦听器watch"><a href="#3、侦听器watch" class="headerlink" title="3、侦听器watch"></a>3、侦听器watch</h4><p>当需要在数据变化时执行异步或开销较大的操作时，<code>侦听器</code>最有用的<br><a href="https://cn.vuejs.org/v2/guide/computed.html#%E4%BE%A6%E5%90%AC%E5%99%A8" target="_blank" rel="noopener">查看官网demo</a></p><h2 id="四、Class与Style绑定"><a href="#四、Class与Style绑定" class="headerlink" title="四、Class与Style绑定"></a>四、Class与Style绑定</h2><h4 id="1、绑定-HTML-Class-对象语法"><a href="#1、绑定-HTML-Class-对象语法" class="headerlink" title="1、绑定 HTML Class - 对象语法"></a>1、绑定 HTML Class - 对象语法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"static"</span> v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"&#123; active: isActive, 'text-danger': hasError &#125;"</span>&gt; <span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  isActive: <span class="literal">true</span>,</span><br><span class="line">  hasError: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"classObject"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  classObject: &#123;</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">'text-danger'</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法三</span></span><br><span class="line">data: &#123;</span><br><span class="line">  isActive: <span class="literal">true</span>,</span><br><span class="line">  error: <span class="literal">null</span></span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  classObject: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      active: <span class="keyword">this</span>.isActive &amp;&amp; !<span class="keyword">this</span>.error,</span><br><span class="line">      <span class="string">'text-danger'</span>: <span class="keyword">this</span>.error &amp;&amp; <span class="keyword">this</span>.error.type === <span class="string">'fatal'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、绑定-HTML-Class-数组语法"><a href="#2、绑定-HTML-Class-数组语法" class="headerlink" title="2、绑定 HTML Class - 数组语法"></a>2、绑定 HTML Class - 数组语法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"[activeClass, errorClass]"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  activeClass: <span class="string">'active'</span>,</span><br><span class="line">  errorClass: <span class="string">'text-danger'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染结果为：</span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"active text-danger"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="3、绑定-HTML-Class-用在组件上"><a href="#3、绑定-HTML-Class-用在组件上" class="headerlink" title="3、绑定 HTML Class - 用在组件上"></a>3、绑定 HTML Class - 用在组件上</h4><p>当在一个自定义组件上使用 class 属性时，这些类将被添加到该组件的根元素上面。这个元素上已经存在的类不会被覆盖。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义组件</span></span><br><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;p class="foo bar"&gt;Hi&lt;/p&gt;'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件的引用</span></span><br><span class="line">&lt;my-component <span class="class"><span class="keyword">class</span></span>=<span class="string">"baz boo"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// HTML 将被渲染为:</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"foo bar baz boo"</span>&gt;</span>Hi<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><h2 id="五、条件渲染-v-if-vs-v-show"><a href="#五、条件渲染-v-if-vs-v-show" class="headerlink" title="五、条件渲染 - v-if vs v-show"></a>五、条件渲染 - v-if vs v-show</h2><p><code>v-if</code> 是惰性的：如果在初始渲染时条件为假，则什么也不做，直到条件第一次变为真时，才会开始渲染条件块。<br><code>v-show</code> 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p><font color="#d00">v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。</font><br><font color="#d00">因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。</font><h2 id="六、列表渲染"><a href="#六、列表渲染" class="headerlink" title="六、列表渲染"></a>六、列表渲染</h2><h3 id="1、v-if-vs-v-show"><a href="#1、v-if-vs-v-show" class="headerlink" title="1、v-if vs v-show"></a>1、v-if vs v-show</h3><p><code>变异方法</code>：会改变被这些方法调用的原始数组。push(), pop(), shift(), unshift(), splice(), sort(), reverse()。<br><code>非变异方法</code>，例如：filter(), concat() 和 slice() 。这些不会改变原始数组，但总是返回一个新数组。</p><font color="#d00">注意事项：</font><br>由于 JavaScript 的限制，Vue 不能检测以下变动的数组：<br>1、利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue；<br>2、修改数组的长度时，例如：vm.items.length = newLength；<br><font color="#d00">解决第一类问题：</font><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue.set</span></span><br><span class="line">Vue.set(vm.items, indexOfItem, newValue);</span><br><span class="line"><span class="comment">// 也可以使用 vm.$set 实例方法，该方法是全局方法 Vue.set 的一个别名：</span></span><br><span class="line">vm.$set(vm.items, indexOfItem, newValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.prototype.splice</span></span><br><span class="line">vm.items.splice(indexOfItem, <span class="number">1</span>, newValue);</span><br></pre></td></tr></table></figure><br><br><font color="#d00">解决第二类问题：</font><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.items.splice(newLength)</span><br></pre></td></tr></table></figure><br><br>### 2、对象更改检测注意事项<br>由于 JS 的限制，Vue 不能检测对象属性的添加或删除。<br>可以使用 <code>Vue.set(object, key, value)</code> 方法向嵌套对象添加响应式属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    userProfile: &#123;</span><br><span class="line">      name: <span class="string">'Anika'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Vue.set(vm.userProfile, <span class="string">'age'</span>, <span class="number">27</span>);</span><br><span class="line">vm.$set(vm.userProfile, <span class="string">'age'</span>, <span class="number">27</span>);</span><br></pre></td></tr></table></figure><br><br>可能需要为已有对象赋予多个新属性，比如使用 <code>Object.assign()</code> 或 <code>_.extend()</code>。<br>在这种情况下，你应该用两个对象的属性创建一个新的对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vm.userProfile = <span class="built_in">Object</span>.assign(&#123;&#125;, vm.userProfile, &#123;</span><br><span class="line">  age: <span class="number">27</span>,</span><br><span class="line">  favoriteColor: <span class="string">'Vue Green'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br><br>### 3、v-for with v-if<br><font color="#d00">当它们处于同一节点，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。</font><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-<span class="keyword">for</span>=<span class="string">"todo in todos"</span> v-<span class="keyword">if</span>=<span class="string">"!todo.isComplete"</span>&gt;</span><br><span class="line">  &#123;&#123; todo &#125;&#125;</span><br><span class="line">&lt;<span class="regexp">/li&gt;</span></span><br></pre></td></tr></table></figure><br><br>### 4、一个组件的 v-for<br>is=”todo-item” 属性。这种做法在使用 DOM 模板时是十分必要的，<br>因为在 <code>&lt;ul&gt;</code> 元素内只有 <code>&lt;li&gt;</code> 元素会被看作有效内容。这样做实现的效果与 <code>&lt;todo-item&gt;</code> 相同，但是可以避开一些潜在的浏览器解析错误。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li</span><br><span class="line">    is=<span class="string">"todo-item"</span></span><br><span class="line">    v-<span class="keyword">for</span>=<span class="string">"(todo, index) in todos"</span></span><br><span class="line">    v-bind:key=<span class="string">"todo.id"</span></span><br><span class="line">    v-bind:title=<span class="string">"todo.title"</span></span><br><span class="line">    v-on:remove=<span class="string">"todos.splice(index, 1)"</span></span><br><span class="line">  &gt;<span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/ul&gt;</span></span><br></pre></td></tr></table></figure><br><br>## 七、事件处理<br>有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 <code>$event</code> 把它传入方法<br><br>### 1、事件修饰符<br><code>.stop</code>、<code>.prevent</code>、<code>.capture</code>、<code>.self</code>、<code>.once</code>、<code>.passive</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阻止单击事件继续传播</span></span><br><span class="line">&lt;a v-on:click.stop=<span class="string">"doThis"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交事件不再重载页面</span></span><br><span class="line">&lt;form v-on:submit.prevent=<span class="string">"onSubmit"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修饰符可以串联</span></span><br><span class="line">&lt;a v-on:click.stop.prevent=<span class="string">"doThat"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有修饰符</span></span><br><span class="line">&lt;form v-on:submit.prevent&gt;<span class="xml"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加事件监听器时使用事件捕获模式</span></span><br><span class="line"><span class="comment">// 即元素自身触发的事件先在此处理，然后才交由内部元素进行处理</span></span><br><span class="line">&lt;div v-on:click.capture=<span class="string">"doThis"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只当在 event.target 是当前元素自身时触发处理函数</span></span><br><span class="line"><span class="comment">// 即事件不是从内部元素触发的</span></span><br><span class="line">&lt;div v-on:click.self=<span class="string">"doThat"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击事件将只会触发一次</span></span><br><span class="line">&lt;a v-on:click.once=<span class="string">"doThis"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 滚动事件的默认行为 (即滚动行为) 将会立即触发</span></span><br><span class="line"><span class="comment">// 而不会等待 `onScroll` 完成</span></span><br><span class="line"><span class="comment">// 这其中包含 `event.preventDefault()` 的情况</span></span><br><span class="line">&lt;div v-on:scroll.passive=<span class="string">"onScroll"</span>&gt;...&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><br><br>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。<br>因此，用 <code>v-on:click.prevent.self</code> 会阻止所有的点击，而 <code>v-on:click.self.prevent</code>只会阻止对元素自身的点击。<br>不要把 <code>.passive</code> 和 <code>.prevent</code> 一起使用，因为 <code>.prevent</code> 将会被忽略，同时浏览器可能会向你展示一个警告。<br>请记住，<code>.passive</code> 会告诉浏览器你不想阻止事件的默认行为。<br><br>### 2、按键修饰符<br>可以通过全局 <code>config.keyCodes</code> 对象自定义按键修饰符别名<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input @keyup.enter=<span class="string">"submit"</span>&gt;</span><br><span class="line"><span class="comment">// 可以使用 `v-on:keyup.f1`</span></span><br><span class="line">Vue.config.keyCodes.f1 = <span class="number">112</span></span><br></pre></td></tr></table></figure><br><br>### 3、系统修饰符<br><code>.exact</code> 修饰符允许你控制由精确的系统修饰符组合触发的事件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 即使 Alt 或 Shift 被一同按下时也会触发</span></span><br><span class="line">&lt;button @click.ctrl=<span class="string">"onClick"</span>&gt;A&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 有且只有 Ctrl 被按下的时候才触发</span></span><br><span class="line"><span class="regexp">&lt;button @click.ctrl.exact="onCtrlClick"&gt;A&lt;/</span>button&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有任何系统修饰符被按下的时候才触发</span></span><br><span class="line">&lt;button @click.exact=<span class="string">"onClick"</span>&gt;A&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><br><br>## 八、表单输入绑定<br>可以用 <code>v-model</code> 指令在表单 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code> 及 <code>&lt;select&gt;</code> 元素上创建双向数据绑定。<br>它会根据控件类型自动选取正确的方法来更新元素。<br><code>v-model</code> 会忽略所有表单元素的 <code>value</code>、<code>checked</code>、<code>selected</code> 特性的初始值而总是将 Vue 实例的数据作为数据来源。<br>你应该通过 JS 在组件的 data 选项中声明初始值。<br>对于需要使用<code>输入法 (如中文、日文、韩文等) 的语言</code>，会发现 <code>v-model</code> 不会在输入法组合文字过程中得到更新。<br>如果你也想处理这个过程，请使用 input 事件。<br><br>### 1、选择框<br>如果 v-model 表达式的初始值未能匹配任何选项，<select> 元素将被渲染为“未选中”状态。<br>在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 change 事件。因此，更推荐像上面这样提供一个值为空的禁用选项。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"example-5"</span>&gt;</span><br><span class="line">  &lt;select v-model=<span class="string">"selected"</span>&gt;</span><br><span class="line">    &lt;option disabled value=<span class="string">""</span>&gt;请选择&lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">    &lt;option&gt;A&lt;/</span>option&gt;</span><br><span class="line">    &lt;option&gt;B&lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">    &lt;option&gt;C&lt;/</span>option&gt;</span><br><span class="line">  &lt;<span class="regexp">/select&gt;</span></span><br><span class="line"><span class="regexp">  &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/</span>span&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">new Vue(&#123;</span></span><br><span class="line"><span class="regexp">  el: '...',</span></span><br><span class="line"><span class="regexp">  data: &#123;</span></span><br><span class="line"><span class="regexp">    selected: ''</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 用 v-for 渲染的动态选项</span></span><br><span class="line"><span class="regexp">&lt;select v-model="selected"&gt;</span></span><br><span class="line"><span class="regexp">  &lt;option v-for="option in options" v-bind:value="option.value"&gt;</span></span><br><span class="line"><span class="regexp">    &#123;&#123; option.text &#125;&#125;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>option&gt;</span><br><span class="line">&lt;<span class="regexp">/select&gt;</span></span><br><span class="line"><span class="regexp">&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/</span>span&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'...'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    selected: <span class="string">'A'</span>,</span><br><span class="line">    options: [</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">'One'</span>, <span class="attr">value</span>: <span class="string">'A'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">'Two'</span>, <span class="attr">value</span>: <span class="string">'B'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">'Three'</span>, <span class="attr">value</span>: <span class="string">'C'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值绑定</span></span><br><span class="line">&lt;select v-model=<span class="string">"selected"</span>&gt;</span><br><span class="line">  <span class="comment">// 内联对象字面量</span></span><br><span class="line">  &lt;option v-bind:value=<span class="string">"&#123; number: 123 &#125;"</span>&gt;<span class="number">123</span>&lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>select&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当选中时</span></span><br><span class="line"><span class="keyword">typeof</span> vm.selected <span class="comment">// =&gt; 'object'</span></span><br><span class="line">vm.selected.number <span class="comment">// =&gt; 123</span></span><br></pre></td></tr></table></figure><br><br>### 2、修饰符<br><code>.lazy</code>: 在默认情况下，<code>v-model</code> 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。<br>你可以添加 <code>lazy</code> 修饰符，从而转变为使用 <code>change</code> 事件进行同步.<br><code>.number</code>: 如果想自动将用户的输入值转为数值类型，可以给 <code>v-mode</code>l 添加 <code>number</code> 修饰符。<br><font color="#d00">如果这个值无法被 parseFloat() 解析，则会返回原始的值。</font><br><code>.trim</code>: 如果要自动过滤用户输入的首尾空白字符，可以给 <code>v-model</code> 添加 <code>trim</code> 修饰符。<br><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在“change”时而非“input”时更新</span></span><br><span class="line">&lt;input v-model.lazy=<span class="string">"msg"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 即使在 type="number" 时，HTML 输入元素的值也总会返回字符串</span></span><br><span class="line">&lt;input v-model.number=<span class="string">"age"</span> type=<span class="string">"number"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;input v-model.trim=<span class="string">"msg"</span>&gt;</span><br></pre></td></tr></table></figure><br><br>### 3、解析DOM模版时需要注意<br>有些 HTML 元素，诸如 <code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;table&gt;</code> 和 <code>&lt;select&gt;</code>，对于哪些元素可以出现在其内部是有严格限制的。<br>而有些元素，诸如 <code>&lt;li&gt;</code>、<code>&lt;tr&gt;</code> 和 <code>&lt;option&gt;</code>，只能出现在其它某些特定的元素内部。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">  &lt;tr is=<span class="string">"blog-post-row"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/table&gt;</span></span><br></pre></td></tr></table></figure><br><br>需要注意的是<font color="#d00">如果我们从以下来源使用模板的话，这条限制是不存在</font>的：<br>1、字符串 (例如：template: ‘…’)<br>2、单文件组件 (.vue)<br>3、<code>&lt;script type=&quot;text/x-template&quot;&gt;</code><br><br>如果使用了 webpack，那么就可以使用 require.context 只全局注册这些非常通用的基础组件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> upperFirst <span class="keyword">from</span> <span class="string">'lodash/upperFirst'</span></span><br><span class="line"><span class="keyword">import</span> camelCase <span class="keyword">from</span> <span class="string">'lodash/camelCase'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> requireComponent = <span class="built_in">require</span>.context(</span><br><span class="line">  <span class="comment">// 其组件目录的相对路径</span></span><br><span class="line">  <span class="string">'./components'</span>,</span><br><span class="line">  <span class="comment">// 是否查询其子目录</span></span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 匹配基础组件文件名的正则表达式</span></span><br><span class="line">  /Base[A-Z]\w+\.(vue|js)$/</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">requireComponent.keys().forEach(<span class="function"><span class="params">fileName</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 获取组件配置</span></span><br><span class="line">  <span class="keyword">const</span> componentConfig = requireComponent(fileName)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取组件的 PascalCase 命名</span></span><br><span class="line">  <span class="keyword">const</span> componentName = upperFirst(</span><br><span class="line">    camelCase(</span><br><span class="line">      <span class="comment">// 剥去文件名开头的 `./` 和结尾的扩展名</span></span><br><span class="line">      fileName.replace(<span class="regexp">/^\.\/(.*)\.\w+$/</span>, <span class="string">'$1'</span>)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 全局注册组件</span></span><br><span class="line">  Vue.component(</span><br><span class="line">    componentName,</span><br><span class="line">    <span class="comment">// 如果这个组件选项是通过 `export default` 导出的，</span></span><br><span class="line">    <span class="comment">// 那么就会优先使用 `.default`，</span></span><br><span class="line">    <span class="comment">// 否则回退到使用模块的根。</span></span><br><span class="line">    componentConfig.default || componentConfig</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br><br><font color="#d00">全局注册的行为必须在根 Vue 实例 (通过 new Vue) 创建之前发生</font></select>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Vue实例&quot;&gt;&lt;a href=&quot;#一、Vue实例&quot; class=&quot;headerlink&quot; title=&quot;一、Vue实例&quot;&gt;&lt;/a&gt;一、Vue实例&lt;/h2&gt;&lt;p&gt;只有当实例被创建时 data 中存在的属性才是响应式的。&lt;br&gt;vm.b = ‘hi’;  // 对
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>单页面应用的权限管理</title>
    <link href="http://yoursite.com/2018/10/19/%5BVue%5D%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E7%9A%84%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2018/10/19/[Vue]单页面应用的权限管理/</id>
    <published>2018-10-19T02:26:43.000Z</published>
    <updated>2018-10-19T15:18:29.449Z</updated>
    
    <content type="html"><![CDATA[<p>Vue 单页面应用的权限管理有两种方法：<code>接口级权限</code>；<code>页面级权限</code></p><h3 id="接口级权限"><a href="#接口级权限" class="headerlink" title="接口级权限"></a>接口级权限</h3><p>例子：后台好多接口发ajax请求获取数据的时候后端都会需要获取用户是否登录，并在登录的情况反馈到前端，前端跳转到登录页面。这个就可以使用这个拦截器来实现。<br>在请求或响应被 then 或 catch 处理前拦截它们。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;, error =&gt; &#123;</span><br><span class="line">  <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="params">config</span>  =&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">&#125;, error =&gt; &#123;</span><br><span class="line">  <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="页面级权限"><a href="#页面级权限" class="headerlink" title="页面级权限"></a>页面级权限</h3><p>页面及权限主要靠vue-router来实现。基本思路是为全局注册一个“前置守卫”钩子函数router.beforeEach。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123; ... &#125;)</span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这里检查权限并进行跳转</span></span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>每个守卫方法接收三个参数：<br>1、<code>to</code>:Route 即将要进入的目标<br>2、<code>from</code>: Route 当前导航正要离开的路由<br>3、<code>next</code>: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。<br><code>next()</code>: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed （确认的）。<br><code>next(false)</code>: 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 from 路由对应的地址。<br><code>next(&#39;/&#39;)</code>或者 <code>next({ path: &#39;/&#39; })</code>: 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。<br>你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: ‘home’ 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项。<br><code>next(error)</code>: (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Vue 单页面应用的权限管理有两种方法：&lt;code&gt;接口级权限&lt;/code&gt;；&lt;code&gt;页面级权限&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;接口级权限&quot;&gt;&lt;a href=&quot;#接口级权限&quot; class=&quot;headerlink&quot; title=&quot;接口级权限&quot;&gt;&lt;/a&gt;接口级权限&lt;
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vue数据传递</title>
    <link href="http://yoursite.com/2018/10/18/%5BVue%5Dvue%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/"/>
    <id>http://yoursite.com/2018/10/18/[Vue]vue数据传递/</id>
    <published>2018-10-18T08:47:41.000Z</published>
    <updated>2018-10-19T15:18:36.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="父组件到子组件"><a href="#父组件到子组件" class="headerlink" title="父组件到子组件"></a>父组件到子组件</h2><h3 id="方法一：Prop方法"><a href="#方法一：Prop方法" class="headerlink" title="方法一：Prop方法"></a>方法一：Prop方法</h3><p>在父组件调用子组件时通过v-bind(:)绑定动态数据，在子组件，使用Prop方法（单项绑定，防止数据倒流）<br>父：</p><p><edit-dialog :dialogdata="dialogData" :rendom="new Date().getTime()"></edit-dialog></p><p>子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  dialogData: <span class="built_in">Object</span>,</span><br><span class="line">  rendom: <span class="built_in">Number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>子组件中通过watch方法来监控数据是否改变，可触发相应的方法。</p><h3 id="方法二：provide-inject"><a href="#方法二：provide-inject" class="headerlink" title="方法二：provide/inject"></a>方法二：provide/inject</h3><p>provider/inject：在父组件中通过provider来提供变量，在子组件中通过inject来注入变量。<br>不论子组件有多深，只要调用了inject那么就可以注入provider中的数据。而不是局限于只能从当前父组件的prop属性来获取数据，只要在父组件的生命周期内，子组件都可以调用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">"Parent"</span>,</span><br><span class="line">  provide: &#123;     <span class="comment">//重要一步，在父组件中注入一个变量</span></span><br><span class="line">    <span class="keyword">for</span>: <span class="string">"demo"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  components:&#123;</span><br><span class="line">    childOne</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">"childOne"</span>,</span><br><span class="line">  inject: [<span class="string">'for'</span>],   <span class="comment">//子孙组件中使用inject接住变量即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="子组件到父组件"><a href="#子组件到父组件" class="headerlink" title="子组件到父组件"></a>子组件到父组件</h2><h3 id="方法一：发送-监听事件"><a href="#方法一：发送-监听事件" class="headerlink" title="方法一：发送/监听事件"></a>方法一：发送/监听事件</h3><p>在父组件中使用v-on(@)绑定自定义事件接收，在子组件中使用$emit来监控，并传给回掉。<br>父：</p><p><edit-dialog @message="recieveMessage"></edit-dialog></p><p>子：<br>this.$emit(‘message’, data)</p><h3 id="方法二：-children、-ref或-parent"><a href="#方法二：-children、-ref或-parent" class="headerlink" title="方法二：$children、$ref或$parent"></a>方法二：$children、$ref或$parent</h3><p><code>$children</code>: 返回所有子组件的实例，是一个数组。如果能清楚的知道子组件的顺序，也可以使用下标来操作；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.$children.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.$children[i].children_data);</span><br><span class="line">  <span class="keyword">this</span>.$children[i].children_fun();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>1、<code>$ref</code>：给子组件做标记，即可在父组件中调用到子组件的数据和方法<br>首先在子组件做标记： <firstchild ref="one"></firstchild><br>然后在父组件中，通过<code>this.$refs.one</code>就可以访问该子组件，包括访问子组件的data里面的数据，调用它的函数。<br>2、<code>ref</code> 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。<br>如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素;<br>如果用在子组件上，引用就指向组件实例。<br>3、子组件访问根组件<code>$root</code>当前组件树的根 Vue 实例。如果当前实例没有父实例，此实例将会是其自已。<br>4、<code>$parent</code>在子组件中调用父组件的方法或获得其数据。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parents.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">'parents'</span>&gt;</span><br><span class="line">            &lt;p&gt;我是父组件</span><br><span class="line">              &lt;button @click=<span class="string">"click1hanlde"</span>&gt;获取子组件<span class="number">1</span>的数据与方法&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">              &lt;button @click="click2hanlde"&gt;获取所有子组件的数据和方法&lt;/</span>button&gt;<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">             &lt;children1 ref=<span class="string">"children1"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">children1</span>&gt;</span></span></span><br><span class="line">             &lt;children2 ref=<span class="string">"children2"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">children2</span>&gt;</span></span></span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">import</span> children1 <span class="keyword">from</span> <span class="string">'./children1.vue'</span></span><br><span class="line">  <span class="keyword">import</span> children2 <span class="keyword">from</span> <span class="string">'./children2.vue'</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    components:&#123;</span><br><span class="line">      children1, children2</span><br><span class="line">    &#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ParentData:<span class="string">'AAA'</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">      click1hanlde()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$refs.children1.children_data)</span><br><span class="line">        <span class="keyword">this</span>.$refs.children1.children_fun();</span><br><span class="line">      &#125;,</span><br><span class="line">      click2hanlde()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.$children.length;i++)&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="keyword">this</span>.$children[i].children_data);</span><br><span class="line">          <span class="keyword">this</span>.$children[i].children_fun();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      showParentData()&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.ParentData)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="非父子组件-eventBus-vuex"><a href="#非父子组件-eventBus-vuex" class="headerlink" title="非父子组件 eventBus / vuex"></a>非父子组件 eventBus / vuex</h2><p>有时候两个组件也需要通信(非父子关系)。在简单的场景下，可以使用一个空的 Vue 实例作为中央事件总线：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eventBus.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vue();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送事件（发送数据）</span></span><br><span class="line"><span class="keyword">import</span> bus <span class="keyword">from</span> <span class="string">'@/bus'</span>;</span><br><span class="line">bus.$emit(<span class="string">'childa-message'</span>, <span class="keyword">this</span>.data); <span class="comment">// 方法内执行下面动作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件内监听（接收数据组件）</span></span><br><span class="line"><span class="keyword">import</span> bus <span class="keyword">from</span> <span class="string">'@/bus'</span>;</span><br><span class="line">bus.$on(<span class="string">'childa-message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;    <span class="comment">// 方法内执行下面动作</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'I get it'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><a href="http://pfuoi64aq.bkt.clouddn.com/vue.webp" target="_blank" rel="noopener">了解整个vue</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;父组件到子组件&quot;&gt;&lt;a href=&quot;#父组件到子组件&quot; class=&quot;headerlink&quot; title=&quot;父组件到子组件&quot;&gt;&lt;/a&gt;父组件到子组件&lt;/h2&gt;&lt;h3 id=&quot;方法一：Prop方法&quot;&gt;&lt;a href=&quot;#方法一：Prop方法&quot; class=&quot;head
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>webpack 到应用</title>
    <link href="http://yoursite.com/2018/10/18/%5B%E6%9E%84%E5%BB%BA%5D%20webpack%E5%88%B0%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2018/10/18/[构建] webpack到应用/</id>
    <published>2018-10-17T16:39:31.000Z</published>
    <updated>2018-10-18T17:01:39.616Z</updated>
    
    <content type="html"><![CDATA[<p><a href="#ES6项目">ES6项目</a><br><a href="#TypeScript项目">TypeScript项目</a><br><a href="#Flow检查器">Flow 检查器</a><br><a href="#SCSS">SCSS</a><br><a href="#PostCSS">PostCSS</a><br><a href="#Vue框架">Vue框架</a></p><h3 id="ES6项目"><a href="#ES6项目" class="headerlink" title="ES6项目"></a>ES6项目</h3><p>可以使用.bablerc对ES6、ES7进行配置<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: [<span class="string">'babel-loader'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 输出 source-map 方便直接调试 ES6 源码</span></span><br><span class="line">  devtool: <span class="string">'source-map'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安装依赖</span></span><br><span class="line"><span class="comment">// Webpack 接入 Babel 必须依赖的模块</span></span><br><span class="line">npm i -D babel-core babel-loader </span><br><span class="line"><span class="comment">// 根据你的需求选择不同的 Plugins 或 Presets</span></span><br><span class="line">npm i -D babel-preset-env</span><br></pre></td></tr></table></figure></p><h3 id="TypeScript项目"><a href="#TypeScript项目" class="headerlink" title="TypeScript项目"></a>TypeScript项目</h3><p>Ts 是 Js 的一个超集，主要提供了类型检查系统和对 ES6 语法的支持，但不支持新的 API。<br>方法一：建立配置编译选项的<code>tsconfig.json</code>文件<br>方法二：集成Webpack<br>需要解决以下2个问题：<br>1、通过 Loader 把 Ts 转换成 Js。 推荐 <code>awesome-typescript-loader</code>。<br>  安装：npm i -D typescript awesome-typescript-loader<br>2、Webpack 在寻找模块对应的文件时需要尝试 ts 后缀，解决办法：修改默认的 <code>resolve.extensions</code> 配置项<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tsconfig.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="string">"module"</span>: <span class="string">"commonjs"</span>, <span class="comment">// 编译出的代码采用的模块规范</span></span><br><span class="line">    <span class="string">"target"</span>: <span class="string">"es5"</span>, <span class="comment">// 编译出的代码采用 ES 的哪个版本</span></span><br><span class="line">    <span class="string">"sourceMap"</span>: <span class="literal">true</span>, <span class="comment">// 输出 Source Map 方便调试</span></span><br><span class="line">    <span class="string">"importHelpers"</span>: <span class="literal">true</span>   <span class="comment">// 避免代码冗余</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"exclude"</span>: [ <span class="comment">// 不编译这些目录里的文件</span></span><br><span class="line">    <span class="string">"node_modules"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集成 Webpack</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 执行入口文件</span></span><br><span class="line">  entry: <span class="string">'./main'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'./dist'</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">'.ts'</span>, <span class="string">'.js'</span>]  <span class="comment">// 先尝试 ts 后缀的 TypeScript 源码文件</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">        loader: <span class="string">'awesome-typescript-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: <span class="string">'source-map'</span>,  <span class="comment">// 输出 Source Map 方便在浏览器里调试 TypeScript 代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="Flow检查器"><a href="#Flow检查器" class="headerlink" title="Flow检查器"></a>Flow检查器</h3><p>Flow 是一个 Facebook 开源的 JS 静态类型检测器，它是 JS 语言的超集，在需要的地方加上类型检查。<br>采用了 Flow 静态类型语法的 JS 是无法直接在目前已有的 JS 引擎中运行，要让代码可以运行需要把这些静态类型语法去掉。<br>有两种方式可以做到这点：<br>1、<code>flow-remove-types</code> 可单独使用，速度快。<br>2、<code>babel-preset-flow</code> 与 <code>Babel</code> 集成。<br>方法二：采用webpack<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改 .babelrc 配置文件，加入 Flow Preset</span></span><br><span class="line"><span class="comment">// 安装 npm i -D babel-preset-flow 依赖到项目</span></span><br><span class="line"><span class="string">"presets"</span>: [</span><br><span class="line">  ...[],</span><br><span class="line">  <span class="string">"flow"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="SCSS"><a href="#SCSS" class="headerlink" title="SCSS"></a>SCSS</h3><p>SCSS 可以让你用更灵活的方式写 CSS。 它是一种 CSS 预处理器，语法和 CSS 相似，但加入了变量、逻辑、等编程元素。<br>好处：可以方便地管理代码，抽离公共的部分，通过逻辑写出更灵活的代码。<br>SCSS 又叫 SASS，区别在于 SASS 语法类似 Ruby，而 SCSS 语法类似 CSS。</p><h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><p>通过 node-sass 编译 .scss 文件  <code>node-sass main.scss main.css</code></p><h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><p>接入 Webpack：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 增加对 SCSS 文件的支持</span></span><br><span class="line">        test: <span class="regexp">/\.scss/</span>,</span><br><span class="line">        <span class="comment">// SCSS 文件的处理顺序为先 sass-loader 再 css-loader 再 style-loader</span></span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'sass-loader'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>1、通过 sass-loader 把 SCSS 源码转换为 CSS 代码，再把 CSS 代码交给 css-loader 去处理。<br>2、css-loader 会找出 CSS 代码中的 @import 和 url() 这样的导入语句，告诉 Webpack 依赖这些资源。同时还支持 CSS Modules、压缩 CSS 等功能。处理完后再把结果交给 style-loader 去处理。<br>3、style-loader 会把 CSS 代码转换成字符串后，注入到 JS 代码中去，通过 JS 去给 DOM 增加样式。<br>如果你想把 CSS 代码提取到一个单独的文件而不是和 JS 混在一起，可以使用 <code>ExtractTextPlugin。</code><br>4、注意：<code>sass-loader 依赖 node-sass</code></p><h3 id="PostCSS"><a href="#PostCSS" class="headerlink" title="PostCSS"></a>PostCSS</h3><p><code>PostCSS</code> 是一个 CSS 处理工具，和 SCSS 不同的地方在于它通过插件机制可以灵活的扩展其支持的特性，而不是像 SCSS 那样语法是固定的。<br><code>PostCSS</code> 的用处非常多，包括<strong>给 CSS 自动加前缀</strong>、<strong>使用下一代 CSS 语法</strong>等</p><h4 id="方法一：postcss-config-js"><a href="#方法一：postcss-config-js" class="headerlink" title="方法一：postcss.config.js"></a>方法一：<code>postcss.config.js</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 需要使用的插件列表</span></span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'postcss-cssnext'</span>)    <span class="comment">// postcss-cssnext 插件: 使用下一代 CSS 语法编写代码</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法一：接入-Webpack"><a href="#方法一：接入-Webpack" class="headerlink" title="方法一：接入 Webpack"></a>方法一：接入 Webpack</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 使用 PostCSS 处理 CSS 文件</span></span><br><span class="line">        test: <span class="regexp">/\.css/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Vue框架"><a href="#Vue框架" class="headerlink" title="Vue框架"></a>Vue框架</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">      use: [<span class="string">'vue-loader'</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><p>安装依赖：npm i -D vue-loader css-loader vue-template-compiler。它们的作用分别是：<br>1、<code>vue-loader</code>：解析和转换 .vue 文件，提取出其中的逻辑代码 script、样式代码 style、以及 HTML 模版 template，再分别把它们交给对应的 Loader 去处理。<br>2、<code>css-loader</code>：加载由 vue-loader 提取出的 CSS 代码。<br>3、<code>vue-template-compiler</code>：把 vue-loader 提取出的 HTML 模版编译成对应的可执行的 JS 代码，这和 React 中的 JSX 语法被编译成 JS 代码类似。预先编译好 HTML 模版相对于在浏览器中再去编译 HTML 模版的好处在于性能更好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;#ES6项目&quot;&gt;ES6项目&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#TypeScript项目&quot;&gt;TypeScript项目&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#Flow检查器&quot;&gt;Flow 检查器&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#SCSS&quot;&gt;SCSS&lt;/a&gt;&lt;br&gt;
      
    
    </summary>
    
      <category term="构建" scheme="http://yoursite.com/categories/%E6%9E%84%E5%BB%BA/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>ES6基础知识 — 字符串的扩展</title>
    <link href="http://yoursite.com/2018/10/17/%5BES6%5DES6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/2018/10/17/[ES6]ES6基础知识—字符串的扩展/</id>
    <published>2018-10-17T12:28:31.000Z</published>
    <updated>2018-10-17T15:33:17.791Z</updated>
    
    <content type="html"><![CDATA[<p><a href="#1、字符的Unicode表示法">1、字符的Unicode表示法</a><br><a href="#2、codePointAt">2、codePointAt</a><br><a href="#3、String.fromCodePoint">3、String.fromCodePoint</a><br><a href="#4、字符串的遍历器接口for...of...">4、字符串的遍历器接口for…of…</a><br><a href="#5、normalize">5、normalize</a><br><a href="#6、includes, startsWith, endsWith">6、includes(), startsWith(), endsWith()</a><br><a href="#7、repeat">7、repeat</a><br><a href="#8、padStart，padEnd">8、padStart，padEnd</a><br><a href="#9、matchAll">9、matchAll</a><br><a href="#10、模板字符串">10、模板字符串</a><br><a href="#11、String.raw">11、String.raw</a></p><h3 id="1、字符的Unicode表示法"><a href="#1、字符的Unicode表示法" class="headerlink" title="1、字符的Unicode表示法"></a>1、字符的Unicode表示法</h3><p>JS允许采用<code>\uxxxx</code>形式表示一个字符，其中<code>xxxx</code>表示字符的<code>Unicode</code>码点， 只限于码点在<code>\u0000</code>~<code>\uFFFF</code><br>JS 共有 6 种方法可以表示一个字符:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\z'</span> === <span class="string">'z'</span>      <span class="comment">// true</span></span><br><span class="line"><span class="string">'\172'</span> === <span class="string">'z'</span>    <span class="comment">// true</span></span><br><span class="line"><span class="string">'\x7A'</span> === <span class="string">'z'</span>    <span class="comment">// true</span></span><br><span class="line"><span class="string">'\u007A'</span> === <span class="string">'z'</span>  <span class="comment">// true</span></span><br><span class="line"><span class="string">'\u&#123;7A&#125;'</span> === <span class="string">'z'</span>  <span class="comment">// true   ES6的改进</span></span><br></pre></td></tr></table></figure></p><h3 id="2、codePointAt"><a href="#2、codePointAt" class="headerlink" title="2、codePointAt"></a>2、codePointAt</h3><p>能够正确说明字符的字节数，返回字符码点的十进制数</p><h3 id="3、String-fromCodePoint"><a href="#3、String-fromCodePoint" class="headerlink" title="3、String.fromCodePoint"></a>3、String.fromCodePoint</h3><p><code>String.fromCharCode</code>从码点返回对应字符，但不能识别 32 位的 UTF-16 字符<br><code>String.fromCodePoint</code>方法弥补不足，有多个参数，则它们会被合并成一个字符串返回</p><font color="#dd0000"><code>fromCodePoint</code>方法定义在<code>String</code>对象上，而<code>codePointAt</code>方法定义在字符串的实例对象上。</font><h3 id="4、字符串的遍历器接口for…of…"><a href="#4、字符串的遍历器接口for…of…" class="headerlink" title="4、字符串的遍历器接口for…of…"></a>4、字符串的遍历器接口for…of…</h3><p>for…of…：字符串可被循环遍历，可以识别大于0xFFFF的码点</p><h3 id="5、normalize"><a href="#5、normalize" class="headerlink" title="5、normalize"></a>5、normalize</h3><p>用来将字符的不同表示方法统一为同样的形式，称为 Unicode 正规化（该方法可传参，具体需要再查）</p><h3 id="6、includes-startsWith-endsWith"><a href="#6、includes-startsWith-endsWith" class="headerlink" title="6、includes, startsWith, endsWith"></a>6、includes, startsWith, endsWith</h3><p><code>indexOf</code>一个字符串是否包含在另一个字符串中<br><code>includes(str, n)</code>是否找到了参数字符串，n表示开始搜索的位置：<br><code>startsWith(str, n)</code>参数字符串是否在原字符串的头部，n表示开始搜索的位置：<br><code>endsWith(str, n)</code>参数字符串是否在原字符串的尾部，n表示开始搜索的位置：</p><h3 id="7、repeat"><a href="#7、repeat" class="headerlink" title="7、repeat"></a>7、repeat</h3><p>将原字符串重复n次，参数若是小数，会被取整；参数是负数或者Infinity，会报错；参数NaN等同于 0。</p><h3 id="8、padStart，padEnd"><a href="#8、padStart，padEnd" class="headerlink" title="8、padStart，padEnd"></a>8、padStart，padEnd</h3><p><code>padStart(n, str)</code>：用于字符串在头部补全，n指定字符串的最小长度，arr用来补全的字符串。<br><code>padEnd(n, str)</code>：字符串在尾部补全，n指定字符串的最小长度，arr用来补全的字符串。<br>如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。<br>如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。<br>如果省略第二个参数，默认使用空格补全长度。</p><h3 id="9、matchAll"><a href="#9、matchAll" class="headerlink" title="9、matchAll"></a>9、matchAll</h3><p>返回一个正则表达式在当前字符串的所有匹配</p><h3 id="10、模板字符串"><a href="#10、模板字符串" class="headerlink" title="10、模板字符串"></a>10、模板字符串</h3><p><code>${}和引号</code>的使用</p><h3 id="11、String-raw"><a href="#11、String-raw" class="headerlink" title="11、String.raw"></a>11、String.raw</h3><p>模板字符串的处理函数<br>返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串<br>String.raw<code>Hi\n${2+3}!</code>;    // 返回 “Hi\n5!”<br>String.raw<code>Hi\u000A!</code>;    // 返回 “Hi\u000A!”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、codePointAt</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"𠮷"</span>;</span><br><span class="line">str.length;   <span class="comment">// length为2，无法正确返回，其为4字节的字符</span></span><br><span class="line">str.charAt(<span class="number">0</span>);  <span class="comment">//'�' 会导致乱码</span></span><br><span class="line">str.charAt(<span class="number">1</span>);  <span class="comment">//'�' 会导致乱码</span></span><br><span class="line">str.codePointAt();  <span class="comment">// 结果:134071</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、fromCodePoint</span></span><br><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0x20BB7</span>)</span><br><span class="line"><span class="comment">// "𠮷"</span></span><br><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0x78</span>, <span class="number">0x1f680</span>, <span class="number">0x79</span>) === <span class="string">'x\uD83D\uDE80y'</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、字符串的遍历器接口for...of...</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> codePoint <span class="keyword">of</span> <span class="string">'foo'</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(codePoint);      <span class="comment">// "f"  // "o"  // "o"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> text = <span class="built_in">String</span>.fromCodePoint(<span class="number">0x20BB7</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> text) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);       <span class="comment">// "𠮷"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、includes(), startsWith(), endsWith()</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="string">'Hello world!'</span>;</span><br><span class="line">s.startsWith(<span class="string">'world'</span>, <span class="number">6</span>)  <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">'Hello'</span>, <span class="number">5</span>)    <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">'Hello'</span>, <span class="number">6</span>)    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5、repeat</span></span><br><span class="line"><span class="string">'hello'</span>.repeat(<span class="number">2</span>) <span class="comment">// "hellohello"</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="number">2.9</span>) <span class="comment">// "nana"</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="string">'na'</span>) <span class="comment">// ""</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="string">'3'</span>) <span class="comment">// "nanana"</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="number">-0.9</span>) <span class="comment">// ""</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="literal">NaN</span>) <span class="comment">// ""</span></span><br><span class="line"></span><br><span class="line"><span class="string">'xxx'</span>.padStart(<span class="number">2</span>, <span class="string">'ab'</span>)     <span class="comment">// 'xxx'</span></span><br><span class="line"><span class="string">'xxx'</span>.padEnd(<span class="number">2</span>, <span class="string">'ab'</span>)       <span class="comment">// 'xxx'  </span></span><br><span class="line"><span class="string">'abc'</span>.padStart(<span class="number">10</span>, <span class="string">'0123456789'</span>)    <span class="comment">// '0123456abc'</span></span><br><span class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>)         <span class="comment">// '   x'</span></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">4</span>)           <span class="comment">// 'x   '</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;#1、字符的Unicode表示法&quot;&gt;1、字符的Unicode表示法&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2、codePointAt&quot;&gt;2、codePointAt&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3、String.fromCodePoint&quot;&gt;3、Strin
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6基础知识 — let和const命令</title>
    <link href="http://yoursite.com/2018/10/17/%5BES6%5DES6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94let%E5%92%8Cconst%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/10/17/[ES6]ES6基础知识—let和const命令/</id>
    <published>2018-10-17T12:23:12.000Z</published>
    <updated>2018-10-17T13:29:59.865Z</updated>
    
    <content type="html"><![CDATA[<p><a href="#1、let和const的性质">1、let和const的性质</a><br><a href="#2、块级作用域">2、块级作用域</a><br><a href="#3、顶层对象的属性">3、顶层对象的属性</a><br><a href="#4、global 对象">4、global 对象</a></p><h3 id="1、let和const的性质"><a href="#1、let和const的性质" class="headerlink" title="1、let和const的性质"></a>1、let和const的性质</h3><p>1、<code>let</code>、<code>const</code>声明的变量只在声明所在的块级作用域内有效；<strong>const 一旦声明变量，就必须立即初始化，不能留到以后赋值。</strong><br>2、不存在变量提升；<br>3、暂时性死区: 在代码块内，只能在声明的位置后面使用；<br>4、不允许在相同作用域内，重复声明同一个变量；</p><font color="#dd0000">对于简单类型的数据（数值、字符串、布尔值），const等同于常量。</font><br><font color="#dd0000">对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。</font><br><font color="#dd0000">如果将对象冻结，可以使用Object.freeze方法。</font><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、变量声明提升</span></span><br><span class="line"><span class="comment">// var 的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 输出undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// let 的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// 报错ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、暂时性死区案例</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// TDZ开始</span></span><br><span class="line">  tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> tmp; <span class="comment">// TDZ结束</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">  tmp = <span class="number">123</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、对象冻结</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line"><span class="comment">// 常规模式时，下面一行不起作用；严格模式时，该行会报错</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、除了将对象本身冻结，对象的属性也应该冻结。</span></span><br><span class="line"><span class="keyword">var</span> constantize = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach( <span class="function">(<span class="params">key, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span> ) &#123;</span><br><span class="line">      constantize( obj[key] );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2、块级作用域"><a href="#2、块级作用域" class="headerlink" title="2、块级作用域"></a>2、块级作用域</h3><p>提出原因：内层变量可能会覆盖外层变量；用来计数的循环变量泄露为全局变量……<br>实现作用：是在块内使用，不影响外面，外面的变量，内部也能定义。</p><font color="#dd0000">ES6 有 6 种声明变量的方法：<code>var</code>、<code>function</code>、<code>let</code>、<code>const</code>、<code>import</code>、<code>class</code></font><h3 id="3、顶层对象的属性"><a href="#3、顶层对象的属性" class="headerlink" title="3、顶层对象的属性"></a>3、顶层对象的属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.a = 1;</span><br><span class="line">a   // 返回 1</span><br><span class="line">a = 2;</span><br><span class="line">window.a // 返回 2</span><br></pre></td></tr></table></figure><p>上述代码的弊端：<br>1、不能在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；<br>2、其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；<br>3、顶层对象的属性是到处可以读写的，这非常不利于模块化编程。<br>4、window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</p><p><font color="#dd0000"><code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象的属性；</font></p><p><font color="#dd0000"><code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。</font><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果在 Node 的 REPL 环境，可以写成 global.a</span></span><br><span class="line"><span class="comment">// 或者采用通用方法，写成 this.a</span></span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 返回 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">window</span>.b <span class="comment">// 返回 undefined</span></span><br></pre></td></tr></table></figure></p><h3 id="4、global-对象"><a href="#4、global-对象" class="headerlink" title="4、global 对象"></a>4、global 对象</h3><p>目的：为了在不同的环境中都能获取到顶层对象。<br>ES5顶层对象的获取：<br>1、浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。<br>2、浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。<br>3、Node 里面，顶层对象是global，但其他环境都不支持。</p><p>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。<br>1、全局环境中，this会返回顶层对象。但Node 模块和 ES6 模块中，this返回的是当前模块。<br>2、函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。<br>3、不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么eval、new Function这些方法都可能无法使用。</p><p>提出了<code>垫片库system.global</code>.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS 的写法</span></span><br><span class="line"><span class="keyword">var</span> global = <span class="built_in">require</span>(<span class="string">'system.global'</span>)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 模块的写法</span></span><br><span class="line"><span class="keyword">import</span> getGlobal <span class="keyword">from</span> <span class="string">'system.global'</span>;</span><br><span class="line"><span class="keyword">const</span> global = getGlobal();</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;#1、let和const的性质&quot;&gt;1、let和const的性质&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2、块级作用域&quot;&gt;2、块级作用域&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3、顶层对象的属性&quot;&gt;3、顶层对象的属性&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#4、globa
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>移动浏览器的四大内核</title>
    <link href="http://yoursite.com/2018/10/15/%5B%E7%A7%BB%E5%8A%A8%E7%AB%AF%5D%E7%A7%BB%E5%8A%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9B%9B%E5%A4%A7%E5%86%85%E6%A0%B8/"/>
    <id>http://yoursite.com/2018/10/15/[移动端]移动浏览器的四大内核/</id>
    <published>2018-10-15T06:20:45.000Z</published>
    <updated>2018-10-15T06:21:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="四大浏览器内核优缺点"><a href="#四大浏览器内核优缺点" class="headerlink" title="四大浏览器内核优缺点"></a>四大浏览器内核优缺点</h2><ol><li>Trident:因为在早期IE占有大量的市场份额，所以以前有很多网页是根据这个Trident的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好，同时存在许多安全Bug。</li><li>Gecko:优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，缺点是消耗很多的资源，比如内存。</li><li>Webkit:优点就是Webkit拥有清晰的源码结构、极快的渲染速度，缺点是对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。</li><li>Presto：Presto内核被称为公认的浏览网页速度最快的内核，同时也是处理JS脚本最兼容的内核，能在Windows、Mac及Linux操作系统下完美运行。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;四大浏览器内核优缺点&quot;&gt;&lt;a href=&quot;#四大浏览器内核优缺点&quot; class=&quot;headerlink&quot; title=&quot;四大浏览器内核优缺点&quot;&gt;&lt;/a&gt;四大浏览器内核优缺点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Trident:因为在早期IE占有大量的市场份额，所以以前有很多
      
    
    </summary>
    
      <category term="移动端" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="移动端" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>跨域的实现方法</title>
    <link href="http://yoursite.com/2018/10/15/%5BJS%5D%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/10/15/[JS]跨域的实现方法/</id>
    <published>2018-10-15T03:09:12.000Z</published>
    <updated>2018-10-15T05:15:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>同源： “协议 + 域名 + 端口” 三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。<br>同源策略限制下 <code>cookie</code>、<code>localStorage</code>、<code>dom</code>、<code>ajax</code>、<code>IndexDB</code> 都是不支持跨域的。</p><h2 id="方法一、使用-jsonp-跨域"><a href="#方法一、使用-jsonp-跨域" class="headerlink" title="方法一、使用 jsonp 跨域"></a>方法一、使用 jsonp 跨域</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装 jsonp 跨域请求的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">&#123; url, params, cb &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 script 标签帮助我们发送请求</span></span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    params = &#123; ...params, cb &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环构建键值对形式的参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">        arr.push(<span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建全局函数</span></span><br><span class="line">    <span class="built_in">window</span>[cb] = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        resolve(data);</span><br><span class="line">        <span class="comment">// 在跨域拿到数据以后将 script 标签销毁</span></span><br><span class="line">        <span class="built_in">document</span>.body.removeChild(script);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接发送请求的参数并赋值到 src 属性</span></span><br><span class="line">    script.src = <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;arr.join(<span class="string">"&amp;"</span>)&#125;</span>`</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font color="#dd0000">缺点：</font><br>只能发送 get 请求 不支持 post、put、delete；<br>不安全，容易引发 xss 攻击。<br><br>## 方法二、使用 CORS 跨域<br><font color="#dd0000">使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。</font><p>使用场景：多用于开发时，前端与后台在不同的 ip 地址下进行数据访问。<br>案例说明：通过访问 <a href="http://localhost:3000/index.html（服务器1）" target="_blank" rel="noopener">http://localhost:3000/index.html（服务器1）</a> 获取 index.html 文件并执行其中的 Ajax 请求 <a href="http://localhost:4000/getDate（服务器2）" target="_blank" rel="noopener">http://localhost:4000/getDate（服务器2）</a> 接口去获取数据。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// 正常 cookie 是不允许跨域的</span></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'name=hello'</span>;</span><br><span class="line"><span class="comment">// cookie 想要实现跨域必须携带凭证</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// xhr.open('GET', 'http://localhost:4000/getDate', true);</span></span><br><span class="line">xhr.open(<span class="string">'PUT'</span>, <span class="string">'http://localhost:4000/getDate'</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置名为 name 的自定义请求头</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">'name'</span>, <span class="string">'hello'</span>);</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span> || xhr.status === <span class="number">304</span>) &#123;</span><br><span class="line">      <span class="comment">// 打印返回的数据</span></span><br><span class="line">      <span class="built_in">console</span>.log(xhr.response);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 打印后台设置的自定义头信息</span></span><br><span class="line">      <span class="built_in">console</span>.log(xhr.getResponseHeader(<span class="string">'name'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器2</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许访问域的白名单</span></span><br><span class="line"><span class="keyword">let</span> whiteList = [<span class="string">"http://localhost:3000"</span>];</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> origin = req.header.origin;</span><br><span class="line">  <span class="keyword">if</span> (whiteList.includes(origin)) &#123;</span><br><span class="line">    <span class="comment">// 设置那个源可以访问我，参数为 * 时，允许任何人访问，但是不可以和 cookie 凭证的响应头共同使用</span></span><br><span class="line">    res.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>, origin);</span><br><span class="line">    <span class="comment">// 想要获取 ajax 的头信息，需设置响应头</span></span><br><span class="line">    res.setHeader(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"name"</span>);</span><br><span class="line">    <span class="comment">// 处理复杂请求的头</span></span><br><span class="line">    res.setHeader(<span class="string">"Access-Control-Allow-Methods"</span>, <span class="string">"PUT"</span>);</span><br><span class="line">    <span class="comment">// 允许发送 cookie 凭证的响应头</span></span><br><span class="line">    res.setHeader(<span class="string">"Access-Control-Allow-Credentials"</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 允许前端获取哪个头信息</span></span><br><span class="line">    res.setHeader(<span class="string">"Access-Control-Expose-Headers"</span>, <span class="string">"name"</span>);</span><br><span class="line">    <span class="comment">// 处理 OPTIONS 预检的存活时间，单位 s</span></span><br><span class="line">    res.setHeader(<span class="string">"Access-Control-Max-Age"</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 发送 PUT 请求会做一个试探性的请求 OPTIONS，其实是请求了两次，当接收的请求为 OPTIONS 时不做任何处理</span></span><br><span class="line">    <span class="keyword">if</span> (req.method === <span class="string">"OPTIONS"</span>) &#123;</span><br><span class="line">      res.end();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.put(<span class="string">"/getDate"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// res.setHeader('name', 'nihao'); // 设置自定义响应头信息</span></span><br><span class="line">  res.end(<span class="string">"I love you"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">"/getDate"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.end(<span class="string">"I love you"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(express.static(__dirname));</span><br><span class="line">app.listen(<span class="number">4000</span>);</span><br></pre></td></tr></table></figure><h2 id="方法三、使用-postMessage-实现跨域"><a href="#方法三、使用-postMessage-实现跨域" class="headerlink" title="方法三、使用 postMessage 实现跨域"></a>方法三、使用 postMessage 实现跨域</h2><p>postMessage 是 H5 的新 API，跨文档消息传送（cross-document messaging），有时简称为 XMD，指的是在来自不同域的页面间传递消息。</p><p><font color="#dd0000">使用场景：不是使用 Ajax 的数据通信，更多是在两个页面之间的通信，在 A 页面中引入 B 页面，使用iframe 标签, 在 A、B 两个页面之间通信。</font><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- a.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://localhost:4000/b.html"</span> <span class="attr">id</span>=<span class="string">"frame"</span> <span class="attr">onload</span>=<span class="string">"load()"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> frame = <span class="built_in">document</span>.getElementById(<span class="string">'frame'</span>);</span></span><br><span class="line"><span class="javascript">      frame.contentWindow.postMessage(<span class="string">'I love you'</span>, <span class="string">'http://localhost:4000'</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(e.data);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- b.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 打印来自页面 A 的消息</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(e.data);</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 给页面 A 发送回执</span></span></span><br><span class="line"><span class="javascript">      e.source.postMessage(<span class="string">'I love you, too'</span>, e.origin);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="方法四、使用-window-name-实现跨域"><a href="#方法四、使用-window-name-实现跨域" class="headerlink" title="方法四、使用 window.name 实现跨域"></a>方法四、使用 window.name 实现跨域</h2><p>同样是页面之间的通信，需要借助 iframe 标签<br>案例说明：A 页面和 B 页面是同域的 <a href="http://localhost:3000，C" target="_blank" rel="noopener">http://localhost:3000，C</a> 页面在独立的域 <a href="http://localhost:4000。" target="_blank" rel="noopener">http://localhost:4000。</a><br>在 A 页面中将 iframe 的 src 指向 C 页面，在 C 页面中将属性值存入 window.name 中，<br>再把 iframe 的 src 换成同域的 B 页面，在当前的 iframe 的 window 对象中取出 name 的值，访问 <a href="http://localhost:3000/a.html。" target="_blank" rel="noopener">http://localhost:3000/a.html。</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- a.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://localhost:4000/c.html"</span> <span class="attr">id</span>=<span class="string">"frame"</span> <span class="attr">onload</span>=<span class="string">"load()"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 增加一个标识，第一次触发 load 时更改地址，更改后再次触发直接取值</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> isFirst = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> frame = <span class="built_in">document</span>.getElementById(<span class="string">'frame'</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span>(isFirst) &#123;</span></span><br><span class="line"><span class="javascript">        frame.src = <span class="string">'http://localhost:3000/b.html'</span>;</span></span><br><span class="line"><span class="javascript">        isFirst = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(frame.contentWindow.name);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- c.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.name = <span class="string">'I love you'</span>;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="方法五、使用-location-hash-实现跨域"><a href="#方法五、使用-location-hash-实现跨域" class="headerlink" title="方法五、使用 location.hash 实现跨域"></a>方法五、使用 location.hash 实现跨域</h2><p><font color="#dd0000">与 window.name 跨域的情况相同，是不同域的页面间的参数传递</font><br>案例说明：需要借助 iframe 标签，A 页面和 B 页面是同域的 <a href="http://localhost:3000，C" target="_blank" rel="noopener">http://localhost:3000，C</a> 页面是独立的域 <a href="http://localhost:4000。" target="_blank" rel="noopener">http://localhost:4000。</a><br>A 页面通过 iframe 引入 C 页面，并给 C 页面传一个 hash 值，C 页面收到 hash 值后创建 iframe 引入 B 页面，<br>把 hash 值传给 B 页面，B 页面将自己的 hash 值放在 A 页面的 hash 值中，访问 <a href="http://localhost:3000/a.html。" target="_blank" rel="noopener">http://localhost:3000/a.html。</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- a.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://localhost:4000/c.html#Iloveyou"</span> <span class="attr">id</span>=<span class="string">"frame"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 使用 hashchange 事件接收来自 B 页面设置给 A 页面的 hash 值</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(location.hash);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- c.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 打印 A 页面引入 C 页面设置的 hash 值</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(location.hash);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span></span><br><span class="line"><span class="javascript">    iframe.src = <span class="string">'http://localhost:3000/b.html#Iloveyoutoo'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.appendChild(iframe);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- b.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 将 C 页面引入 B 页面设置的 hash 值设置给 A页面</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.parent.parent.location.hash = location.hash;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="方法六、使用-document-domain-实现跨域"><a href="#方法六、使用-document-domain-实现跨域" class="headerlink" title="方法六、使用 document.domain 实现跨域"></a>方法六、使用 document.domain 实现跨域</h2><p><font color="#dd0000">使用场景：不是万能的跨域方式，大多使用于同一公司不同产品间获取数据，必须是一级域名和二级域名的关系，如 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 与 video.baidu.com 之间。</font><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- http://www.domainacross.com:3000/a.html。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是页面 A 的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://sucess.domainacross.com:3000/b.html"</span> <span class="attr">onload</span>=<span class="string">"load()"</span> <span class="attr">id</span>=<span class="string">"frame"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.domain = <span class="string">'domainacross.com'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(frame.contentWindow.message);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是 B 页面的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.domain = <span class="string">'domainacross.com'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> message = <span class="string">'Hello A'</span>;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="方法七、使用-WebSocket-实现跨域"><a href="#方法七、使用-WebSocket-实现跨域" class="headerlink" title="方法七、使用 WebSocket 实现跨域"></a>方法七、使用 WebSocket 实现跨域</h2><p>WebSocket 没有跨域限制，高级 API（不兼容），想要兼容低版本浏览器，可以使用 socket.io 的库，<br>WebSocket 与 HTTP 内部都是基于 TCP 协议，区别在于 HTTP 是单向的（单双工），WebSocket 是双向的（全双工），<br>协议是 ws:// 和 wss:// 对应 http:// 和 https://，因为没有跨域限制，所以使用 file:// 协议也可以进行通信。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 创建 webSocket</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:3000'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 连接上触发</span></span></span><br><span class="line"><span class="javascript">    socket.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      socket.send(<span class="string">'I love you'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 收到消息触发</span></span></span><br><span class="line"><span class="javascript">    socket.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 打印收到的数据</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(e.data); <span class="comment">// I love you, too</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入 webSocket</span></span><br><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">"ws"</span>);</span><br><span class="line"><span class="comment">// 创建连接，端口号与前端相对应</span></span><br><span class="line"><span class="keyword">let</span> wss = <span class="keyword">new</span> WebSocket.Server(&#123; <span class="attr">port</span>: <span class="number">3000</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听连接</span></span><br><span class="line">wss.on(<span class="string">"connection"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ws</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 监听消息</span></span><br><span class="line">  ws.on(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 打印消息</span></span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// I love you</span></span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    ws.send(<span class="string">"I love you, too"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="方法八、使用-nginx-实现跨域"><a href="#方法八、使用-nginx-实现跨域" class="headerlink" title="方法八、使用 nginx 实现跨域"></a>方法八、使用 nginx 实现跨域</h2><h2 id="方法九、使用-http-proxy-middleware-实现跨域"><a href="#方法九、使用-http-proxy-middleware-实现跨域" class="headerlink" title="方法九、使用 http-proxy-middleware 实现跨域"></a>方法九、使用 http-proxy-middleware 实现跨域</h2><p>NodeJS 中间件 http-proxy-middleware 实现跨域代理，原理大致与 nginx 相同，都是通过启一个代理服务器，实现数据的转发，<br>也可以通过设置 cookieDomainRewrite 参数修改响应头中 cookie 中的域名，实现当前域的 cookie 写入，方便接口登录认证。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;同源： “协议 + 域名 + 端口” 三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。&lt;br&gt;同源策略限制下 &lt;code&gt;cookie&lt;/code&gt;、&lt;code&gt;localStorage&lt;/code&gt;、&lt;code&gt;dom&lt;/code&gt;、&lt;code&gt;ajax&lt;/
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Http协议知识</title>
    <link href="http://yoursite.com/2018/10/12/%5BHttp%5DHttp%E5%8D%8F%E8%AE%AE%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2018/10/12/[Http]Http协议知识/</id>
    <published>2018-10-12T07:44:41.000Z</published>
    <updated>2018-10-12T08:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="http协议的请求报文组成格式"><a href="#http协议的请求报文组成格式" class="headerlink" title="http协议的请求报文组成格式"></a>http协议的请求报文组成格式</h2><p>HTTP请求报文组成：请求行（＜request-line＞）、请求头部（＜headers＞）、空行（＜blank line＞）和请求数据（＜request-body＞）。</p><h4 id="1-请求行"><a href="#1-请求行" class="headerlink" title="1. 请求行"></a>1. 请求行</h4><p>请求行组成：请求方法、URL和HTTP协议版本字段组成，它们用空格分隔。<br>例如，GET /index.html HTTP/1.1。</p><font color="#dd0000">HTTP协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。</font><h4 id="2-请求头部"><a href="#2-请求头部" class="headerlink" title="2.请求头部"></a>2.请求头部</h4><p>请求头部通知服务器有关于客户端请求的信息：<br><code>User-Agent</code>：产生请求的浏览器类型。<br><code>Accept</code>：客户端可识别的内容类型列表。<br><code>Host</code>：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。</p><h4 id="3-请求数据"><a href="#3-请求数据" class="headerlink" title="3.请求数据"></a>3.请求数据</h4><p><font color="#dd0000">请求数据不在GET方法中使用，而是在POST方法中使用。</font><br>与请求数据相关的最常使用的请求头是Content-Type和Content-Length。</p><h2 id="http协议的响应报文组成格式"><a href="#http协议的响应报文组成格式" class="headerlink" title="http协议的响应报文组成格式"></a>http协议的响应报文组成格式</h2><p>HTTP响应也组成：状态行（＜status-line＞）、消息报头（＜headers＞）、响应正文（＜response-body＞）。</p><h4 id="1-状态行"><a href="#1-状态行" class="headerlink" title="1.状态行"></a>1.状态行</h4><p>状态行（status line）通过提供一个状态码来说明所请求的资源情况。</p><p>状态行格式：服务器HTTP协议的版本（HTTP-Version） 服务器发回的响应状态代码（Status-Code） 状态代码的文本描述（Reason-Phrase） CRLF<br>状态代码：</p><ul><li>1xx：指示信息–表示请求已接收，继续处理。</li><li>2xx：成功–表示请求已被成功接收、理解、接受。</li><li>3xx：重定向–要完成请求必须进行更进一步的操作。</li><li>4xx：客户端错误–请求有语法错误或请求无法实现。</li><li><p>5xx：服务器端错误–服务器未能实现合法的请求。</p></li><li><p>200 OK：客户端请求成功。</p></li><li>400 Bad Request：客户端请求有语法错误，不能被服务器所理解。</li><li>401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。</li><li>403 Forbidden：服务器收到请求，但是拒绝提供服务。</li><li>404 Not Found：请求资源不存在，举个例子：输入了错误的URL。</li><li>500 Internal Server  Error：服务器发生不可预期的错误。</li><li>503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。</li></ul><h2 id="状态码302与301的区别"><a href="#状态码302与301的区别" class="headerlink" title="状态码302与301的区别"></a>状态码302与301的区别</h2><p>302重定向表示临时性转移(Temporarily Moved )，当一个网页URL需要短期变化时使用。<br>301重定向/跳转一般，表示本网页永久性转移到另一个地址。<br>301是永久性转移(Permanently Moved), SEO常用的招式，会把旧页面的PR等信息转移到新页面<br>301重定向是永久的重定向，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。<br>302重定向是临时的重定向，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;http协议的请求报文组成格式&quot;&gt;&lt;a href=&quot;#http协议的请求报文组成格式&quot; class=&quot;headerlink&quot; title=&quot;http协议的请求报文组成格式&quot;&gt;&lt;/a&gt;http协议的请求报文组成格式&lt;/h2&gt;&lt;p&gt;HTTP请求报文组成：请求行（＜re
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Project Display</title>
    <link href="http://yoursite.com/2018/10/11/Project-Display/"/>
    <id>http://yoursite.com/2018/10/11/Project-Display/</id>
    <published>2018-10-11T05:10:11.000Z</published>
    <updated>2018-10-11T07:35:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="商城首页"><a href="#商城首页" class="headerlink" title="商城首页"></a>商城首页</h2><p><img src="http://pfuoi64aq.bkt.clouddn.com/%E9%A6%96%E9%A1%B5-%E9%A6%96%E9%A1%B5.png" width="70%" height="70%"></p><h2 id="红包雨活动"><a href="#红包雨活动" class="headerlink" title="红包雨活动"></a>红包雨活动</h2><h3 id="图1"><a href="#图1" class="headerlink" title="图1:"></a>图1:</h3><p><img src="http://pfuoi64aq.bkt.clouddn.com/WechatIMG505.jpeg" width="70%" height="70%"></p><h3 id="图2"><a href="#图2" class="headerlink" title="图2:"></a>图2:</h3><p><img src="http://pfuoi64aq.bkt.clouddn.com/WechatIMG506.jpeg" width="70%" height="70%"></p><h2 id="小程序-红包拼团"><a href="#小程序-红包拼团" class="headerlink" title="小程序 红包拼团"></a>小程序 红包拼团</h2><h3 id="图1-1"><a href="#图1-1" class="headerlink" title="图1:"></a>图1:</h3><p><img src="http://pfuoi64aq.bkt.clouddn.com/WechatIMG503.jpeg" width="40%" height="40%"></p><h3 id="图2-1"><a href="#图2-1" class="headerlink" title="图2:"></a>图2:</h3><p><img src="http://pfuoi64aq.bkt.clouddn.com/WechatIMG501.jpeg" width="40%" height="40%"></p><h3 id="图3"><a href="#图3" class="headerlink" title="图3:"></a>图3:</h3><p><img src="http://pfuoi64aq.bkt.clouddn.com/WechatIMG502.jpeg" width="40%" height="40%"></p><h3 id="图4"><a href="#图4" class="headerlink" title="图4:"></a>图4:</h3><p><img src="http://pfuoi64aq.bkt.clouddn.com/%E5%9B%BE%E7%89%87.png" alt="小程序 红包拼团"></p><h2 id="小程序-魅客分销"><a href="#小程序-魅客分销" class="headerlink" title="小程序 魅客分销"></a>小程序 魅客分销</h2><p><img src="http://pfuoi64aq.bkt.clouddn.com/IMG_2419.PNG" alt="小程序 魅客分销"></p><h2 id="前端异常监控-性能检测"><a href="#前端异常监控-性能检测" class="headerlink" title="前端异常监控 性能检测"></a>前端异常监控 性能检测</h2><h3 id="图1-2"><a href="#图1-2" class="headerlink" title="图1:"></a>图1:</h3><p><img src="http://pfuoi64aq.bkt.clouddn.com/WechatIMG499.jpeg" width="70%" height="70%"></p><h3 id="图2-2"><a href="#图2-2" class="headerlink" title="图2:"></a>图2:</h3><p><img src="http://pfuoi64aq.bkt.clouddn.com/WechatIMG500.jpeg" width="70%" height="70%"></p><h3 id="图3-1"><a href="#图3-1" class="headerlink" title="图3:"></a>图3:</h3><p><img src="http://pfuoi64aq.bkt.clouddn.com/WechatIMG498.jpeg" width="70%" height="70%"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;商城首页&quot;&gt;&lt;a href=&quot;#商城首页&quot; class=&quot;headerlink&quot; title=&quot;商城首页&quot;&gt;&lt;/a&gt;商城首页&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://pfuoi64aq.bkt.clouddn.com/%E9%A6%96%E9%A1%B5-
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Ajax 原理</title>
    <link href="http://yoursite.com/2018/09/30/%5BJS%5D%20Ajax%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/09/30/[JS] Ajax原理/</id>
    <published>2018-09-30T09:20:31.000Z</published>
    <updated>2018-10-18T14:38:24.563Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://jartto.wang/2015/09/01/chattered-about-ajax/" target="_blank" rel="noopener">http://jartto.wang/2015/09/01/chattered-about-ajax/</a></p><p><a href="http://jartto.wang/2015/10/01/advantage-and-disadvantages-of-Ajax/" target="_blank" rel="noopener">http://jartto.wang/2015/10/01/advantage-and-disadvantages-of-Ajax/</a></p><p>Ajax函数的封装<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url, fnSucc, fnFailed</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> oAjax;</span><br><span class="line">  <span class="comment">// 1、建立Ajax对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHTTPRequest) &#123;</span><br><span class="line">    oAjax = <span class="keyword">new</span> XMLHTTPRequest();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    oAjax = <span class="keyword">new</span> ActiveXObjext(<span class="string">'Micosoft.XMLHTTP'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2、连接服务器（打开和连接服务器）</span></span><br><span class="line">  oAjax.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// 3、发送</span></span><br><span class="line">  oAjax.send();</span><br><span class="line">  <span class="comment">// 4、接收</span></span><br><span class="line">  oAjax.onreadyStateChange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (oAjax.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (oAjax.status === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="comment">// fnSucc</span></span><br><span class="line">        fnSucc(oAjax.requesText);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fnSucc(oAjax.status);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://jartto.wang/2015/09/01/chattered-about-ajax/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://jartto.wang/2015/09/01/chattered-abou
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Html5知识积累</title>
    <link href="http://yoursite.com/2018/09/30/%5BH5%5D%20Html5%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/"/>
    <id>http://yoursite.com/2018/09/30/[H5] Html5知识积累/</id>
    <published>2018-09-30T06:59:31.000Z</published>
    <updated>2018-10-15T03:22:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sessionStorage-和-localStorage"><a href="#sessionStorage-和-localStorage" class="headerlink" title="sessionStorage 和 localStorage"></a>sessionStorage 和 localStorage</h2><p><code>Web Storage</code>包括了两种存储方式：<code>sessionStorage</code>和<code>localStorage</code>。<br><code>sessionStorage</code>用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁，生命周期为当前窗口或标签页，一旦窗口或标签页被永久关闭了。<br>  因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。<br>  页面及标签页仅指顶级窗口，如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的。<br><code>localStorage</code>用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</p><p><code>web storage</code>和<code>cookie</code>的区别：<br>Web Storage是为了更大容量存储而设计。<br>Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。</p><p>Web Storage拥有<code>setItem</code>,<code>getItem</code>,<code>removeItem</code>,<code>clear</code>等方法，不像cookie需要开发者自己封装<code>setCookie</code>,<code>getCookie</code>。</p><p>Cookie优点：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。</p><p>html5 web storage的浏览器支持情况:<br>浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持。通过简单的代码封装可以统一到所有的浏览器都支持web storage。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.localStorage)&#123; </span><br><span class="line">  <span class="comment">// 浏览支持localStorage</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">// 浏览暂不支持localStorage</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者 </span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">window</span>.localStorage == <span class="string">'undefined'</span>)&#123;</span><br><span class="line">  <span class="comment">// 浏览暂不支持localStorage</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>setItem</code>存储value 用途，.setItem(key, value)<br><code>getItem</code>获取value 用途，.getItem(key)<br><code>removeItem</code>删除key 用途，.removeItem(key)<br><code>clear</code>清除所有的key/value 用途， .clear()<br><code>localStorage</code>和<code>sessionStorage</code>的key和length属性实现遍历: <code>sessionStorage</code>和<code>localStorage</code>提供的key()和length可以方便的实现存储的数据遍历.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.setItem(<span class="string">"key"</span>, <span class="string">"value"</span>);     </span><br><span class="line">localStorage.setItem(<span class="string">"site"</span>, <span class="string">"js8.in"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value = sessionStorage.getItem(<span class="string">"key"</span>);     </span><br><span class="line"><span class="keyword">var</span> site = localStorage.getItem(<span class="string">"site"</span>);</span><br><span class="line"></span><br><span class="line">sessionStorage.removeItem(<span class="string">"key"</span>);     </span><br><span class="line">localStorage.removeItem(<span class="string">"site"</span>);</span><br><span class="line"></span><br><span class="line">sessionStorage.clear();     </span><br><span class="line">localStorage.clear();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> storage = <span class="built_in">window</span>.localStorage; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>, len = storage.length; i &lt; len; i++)&#123;</span><br><span class="line">  <span class="keyword">var</span> key = storage.key(i); </span><br><span class="line">  <span class="keyword">var</span> value = storage.getItem(key); </span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">"="</span> + value); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="web-storage-的离线存储"><a href="#web-storage-的离线存储" class="headerlink" title="web storage 的离线存储"></a>web storage 的离线存储</h2><p>H5 的 Web storage API 采用了离线缓存，会生成一个清单文件（manifest file)，这个清单文件实质就是一系列的URL列表文件，这些URL分别指向页面当中的html,css,javascript,图片等相关内容。<br>当使用离线应用时，应用会引入这一清单文件，浏览器会读取这一文件，下载相应的文件，并将其缓存到本地。<br>使得这些web应用能够脱离网络使用，而用户在离线时的更改也同样会映射到清单文件中，并在重新连线之后将更改返回应用，工作方式与我们现在所使用的网盘有着异曲同工之处。<br>首先，需要在页面头加入manifest属性：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span> = <span class="string">"cache.manifest"</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>然后cache.manifest文件的书写方式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line">#v0.11</span><br><span class="line">CACHE:</span><br><span class="line">js/app.js</span><br><span class="line">css/style.css</span><br><span class="line">NETWORK:</span><br><span class="line">resourse/logo.png</span><br><span class="line">FALLBACK:</span><br><span class="line">/ /offline.html</span><br></pre></td></tr></table></figure></p><p>离线存储的manifest一般由三个部分组成:</p><ol><li>CACHE:表示需要离线存储的资源列表，由于包含manifest文件的页面将被自动离线存储，所以不需要把页面自身也列出来。</li><li>NETWORK:表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在CACHE和NETWORK中有一个相同的资源，那么这个资源还是会被离线存储，也就是说CACHE的优先级更高。</li><li>FALLBACK:表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问offline.html。</li></ol><p><a href="http://jartto.wang/2016/07/25/make-an-inventory-of-html5-api/" target="_blank" rel="noopener">http://jartto.wang/2016/07/25/make-an-inventory-of-html5-api/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;sessionStorage-和-localStorage&quot;&gt;&lt;a href=&quot;#sessionStorage-和-localStorage&quot; class=&quot;headerlink&quot; title=&quot;sessionStorage 和 localStorage&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="H5" scheme="http://yoursite.com/tags/H5/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://yoursite.com/2018/09/29/%5BJS%5D%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/09/29/[JS] 正则表达式/</id>
    <published>2018-09-29T08:20:42.000Z</published>
    <updated>2018-10-08T02:21:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式是匹配模式，要么匹配字符，要么匹配位置。</p><h2 id="正则表达式字符匹配攻略"><a href="#正则表达式字符匹配攻略" class="headerlink" title="正则表达式字符匹配攻略"></a>正则表达式字符匹配攻略</h2><ol><li><p>两种模糊匹配：横向模糊和纵向模糊<br>横向模糊指的是，一个正则可匹配的字符串的长度不是固定的。<br>纵向模糊指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符。</p></li><li><p>字符组<br><code>[123456abcdefGHIJKLM] 可以写成 [1-6a-fG-M]</code><br>可以写成如下的方式：<code>[-az]</code>或<code>[az-]</code>或<code>[a\-z]</code>, 即要么放在开头，要么放在结尾，要么转义</p></li></ol><p>排除字符组：例如<code>[^abc]</code>，表示是一个除”a”、”b”、”c”之外的任意一个字符。字符组的第一位放<code>^（脱字符）</code>，表示求反。</p><blockquote><ul><li><code>\d</code>就是[0-9]。表示是一位数字。记忆方式：其英文是digit（数字）</li><li><code>\D</code>就是[^0-9]。表示除数字外的任意字符。\w就是[0-9a-zA-Z_]。表示数字、大小写字母和下划线。</li><li><code>\W</code>是[^0-9a-zA-Z_]。非单词字符。记忆方式：w是word的简写，也称单词字符。</li><li><code>\s</code>是[ \t\v\n\r\f]。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。记忆方式：s是space character的首字母。</li><li><code>\S</code>是[^ \t\v\n\r\f]。 非空白符。</li><li><code>.</code>就是[^\n\r\u2028\u2029]。通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外。记忆方式：想想省略号…中的每个点，都可以理解成占位符，表示任何类似的东西。</li></ul></blockquote><ol start="3"><li>量词：</li></ol><blockquote><ul><li><code>{m,}</code> 表示至少出现m次。</li><li><code>{m}</code> 等价于{m,m}，表示出现m次。</li><li><code>?</code> 等价于{0,1}，表示出现或者不出现。记忆方式：问号的意思表示，有吗？</li><li><code>+</code> 等价于{1,}，表示出现至少一次。记忆方式：加号是追加的意思，得先有一个，然后才考虑追加。</li><li><code>*</code> 等价于{0,}，表示出现任意次，有可能不出现。记忆方式：看看天上的星星，可能一颗没有，可能零散有几颗，可能数也数不过来。</li></ul></blockquote><p><strong>贪婪匹配</strong>: 尽可能多的匹配<br><strong>惰性匹配</strong>: 尽可能少的匹配</p><ol start="4"><li><p>多选分支<br><code>(p1|p2|p3)</code>，其中p1、p2和p3是子模式，用|（管道符）分隔，表示其中任何之一。</p></li><li><p>案例</p></li></ol><ul><li style="list-style: none"><input type="checkbox" checked> 匹配时间（24小时制）：<code>/^(0?[0-9]|1[0-9]|[2][0-3]):(0?[0-9]|[1-5][0-9])$/</code></li><li style="list-style: none"><input type="checkbox" checked> 匹配日期（yyyy-mm-dd格式）： <code>/^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/</code></li><li style="list-style: none"><input type="checkbox" checked> window操作系统文件路径：<code>/^[a-zA-Z]:\\([^\\:*&lt;&gt;|&quot;?\r\n/]+\\)*([^\\:*&lt;&gt;|&quot;?\r\n/]+)?$/</code><br>eg：盘符:\文件夹\文件夹\文件夹\<br>F:\study\javascript\regex\regular expression.pdf<br>F:\study\javascript\regex\<br>F:\study\javascript<br>F:\</li></ul><p>文件名或者文件夹名，不能包含一些特殊字符，排除字符组<code>[^\\:*&lt;&gt;|&quot;?\r\n/]</code>来表示合法字符<br>路径的最后一部分可以是“文件夹”，没有\，因此需要添加<code>([^\\:*&lt;&gt;|&quot;?\r\n/]+)?</code></p><h2 id="正则表达式位置匹配攻略"><a href="#正则表达式位置匹配攻略" class="headerlink" title="正则表达式位置匹配攻略"></a>正则表达式位置匹配攻略</h2><blockquote><ul><li><code>^</code>（脱字符）匹配开头，在多行匹配中匹配行开头。</li><li><code>$</code>（美元符号）匹配结尾，在多行匹配中匹配行结尾。</li><li><code>\b</code> 是单词边界，具体就是\w和\W之间的位置，也包括\w和^之间的位置，也包括\w和$之间的位置。\w是字符组[0-9a-zA-Z_]的简写形式，</li><li><code>\B</code> 是\b的反面的意思，非单词边界</li><li><code>(?=p)</code> 其中p是一个子模式，即p前面的位置。eg：(?=l)，表示’l’字符前面的位置。（positive lookahead）</li><li><code>(?!p)</code> 是(?=p)的反面意思。（negative lookahead）</li></ul></blockquote><ol><li>案例</li></ol><ul><li style="list-style: none"><input type="checkbox" checked> 不匹配任何东西的正则: <code>/.^/</code></li><li style="list-style: none"><input type="checkbox" checked> 数字的千位分隔符表示法: “12,345,678” 正则为：<code>/(?!^)(?=(\d{3})+$)/g</code><br>“12345678  123456789” 替换成”12,345,678  123,456,789”  正则为: <code>/\B(?=(\d{3})+\b)/g</code>，其中 <code>(?!\b) 为 \B</code></li><li style="list-style: none"><input type="checkbox" checked> 必须包含数字: <code>(?=.*[0-9])</code></li><li style="list-style: none"><input type="checkbox" checked> 同时包含数字和小写字母:  <code>(?=.*[0-9])(?=.*[a-z])</code></li><li style="list-style: none"><input type="checkbox" checked> 密码长度6-12位，由数字、小写字符和大写字母组成，但必须至少包括2种字符。<br><code>/((?=.*[0-9])(?=.*[a-z])|(?=.*[0-9])(?=.*[A-Z])|(?=.*[a-z])(?=.*[A-Z]))^[0-9A-Za-z]{6,12}$/</code></li></ul><h2 id="正则表达式括号的作用"><a href="#正则表达式括号的作用" class="headerlink" title="正则表达式括号的作用"></a>正则表达式括号的作用</h2><ul><li style="list-style: none"><input type="checkbox" checked> “2017-06-12”.replace(/(\d{4})-(\d{2})-(\d{2})/, “$2/$3/$1”); // “06/12/2017”</li><li style="list-style: none"><input type="checkbox" checked> 匹配”2016-06-12”、”2016/06/12”、”2016.06.12” 正则为: <code>/\d{4}(-|\/|\.)\d{2}\1\d{2}/</code><br><strong>注意里面的\1，表示的引用之前的那个分组<code>(-|\/|\.)</code>。不管它匹配到什么（比如-），\1都匹配那个同样的具体某个字符。</strong></li></ul><ol><li>括号嵌套</li><li><p><code>\10</code>表示第10个分组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/(1)(2)(3)(4)(5)(6)(7)(8)(9)(#) \10+/</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"123456789# ######"</span></span><br><span class="line"><span class="built_in">console</span>.log( regex.test(string) );  <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure></li><li><p>引用不存在的分组<br>因为反向引用，是引用前面的分组，但我们在正则里引用了不存在的分组时，此时正则不会报错，只是匹配反向引用的字符本身。</p></li></ol><ul><li><p>[x] 字符串trim方法模拟</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trim</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> str.replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log( trim(<span class="string">"  foobar   "</span>) );   <span class="comment">// =&gt; "foobar"</span></span><br></pre></td></tr></table></figure></li><li><p>[x] 将每个单词的首字母转换为大写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">titleize</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> str.toLowerCase().replace(<span class="regexp">/(?:^|\s)\w/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> c.toUpperCase();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log( titleize(<span class="string">'my name is epeli'</span>) );  <span class="comment">// =&gt; "My Name Is Epeli"</span></span><br></pre></td></tr></table></figure></li><li><p>[x] 驼峰化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">camelize</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> str.replace(<span class="regexp">/[-_\s]+(.)?/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match, c</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> c ? c.toUpperCase() : <span class="string">''</span>;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log( camelize(<span class="string">'-moz-transform'</span>) );  <span class="comment">// =&gt; "MozTransform"</span></span><br></pre></td></tr></table></figure></li><li><p>[x] 匹配成对标签  <code>/&lt;([^&gt;]+)&gt;[\d\D]*&lt;\/\1&gt;/</code><br>开标签: <code>&lt;[^&gt;]+&gt;</code>, 闭标签: <code>&lt;\/[^&gt;]+&gt;</code><br><code>[\d\D]</code>的意思是，这个字符是数字或者不是数字，因此，也就是匹配任意字符的意思。</p></li></ul><h2 id="正则表达式回溯法原理"><a href="#正则表达式回溯法原理" class="headerlink" title="正则表达式回溯法原理"></a>正则表达式回溯法原理</h2><h2 id="正则表达式的拆分"><a href="#正则表达式的拆分" class="headerlink" title="正则表达式的拆分"></a>正则表达式的拆分</h2><h2 id="正则表达式的构建"><a href="#正则表达式的构建" class="headerlink" title="正则表达式的构建"></a>正则表达式的构建</h2><h2 id="正则表达式编程"><a href="#正则表达式编程" class="headerlink" title="正则表达式编程"></a>正则表达式编程</h2><h1 id="正则表达式的一些规则"><a href="#正则表达式的一些规则" class="headerlink" title="正则表达式的一些规则"></a>正则表达式的一些规则</h1><p>RegExp对象的方法：</p><ul><li><ul><li>test：在字符串中测试模式匹配,返回 true 或 false</li></ul></li><li><ul><li>exec：在字符串中执行匹配搜索,返回结果数组</li></ul></li><li><ul><li>match(pattern)：返回 pattern 中的子串或 null</li></ul></li><li><ul><li>replace(pattern, replacement)：用 replacement 替换 pattern</li></ul></li><li><ul><li>search(pattern)：返回字符串中 pattern 开始位置</li></ul></li><li><ul><li>split(pattern)：返回字符串按指定 pattern 拆分的数组</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;正则表达式是匹配模式，要么匹配字符，要么匹配位置。&lt;/p&gt;
&lt;h2 id=&quot;正则表达式字符匹配攻略&quot;&gt;&lt;a href=&quot;#正则表达式字符匹配攻略&quot; class=&quot;headerlink&quot; title=&quot;正则表达式字符匹配攻略&quot;&gt;&lt;/a&gt;正则表达式字符匹配攻略&lt;/h2&gt;&lt;ol&gt;
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>webpack 优化项目策略</title>
    <link href="http://yoursite.com/2018/09/29/%5B%E6%9E%84%E5%BB%BA%5D%20webpack%E4%BC%98%E5%8C%96%E9%A1%B9%E7%9B%AE/"/>
    <id>http://yoursite.com/2018/09/29/[构建] webpack优化项目/</id>
    <published>2018-09-29T02:20:51.000Z</published>
    <updated>2018-10-21T14:51:08.024Z</updated>
    
    <content type="html"><![CDATA[<p>优化可以分为<code>优化开发体验</code>和<code>优化输出质量</code>两部分。</p><h1 id="优化开发体验"><a href="#优化开发体验" class="headerlink" title="优化开发体验"></a>优化开发体验</h1><p>优化开发体验的目的是为了提升开发时的效率</p><h2 id="1-优化构建速度"><a href="#1-优化构建速度" class="headerlink" title="1.优化构建速度"></a>1.优化构建速度</h2><p><a href="">缩小文件搜索范围</a><br><a href="">使用 DllPlugin</a><br><a href="">使用 HappyPack</a><br><a href="">使用 ParallelUglifyPlugin</a></p><h2 id="2-优化使用体验"><a href="#2-优化使用体验" class="headerlink" title="2.优化使用体验"></a>2.优化使用体验</h2><p><a href="">使用自动刷新</a><br><a href="">开启模块热替换</a></p><h1 id="优化输出质量"><a href="#优化输出质量" class="headerlink" title="优化输出质量"></a>优化输出质量</h1><p>优化输出质量的目的是为了给用户呈现体验更好的网页，例如减少首屏加载时间、提升性能流畅度等。</p><h2 id="1-减少用户能感知到的加载时间-首屏加载时间"><a href="#1-减少用户能感知到的加载时间-首屏加载时间" class="headerlink" title="1.减少用户能感知到的加载时间(首屏加载时间)"></a>1.减少用户能感知到的加载时间(首屏加载时间)</h2><p><a href="">区分环境</a><br><a href="">压缩代码</a><br><a href="">CDN 加速</a><br><a href="">使用 Tree Shaking</a><br><a href="">提取公共代码</a><br><a href="">按需加载</a></p><h2 id="2-提升流畅度-提升代码性能"><a href="#2-提升流畅度-提升代码性能" class="headerlink" title="2.提升流畅度(提升代码性能)"></a>2.提升流畅度(提升代码性能)</h2><p><a href="">使用 Prepack</a><br><a href="">开启 Scope Hoisting</a></p><h3 id="缩小文件搜索范围-resolve"><a href="#缩小文件搜索范围-resolve" class="headerlink" title="缩小文件搜索范围 resolve"></a>缩小文件搜索范围 resolve</h3><p>Webpack 启动后会从配置的 Entry 出发，解析出文件中的导入语句，再递归的解析。<br>在遇到导入语句时 Webpack 会做两件事情：<br>1、根据导入语句去寻找对应的要导入的文件。<br>  例如 require(‘react’) 导入语句对应的文件是 ./node_modules/react/react.js， require(‘./util’) 对应的文件是 ./util.js。<br>2、根据找到的要导入文件的后缀，使用配置中的 Loader 去处理文件。<br>  例如使用 ES6 开发的 JavaScript 文件需要使用 babel-loader 去处理。</p><h3 id="DllPlugin"><a href="#DllPlugin" class="headerlink" title="DllPlugin"></a>DllPlugin</h3><p><code>动态链接库</code>: 可包含给其他模块调用的函数和数据。</p><p><font color="#d00">要给 Web 项目构建接入动态链接库的思想，需要完成以下事情：</font><br>1、把网页依赖的基础模块抽离出来，打包到一个个单独的动态链接库中去。一个动态链接库中可以包含多个模块。<br>2、当需要导入的模块存在于某个动态链接库中时，这个模块不能被再次被打包，而是去动态链接库中获取。<br>3、页面依赖的所有动态链接库需要被加载。</p><p><font color="#d00">Web 项目构建接入动态链接库的思想后，会大大提升构建速度。</font><br>原因：包含大量复用模块的动态链接库只需要编译一次，在之后的构建过程中被动态链接库包含的模块将不会在重新编译，而是直接使用动态链接库中的代码。<br>由于动态链接库中大多数包含的是常用的第三方模块，例如 react、react-dom，只要不升级这些模块的版本，动态链接库就不用重新编译。</p><p><code>DllPlugin</code>: 用于打包出一个个单独的动态链接库文件。<br><code>DllReferencePlugin</code>: 将打包好的dll文件传入构建的代码里面<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack_dll.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> DllPlugin = <span class="built_in">require</span>(<span class="string">'webpack/lib/DllPlugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// JS 执行入口文件</span></span><br><span class="line">  entry: &#123;</span><br><span class="line">    <span class="comment">// 把 React 相关模块的放到一个单独的动态链接库</span></span><br><span class="line">    react: [<span class="string">'react'</span>, <span class="string">'react-dom'</span>],</span><br><span class="line">    <span class="comment">// 把项目需要所有的 polyfill 放到一个单独的动态链接库</span></span><br><span class="line">    polyfill: [<span class="string">'core-js/fn/object/assign'</span>, <span class="string">'core-js/fn/promise'</span>, <span class="string">'whatwg-fetch'</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 输出的动态链接库的文件名称，[name] 代表当前动态链接库的名称，</span></span><br><span class="line">    <span class="comment">// 也就是 entry 中配置的 react 和 polyfill</span></span><br><span class="line">    filename: <span class="string">'[name].dll.js'</span>,</span><br><span class="line">    <span class="comment">// 输出的文件都放到 dist 目录下</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    <span class="comment">// 存放动态链接库的全局变量名称，例如对应 react 来说就是 _dll_react</span></span><br><span class="line">    <span class="comment">// 之所以在前面加上 _dll_ 是为了防止全局变量冲突</span></span><br><span class="line">    library: <span class="string">'_dll_[name]'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 接入 DllPlugin</span></span><br><span class="line">    <span class="keyword">new</span> DllPlugin(&#123;</span><br><span class="line">      <span class="comment">// 动态链接库的全局变量名称，需要和 output.library 中保持一致</span></span><br><span class="line">      <span class="comment">// 该字段的值也就是输出的 manifest.json 文件 中 name 字段的值</span></span><br><span class="line">      <span class="comment">// 例如 react.manifest.json 中就有 "name": "_dll_react"</span></span><br><span class="line">      name: <span class="string">'_dll_[name]'</span>,</span><br><span class="line">      <span class="comment">// 描述动态链接库的 manifest.json 文件输出时的文件名称</span></span><br><span class="line">      path: path.join(__dirname, <span class="string">'dist'</span>, <span class="string">'[name].manifest.json'</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>构建出的动态链接库文件用于给其它地方使用，在这里也就是给执行入口使用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主 webpack.config.js 文件</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> DllReferencePlugin = <span class="built_in">require</span>(<span class="string">'webpack/lib/DllReferencePlugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    <span class="comment">// 定义入口 Chunk</span></span><br><span class="line">    main: <span class="string">'./main.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 输出文件的名称</span></span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    <span class="comment">// 输出文件都放到 dist 目录下</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 项目源码使用了 ES6 和 JSX 语法，需要使用 babel-loader 转换</span></span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: [<span class="string">'babel-loader'</span>],</span><br><span class="line">        exclude: path.resolve(__dirname, <span class="string">'node_modules'</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 告诉 Webpack 使用了哪些动态链接库</span></span><br><span class="line">    <span class="keyword">new</span> DllReferencePlugin(&#123;</span><br><span class="line">      <span class="comment">// 描述 react 动态链接库的文件内容</span></span><br><span class="line">      manifest: <span class="built_in">require</span>(<span class="string">'./dist/react.manifest.json'</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> DllReferencePlugin(&#123;</span><br><span class="line">      <span class="comment">// 描述 polyfill 动态链接库的文件内容</span></span><br><span class="line">      manifest: <span class="built_in">require</span>(<span class="string">'./dist/polyfill.manifest.json'</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  devtool: <span class="string">'source-map'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><font color="#d00">注意：</font>在 webpack_dll.config.js 文件中，DllPlugin 中的 name 参数必须和 output.library 中保持一致。 原因在于 DllPlugin 中的 name 参数会影响输出的 manifest.json 文件中 name 字段的值， 而在 webpack.config.js 文件中 DllReferencePlugin 会去 manifest.json 文件读取 name 字段的值， 把值的内容作为在从全局变量中获取动态链接库中内容时的全局变量名。</p><p>执行构建时流程如下：<br>1、如果动态链接库相关的文件还没有编译出来，就需要先把它们编译出来。方法是执行 webpack –config webpack_dll.config.js 命令。<br>2、在确保动态链接库存在时，才能正常的编译出入口执行文件。方法是执行 webpack 命令。这时你会发现构建速度有了非常大的提升。</p><p><code>AddAssetHtmlPlugin</code>: 在生成的html文件中加入dll文件的script引用<br><code>imagemin-webpack-plugin</code>: 压缩图片；<br><code>webpack-spritesmith</code>: 插件制作雪碧图</p><p>png: <code>file-loader</code> 可以把 JS 和 CSS 中导入图片的语句替换成正确的地址，并同时把文件输出到对应的位置。<br><code>url-loader</code> 经 base64 编码后注入到 JS 或者 CSS 中去。<br>svg: <code>raw-loader</code> 可以把文本文件的内容读取出来，注入到 JS 或 CSS 中去。</p><h3 id="DllPlugin-1"><a href="#DllPlugin-1" class="headerlink" title="DllPlugin"></a>DllPlugin</h3><p>由于有大量文件需要解析和处理，构建是文件读写和计算密集型的操作，特别是当文件数量变多后，Webpack 构建慢的问题会显得严重。<br>运行在 Node.js 之上的 Webpack 是单线程模型的。</p><p>文件读写和计算操作是无法避免的，那能不能让 Webpack 同一时刻处理多个任务，发挥多核 CPU 电脑的威力，以提升构建速度呢？</p><p>HappyPack 就能让 Webpack 做到这点，它把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。</p><h2 id="总结：侧重优化开发体验的配置文件-webpack-config-js："><a href="#总结：侧重优化开发体验的配置文件-webpack-config-js：" class="headerlink" title="总结：侧重优化开发体验的配置文件 webpack.config.js："></a>总结：侧重优化开发体验的配置文件 webpack.config.js：</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> CommonsChunkPlugin = <span class="built_in">require</span>(<span class="string">'webpack/lib/optimize/CommonsChunkPlugin'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;AutoWebPlugin&#125; = <span class="built_in">require</span>(<span class="string">'web-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> HappyPack = <span class="built_in">require</span>(<span class="string">'happypack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动寻找 pages 目录下的所有目录，把每一个目录看成一个单页应用</span></span><br><span class="line"><span class="keyword">const</span> autoWebPlugin = <span class="keyword">new</span> AutoWebPlugin(<span class="string">'./src/pages'</span>, &#123;</span><br><span class="line">  <span class="comment">// HTML 模版文件所在的文件路径</span></span><br><span class="line">  template: <span class="string">'./template.html'</span>,</span><br><span class="line">  <span class="comment">// 提取出所有页面公共的代码</span></span><br><span class="line">  commonsChunk: &#123;</span><br><span class="line">    <span class="comment">// 提取出公共代码 Chunk 的名称</span></span><br><span class="line">    name: <span class="string">'common'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// AutoWebPlugin 会找为寻找到的所有单页应用，生成对应的入口配置，</span></span><br><span class="line">  <span class="comment">// autoWebPlugin.entry 方法可以获取到生成入口配置</span></span><br><span class="line">  entry: autoWebPlugin.entry(&#123;</span><br><span class="line">    <span class="comment">// 这里可以加入你额外需要的 Chunk 入口</span></span><br><span class="line">    base: <span class="string">'./src/base.js'</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    <span class="comment">// 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤</span></span><br><span class="line">    <span class="comment">// 其中 __dirname 表示当前工作目录，也就是项目根目录</span></span><br><span class="line">    modules: [path.resolve(__dirname, <span class="string">'node_modules'</span>)],</span><br><span class="line">    <span class="comment">// 针对 Npm 中的第三方模块优先采用 jsnext:main 中指向的 ES6 模块化语法的文件，使用 Tree Shaking 优化</span></span><br><span class="line">    <span class="comment">// 只采用 main 字段作为入口文件描述字段，以减少搜索步骤</span></span><br><span class="line">    mainFields: [<span class="string">'jsnext:main'</span>, <span class="string">'main'</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 如果项目源码中只有 js 文件就不要写成 /\.jsx?$/，提升正则表达式性能</span></span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="comment">// 使用 HappyPack 加速构建</span></span><br><span class="line">        use: [<span class="string">'happypack/loader?id=babel'</span>],</span><br><span class="line">        <span class="comment">// 只对项目根目录下的 src 目录中的文件采用 babel-loader</span></span><br><span class="line">        include: path.resolve(__dirname, <span class="string">'src'</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: [<span class="string">'happypack/loader?id=ui-component'</span>],</span><br><span class="line">        include: path.resolve(__dirname, <span class="string">'src'</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 增加对 CSS 文件的支持</span></span><br><span class="line">        test: <span class="regexp">/\.css/</span>,</span><br><span class="line">        use: [<span class="string">'happypack/loader?id=css'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    autoWebPlugin,</span><br><span class="line">    <span class="comment">// 使用 HappyPack 加速构建</span></span><br><span class="line">    <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">      id: <span class="string">'babel'</span>,</span><br><span class="line">      <span class="comment">// babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启</span></span><br><span class="line">      loaders: [<span class="string">'babel-loader?cacheDirectory'</span>],</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">      <span class="comment">// UI 组件加载拆分</span></span><br><span class="line">      id: <span class="string">'ui-component'</span>,</span><br><span class="line">      loaders: [&#123;</span><br><span class="line">        loader: <span class="string">'ui-component-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          lib: <span class="string">'antd'</span>,</span><br><span class="line">          style: <span class="string">'style/index.css'</span>,</span><br><span class="line">          camel2: <span class="string">'-'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;],</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">      id: <span class="string">'css'</span>,</span><br><span class="line">      <span class="comment">// 如何处理 .css 文件，用法和 Loader 配置中一样</span></span><br><span class="line">      loaders: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>],</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 4-11提取公共代码</span></span><br><span class="line">    <span class="keyword">new</span> CommonsChunkPlugin(&#123;</span><br><span class="line">      <span class="comment">// 从 common 和 base 两个现成的 Chunk 中提取公共的部分</span></span><br><span class="line">      chunks: [<span class="string">'common'</span>, <span class="string">'base'</span>],</span><br><span class="line">      <span class="comment">// 把公共的部分放到 base 中</span></span><br><span class="line">      name: <span class="string">'base'</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  watchOptions: &#123;</span><br><span class="line">    <span class="comment">// 4-5使用自动刷新：不监听的 node_modules 目录下的文件</span></span><br><span class="line">    ignored: <span class="regexp">/node_modules/</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="侧重优化输出质量的配置文件-webpack-dist-config-js："><a href="#侧重优化输出质量的配置文件-webpack-dist-config-js：" class="headerlink" title="侧重优化输出质量的配置文件 webpack-dist.config.js："></a>侧重优化输出质量的配置文件 webpack-dist.config.js：</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> DefinePlugin = <span class="built_in">require</span>(<span class="string">'webpack/lib/DefinePlugin'</span>);</span><br><span class="line"><span class="keyword">const</span> ModuleConcatenationPlugin = <span class="built_in">require</span>(<span class="string">'webpack/lib/optimize/ModuleConcatenationPlugin'</span>);</span><br><span class="line"><span class="keyword">const</span> CommonsChunkPlugin = <span class="built_in">require</span>(<span class="string">'webpack/lib/optimize/CommonsChunkPlugin'</span>);</span><br><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;AutoWebPlugin&#125; = <span class="built_in">require</span>(<span class="string">'web-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> HappyPack = <span class="built_in">require</span>(<span class="string">'happypack'</span>);</span><br><span class="line"><span class="keyword">const</span> ParallelUglifyPlugin = <span class="built_in">require</span>(<span class="string">'webpack-parallel-uglify-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动寻找 pages 目录下的所有目录，把每一个目录看成一个单页应用</span></span><br><span class="line"><span class="keyword">const</span> autoWebPlugin = <span class="keyword">new</span> AutoWebPlugin(<span class="string">'./src/pages'</span>, &#123;</span><br><span class="line">  <span class="comment">// HTML 模版文件所在的文件路径</span></span><br><span class="line">  template: <span class="string">'./template.html'</span>,</span><br><span class="line">  <span class="comment">// 提取出所有页面公共的代码</span></span><br><span class="line">  commonsChunk: &#123;</span><br><span class="line">    <span class="comment">// 提取出公共代码 Chunk 的名称</span></span><br><span class="line">    name: <span class="string">'common'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 指定存放 CSS 文件的 CDN 目录 URL</span></span><br><span class="line">  stylePublicPath: <span class="string">'//css.cdn.com/id/'</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// AutoWebPlugin 会找为寻找到的所有单页应用，生成对应的入口配置，</span></span><br><span class="line">  <span class="comment">// autoWebPlugin.entry 方法可以获取到生成入口配置</span></span><br><span class="line">  entry: autoWebPlugin.entry(&#123;</span><br><span class="line">    <span class="comment">// 这里可以加入你额外需要的 Chunk 入口</span></span><br><span class="line">    base: <span class="string">'./src/base.js'</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 给输出的文件名称加上 Hash 值</span></span><br><span class="line">    filename: <span class="string">'[name]_[chunkhash:8].js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'./dist'</span>),</span><br><span class="line">    <span class="comment">// 指定存放 JavaScript 文件的 CDN 目录 URL</span></span><br><span class="line">    publicPath: <span class="string">'//js.cdn.com/id/'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    <span class="comment">// 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤</span></span><br><span class="line">    <span class="comment">// 其中 __dirname 表示当前工作目录，也就是项目根目录</span></span><br><span class="line">    modules: [path.resolve(__dirname, <span class="string">'node_modules'</span>)],</span><br><span class="line">    <span class="comment">// 只采用 main 字段作为入口文件描述字段，以减少搜索步骤</span></span><br><span class="line">    mainFields: [<span class="string">'jsnext:main'</span>, <span class="string">'main'</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 如果项目源码中只有 js 文件就不要写成 /\.jsx?$/，提升正则表达式性能</span></span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="comment">// 使用 HappyPack 加速构建</span></span><br><span class="line">        use: [<span class="string">'happypack/loader?id=babel'</span>],</span><br><span class="line">        <span class="comment">// 只对项目根目录下的 src 目录中的文件采用 babel-loader</span></span><br><span class="line">        include: path.resolve(__dirname, <span class="string">'src'</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: [<span class="string">'happypack/loader?id=ui-component'</span>],</span><br><span class="line">        include: path.resolve(__dirname, <span class="string">'src'</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 增加对 CSS 文件的支持</span></span><br><span class="line">        test: <span class="regexp">/\.css/</span>,</span><br><span class="line">        <span class="comment">// 提取出 Chunk 中的 CSS 代码到单独的文件中</span></span><br><span class="line">        use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">          use: [<span class="string">'happypack/loader?id=css'</span>],</span><br><span class="line">          <span class="comment">// 指定存放 CSS 中导入的资源（例如图片）的 CDN 目录 URL</span></span><br><span class="line">          publicPath: <span class="string">'//img.cdn.com/id/'</span></span><br><span class="line">        &#125;),</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    autoWebPlugin,</span><br><span class="line">    <span class="comment">// 4-14开启ScopeHoisting</span></span><br><span class="line">    <span class="keyword">new</span> ModuleConcatenationPlugin(),</span><br><span class="line">    <span class="comment">// 4-3使用HappyPack</span></span><br><span class="line">    <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">      <span class="comment">// 用唯一的标识符 id 来代表当前的 HappyPack 是用来处理一类特定的文件</span></span><br><span class="line">      id: <span class="string">'babel'</span>,</span><br><span class="line">      <span class="comment">// babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启</span></span><br><span class="line">      loaders: [<span class="string">'babel-loader?cacheDirectory'</span>],</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">      <span class="comment">// UI 组件加载拆分</span></span><br><span class="line">      id: <span class="string">'ui-component'</span>,</span><br><span class="line">      loaders: [&#123;</span><br><span class="line">        loader: <span class="string">'ui-component-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          lib: <span class="string">'antd'</span>,</span><br><span class="line">          style: <span class="string">'style/index.css'</span>,</span><br><span class="line">          camel2: <span class="string">'-'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;],</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">      id: <span class="string">'css'</span>,</span><br><span class="line">      <span class="comment">// 如何处理 .css 文件，用法和 Loader 配置中一样</span></span><br><span class="line">      <span class="comment">// 通过 minimize 选项压缩 CSS 代码</span></span><br><span class="line">      loaders: [<span class="string">'css-loader?minimize'</span>],</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> ExtractTextPlugin(&#123;</span><br><span class="line">      <span class="comment">// 给输出的 CSS 文件名称加上 Hash 值</span></span><br><span class="line">      filename: <span class="string">`[name]_[contenthash:8].css`</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 4-11提取公共代码</span></span><br><span class="line">    <span class="keyword">new</span> CommonsChunkPlugin(&#123;</span><br><span class="line">      <span class="comment">// 从 common 和 base 两个现成的 Chunk 中提取公共的部分</span></span><br><span class="line">      chunks: [<span class="string">'common'</span>, <span class="string">'base'</span>],</span><br><span class="line">      <span class="comment">// 把公共的部分放到 base 中</span></span><br><span class="line">      name: <span class="string">'base'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> DefinePlugin(&#123;</span><br><span class="line">      <span class="comment">// 定义 NODE_ENV 环境变量为 production 去除 react 代码中的开发时才需要的部分</span></span><br><span class="line">      <span class="string">'process.env'</span>: &#123;</span><br><span class="line">        NODE_ENV: <span class="built_in">JSON</span>.stringify(<span class="string">'production'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 使用 ParallelUglifyPlugin 并行压缩输出的 JS 代码</span></span><br><span class="line">    <span class="keyword">new</span> ParallelUglifyPlugin(&#123;</span><br><span class="line">      <span class="comment">// 传递给 UglifyJS 的参数</span></span><br><span class="line">      uglifyJS: &#123;</span><br><span class="line">        output: &#123;</span><br><span class="line">          <span class="comment">// 最紧凑的输出</span></span><br><span class="line">          beautify: <span class="literal">false</span>,</span><br><span class="line">          <span class="comment">// 删除所有的注释</span></span><br><span class="line">          comments: <span class="literal">false</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        compress: &#123;</span><br><span class="line">          <span class="comment">// 在UglifyJs删除没有用到的代码时不输出警告</span></span><br><span class="line">          warnings: <span class="literal">false</span>,</span><br><span class="line">          <span class="comment">// 删除所有的 `console` 语句，可以兼容ie浏览器</span></span><br><span class="line">          drop_console: <span class="literal">true</span>,</span><br><span class="line">          <span class="comment">// 内嵌定义了但是只用到一次的变量</span></span><br><span class="line">          collapse_vars: <span class="literal">true</span>,</span><br><span class="line">          <span class="comment">// 提取出出现多次但是没有定义成变量去引用的静态值</span></span><br><span class="line">          reduce_vars: <span class="literal">true</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;优化可以分为&lt;code&gt;优化开发体验&lt;/code&gt;和&lt;code&gt;优化输出质量&lt;/code&gt;两部分。&lt;/p&gt;
&lt;h1 id=&quot;优化开发体验&quot;&gt;&lt;a href=&quot;#优化开发体验&quot; class=&quot;headerlink&quot; title=&quot;优化开发体验&quot;&gt;&lt;/a&gt;优化开发体验&lt;/h1&gt;
      
    
    </summary>
    
      <category term="构建" scheme="http://yoursite.com/categories/%E6%9E%84%E5%BB%BA/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化</title>
    <link href="http://yoursite.com/2018/09/28/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    <id>http://yoursite.com/2018/09/28/前端工程化/</id>
    <published>2018-09-28T06:29:31.000Z</published>
    <updated>2018-10-08T02:21:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>前端工程化：开发需求、共享需求、性能需求、部署需求。为了简化前端工程化的配置，出现了很多优秀的工具比如：<br>1、前端工作流工具：Gulp，Grunt，Broccoli<br>2、前端 JS 模块编译工具：Babel，Browserify，Webpack<br>3、前端开发系列工具： livereload，数据 mock，代码监控，代码检查</p><h2 id="开发需求"><a href="#开发需求" class="headerlink" title="开发需求"></a>开发需求</h2><p>在开始一个前端项目时，通常需要进行技术选型，定义代码规范以及配合后端和业务进行项目的目录规划</p><ol><li>代码规范：jslint、SASSLint、ESLint/TSLint….</li><li>JS 预处理：（编译过程）</li></ol><ul><li>编程语言：Coffeescript、Livescript、Typescript、React Jsx、Dart、Elm….</li><li>ES6</li><li>CommonJS</li></ul><p>Typescript 中提供静态语法的一些强类型特性。<br>Coffeescript, Livescript 提供现代化语言的语法糖特性，专门针对 xml 优化的 JSX。</p><ol start="3"><li><p>CSS 预处理：less、sass…<br>预处理工具：Autoprefixer、Compass</p></li><li><p>文件处理： src 放置源码，dist 放置编译后的代码</p></li><li>开发效率：webpack的Hot Module Replacement， livereload 自动刷新浏览器</li><li>数据 mock：可构建mock平台</li><li>域名代理</li></ol><h2 id="共享需求"><a href="#共享需求" class="headerlink" title="共享需求"></a>共享需求</h2><p>设计前端项目架构时，一定要考虑业务的组件化和可共享性：</p><ul><li>Base 基础代码共享</li><li>通用工具方法共享</li><li>基础交互组件共享</li><li>业务组件共享</li></ul><h2 id="性能需求"><a href="#性能需求" class="headerlink" title="性能需求"></a>性能需求</h2><p>优化源码的体积是提升首屏加载时间的关键：</p><ol><li>Javascript, Css 代码压缩</li><li>Javascript, Css 代码合并</li><li>图片压缩</li><li>Css 图片精灵或雪碧图（css sprit）</li></ol><p>可以在前端工程的 build 过程中实现。</p><h2 id="部署需求"><a href="#部署需求" class="headerlink" title="部署需求"></a>部署需求</h2><ol><li>多人分支协作流程：用 git flow 来管理代码分支</li><li>代码自动发布：git hookgit hook实现代码自动部署</li></ol><h2 id="前端工作流工具"><a href="#前端工作流工具" class="headerlink" title="前端工作流工具"></a>前端工作流工具</h2><ol><li>Grunt: 基于配置的工作流模式，定义一个配置文件，声明工作流各个环节的相关配置，调用 grunt 就能完成打包编译.</li><li>Broccoli: 以 tree 的基础结构，提供极其高效稳定的工作流。</li><li>Gulp: 基于内存的流的方式，提供高效的性能，极简的 API，定义不同的 task，然后将 task 串联起来。</li></ol><h2 id="前端-Javascript-编译工具"><a href="#前端-Javascript-编译工具" class="headerlink" title="前端 Javascript 编译工具"></a>前端 Javascript 编译工具</h2><ol><li>Babel</li><li>Browserify: 是最先出现的 CommonJs 编译工具，使得我们可以像写 Node 模块一样写前端代码，Browserify 可以 build 使用 npm 中的所有模块。</li><li>Webpack: 是支持 CommonJs 和 AMD 的模块编译工具，逐渐替代 Browserify, 基于 AMD 的好处就是代码可以异步话，这是 Browserify 无法做到的。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前端工程化：开发需求、共享需求、性能需求、部署需求。为了简化前端工程化的配置，出现了很多优秀的工具比如：&lt;br&gt;1、前端工作流工具：Gulp，Grunt，Broccoli&lt;br&gt;2、前端 JS 模块编译工具：Babel，Browserify，Webpack&lt;br&gt;3、前端开
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>parceljs &amp; webpack</title>
    <link href="http://yoursite.com/2018/09/28/%5B%E6%9E%84%E5%BB%BA%5D%20parceljs%20&amp;%20webpack/"/>
    <id>http://yoursite.com/2018/09/28/[构建] parceljs &amp; webpack/</id>
    <published>2018-09-28T06:29:31.000Z</published>
    <updated>2018-10-08T02:21:31.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="构建" scheme="http://yoursite.com/categories/%E6%9E%84%E5%BB%BA/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack 进阶</title>
    <link href="http://yoursite.com/2018/09/28/%5B%E6%9E%84%E5%BB%BA%5D%20webpack%E8%BF%9B%E9%98%B6/"/>
    <id>http://yoursite.com/2018/09/28/[构建] webpack进阶/</id>
    <published>2018-09-28T06:09:21.000Z</published>
    <updated>2018-10-17T16:45:50.885Z</updated>
    
    <content type="html"><![CDATA[<p>在使用 webpack 构建的典型应用程序或站点中，有三种主要的代码类型：<br>1、团队编写的源码。<br>2、源码会依赖的任何第三方的 library 或 “vendor” 代码。<br>3、webpack 的 runtime 和 manifest，管理所有模块的交互。<br>runtime 包含：在模块交互时，连接模块所需的加载和解析逻辑。包括浏览器中的已加载模块的连接，以及懒加载模块的执行逻辑。<br>通过使用 manifest 中的数据，runtime 将能够查询模块标识符，检索出背后对应的模块。<br>import 或 require 语句现在都已经转换为 <strong>webpack_require</strong> 方法，此方法指向模块标识符(module identifier)</p><h2 id="配置分离"><a href="#配置分离" class="headerlink" title="配置分离"></a>配置分离</h2><p>在大型项目中，webpack.config.js 会变得越来越臃肿，因此可以利用 webpack-merge 插件。将配置定义在一个目录下面的不同文件中，然后通过 webpack-merge 来合并成最终的配置。</p><h2 id="code-splitting-异步加载"><a href="#code-splitting-异步加载" class="headerlink" title="code splitting 异步加载"></a>code splitting 异步加载</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在使用 webpack 构建的典型应用程序或站点中，有三种主要的代码类型：&lt;br&gt;1、团队编写的源码。&lt;br&gt;2、源码会依赖的任何第三方的 library 或 “vendor” 代码。&lt;br&gt;3、webpack 的 runtime 和 manifest，管理所有模块的交互。
      
    
    </summary>
    
      <category term="构建" scheme="http://yoursite.com/categories/%E6%9E%84%E5%BB%BA/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack 入门</title>
    <link href="http://yoursite.com/2018/09/28/%5B%E6%9E%84%E5%BB%BA%5D%20webpack%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2018/09/28/[构建] webpack入门/</id>
    <published>2018-09-28T03:42:48.000Z</published>
    <updated>2018-10-17T17:09:38.655Z</updated>
    
    <content type="html"><![CDATA[<h2 id="论述"><a href="#论述" class="headerlink" title="论述"></a>论述</h2><p><code>CommonJS</code> 是一种使用广泛的 JavaScript 模块化规范，核心思想是通过 require 方法来同步地加载依赖的其他模块，通过 module.exports 导出需要暴露的接口。<br><code>CommonJS</code> 的优点在于：</p><ul><li>代码可复用于 Node.js 环境下并运行，例如做同构应用；</li><li>通过 NPM 发布的很多第三方模块都采用了 CommonJS 规范。</li></ul><p><code>CommonJS</code> 的缺点在于这样的代码无法直接运行在浏览器环境下，必须通过工具转换成标准的 ES5。</p><p><code>AMD</code> 也是一种 JavaScript 模块化规范，与 CommonJS 最大的不同在于它采用异步的方式去加载依赖的模块。 AMD 规范主要是为了解决针对浏览器环境的模块化问题，最具代表性的实现是 requirejs。<br><code>AMD</code> 的优点在于：</p><ul><li>可在不转换代码的情况下直接在浏览器中运行；</li><li>可异步加载依赖；</li><li>可并行加载多个依赖；</li><li>代码可运行在浏览器环境和 Node.js 环境下。</li></ul><p><code>AMD</code> 的缺点在于JavaScript 运行环境没有原生支持 AMD，需要先导入实现了 AMD 的库后才能正常使用。</p><p><code>TypeScript</code> 的缺点在于语法相对于 JavaScript 更加啰嗦，并且无法直接运行在浏览器或 Node.js 环境下。<br><code>Flow</code> 也是 JavaScript 的一个超集，它的主要特点是为 JavaScript 提供静态类型检查，和 TypeScript 相似但更灵活，可以让你只在需要的地方加上类型检查。</p><h2 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h2><p>构建就是做这件事情，把源代码转换成发布到线上的可执行 JavaScrip、CSS、HTML 代码，包括如下内容。</p><ul><li>代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等。</li><li>文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。</li><li>代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。</li><li>模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。</li><li>自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。</li><li>代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。</li><li>自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。</li></ul><h2 id="webpack配置"><a href="#webpack配置" class="headerlink" title="webpack配置"></a>webpack配置</h2><p>webpack官方提供的配置方法是通过module.exports返回一个json，但是这种场景不灵活，不能适配多种场景。<br>最佳方式：<br>1、两份配置文件webpack.config.production.js/webpack.config.development.js，然后不同场景下，使用不同的配置文件。<br>2、通过module.exports返回函数，该函数能接受参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">env</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    context: config.context,</span><br><span class="line">    entry: config.src,</span><br><span class="line">    output: &#123;</span><br><span class="line">      path: path.join(config.jsDest, project),</span><br><span class="line">      filename: <span class="string">'[name].js'</span>,</span><br><span class="line">      chunkFilename: <span class="string">'[name].[chunkhash:8].js'</span>,</span><br><span class="line">      publicPath: <span class="string">'/assets/'</span> + project + <span class="string">'/'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    devtool: <span class="string">"eval"</span>,</span><br><span class="line">    watch: <span class="literal">false</span>,</span><br><span class="line">    profile: <span class="literal">true</span>,</span><br><span class="line">    cache: <span class="literal">true</span>,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">      loaders: getLoaders(env)</span><br><span class="line">    &#125;,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">      alias: getAlias(env)</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: getPlugins(env)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>context</code>：上下文。<br><code>entry</code>：入口文件，是所有依赖关系的入口，webpack从这个入口开始静态解析，分析模块之间的依赖关系。<br><code>output</code>：打包输出的配置。<br><code>devtools</code>：SourceMap选项，便于开发模式下调试。<br><code>watch</code>：监听模式，增量更新，开发必备！<br><code>profile</code>：优化。<br><code>cache</code>：webpack构建的过程中会生成很多临时的文件，打开cache可以让这些临时的文件缓存起来，从而更快的构建。<br><code>module.loaders</code>：loaders用来对文件做预处理。这样webpack就可以打包任何静态文件。<br><code>resolve.alias</code>：模块别名，这样可以更方便的引用模块。<br><code>plugins</code>：webpack的一些内置功能均是以插件的形式提供。</p><h2 id="webpack-使用"><a href="#webpack-使用" class="headerlink" title="webpack 使用"></a>webpack 使用</h2><h4 id="1、命令行调用"><a href="#1、命令行调用" class="headerlink" title="1、命令行调用"></a>1、命令行调用</h4><p>webpack可以在终端中使用：</p><ul><li>{extry file}填写入口文件的路径</li><li>{destination for bundled file}处填写打包文件的存放路径</li><li>填写路径的时候不用添加{}<br><code>webpack {entry file}  {destination for bundled file}</code>  （全局模式）<br><code>node_modules/.bin/webpack  app/main.js  public/bundle.js</code> （非全局安装的情况）</li></ul><h4 id="2、入口与输出"><a href="#2、入口与输出" class="headerlink" title="2、入口与输出"></a>2、入口与输出</h4><p>模板<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  entry: [<span class="built_in">String</span> | <span class="built_in">Array</span> | <span class="built_in">Object</span>], <span class="comment">// 入口模块</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: <span class="built_in">String</span>,                   <span class="comment">// 输出路径</span></span><br><span class="line">    filename: <span class="built_in">String</span>                <span class="comment">// 输出名称或名称 pattern</span></span><br><span class="line">    publicPath: <span class="built_in">String</span>              <span class="comment">// 指定静态资源的位置</span></span><br><span class="line">    ...                             <span class="comment">// 其他配置</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li><p>多个入口文件：eg: <code>entry: [&#39;./src/index.js&#39;, &#39;./vendor/bootstrap.min.js&#39;]</code> 一个入口，多个文件<br>最终 bootstrap 会被追加到打包好的 index.js 中，数组中的最后一个会被 export。</p></li><li><p>多个打包目标</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    a: <span class="string">'./src/a.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: <span class="string">'./dist/'</span>,</span><br><span class="line">    filename: <span class="string">'[name].js'</span> </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="3、生成Source-Maps（使调试更容易）——-devtool"><a href="#3、生成Source-Maps（使调试更容易）——-devtool" class="headerlink" title="3、生成Source Maps（使调试更容易）——  devtool"></a>3、生成Source Maps（使调试更容易）——  devtool</h4><p>webpack就可以在打包时为我们生成的source maps，提供了一种对应编译文件和源文件的方法，使得编译后的代码可读性更高，也更容易调试。<br>在webpack的配置文件中配置source maps，需要配置devtool，有四种不同的配置选项：</p><ul><li><code>source-map</code>：在一个单独的文件中产生一个完整且功能完全的文件，但它会减慢打包速度</li><li><code>cheap-module-source-map</code>：在一个单独的文件中生成一个不带列映射的map，不带列映射提高了打包速度，但不能对应到具体的列（符号），会对调试造成不便；</li><li><code>eval-source-map</code>：使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。其可以在不影响构建速度的前提下生成完整的sourcemap，但对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定不要启用这个选项；</li><li><code>cheap-module-eval-source-map</code>：在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点。（cheap-module-eval-source-map方法构建速度更快，但是不利于调试，推荐在大型项目考虑时间成本时使用。）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: __dirname + <span class="string">'/app/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + <span class="string">'/public'</span>,</span><br><span class="line">    filename: <span class="string">'bundle-[hash:7].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: <span class="string">'eval-source-map'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、使用webpack构建本地服务器（webpack-dev-server）——-devServer"><a href="#4、使用webpack构建本地服务器（webpack-dev-server）——-devServer" class="headerlink" title="4、使用webpack构建本地服务器（webpack-dev-server）—— devServer"></a>4、使用webpack构建本地服务器（webpack-dev-server）—— devServer</h4><p>背景：浏览器监听代码的修改，并自动刷新显示修改后的结果<br>Webpack提供一个可选的本地开发服务器，该本地服务器基于node.js构建<br>先安装：npm install –save-dev webpack-dev-server<br>再配置: devserver</p><ul><li><code>contentBase</code>：默认webpack-dev-server会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录</li><li><code>port</code>：设置默认监听端口，默认“8080”；</li><li><code>inline</code>：设置为true，当源文件改变时会自动刷新页面；</li><li><code>historyApiFallback</code>：若设置true，所有的跳转将指向index.html，在单页应用时有用，它依赖于HTML5 history API</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: __dirname + <span class="string">'/app/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + <span class="string">'/public'</span>,</span><br><span class="line">    filename: <span class="string">'bundle-[hash:7].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: <span class="string">'eval-source-map'</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./public'</span>,    <span class="comment">// 本地服务器所加载的页面所在的目录</span></span><br><span class="line">    historyApiFallback: <span class="literal">true</span>,   <span class="comment">// 不跳转</span></span><br><span class="line">    inline: <span class="literal">true</span>                <span class="comment">// 实时刷新</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、loader"><a href="#5、loader" class="headerlink" title="5、loader"></a>5、loader</h4><p>使用不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理<br>在 webpack 中，通过 loader 可以实现 JSX 、Es6、CoffeeScript 等的转换.</p><ul><li>分析转换scss为css</li><li>把下一代的JS文件（ES6，ES7)转换为现代浏览器兼容的JS文件</li><li>把React的中用到的JSX文件转换为JS文件</li><li>……<br>Loader需要单独安装，并在config.js 中的 modules关键字中进行配置<br>Loader 的配置说明：</li><li><code>test</code>：一个用以匹配loaders所处理文件的拓展名的正则表达式（必须）</li><li><code>loader</code>：loader的名称（必须）</li><li><code>include/exclude</code>:手动添加必须处理的文件/文件夹或屏蔽不需要处理的文件/文件夹（可选）</li><li><code>query</code>：为loaders提供额外的设置选项（可选）</li></ul><p><strong>loader 除了做文件转换以外，还可以创建额外的文件</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    <span class="comment">// template loaders</span></span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.(tpl|html)$/</span>,</span><br><span class="line">      use: <span class="string">'html-loader'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.art$/</span>,</span><br><span class="line">      use: <span class="string">'art-template-loader'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.(hbs|handlebars)$/</span>,</span><br><span class="line">      use: <span class="string">'handlebars-loader'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// picture loader</span></span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        query: &#123;</span><br><span class="line">          limit: <span class="number">8192</span>,</span><br><span class="line">          name: <span class="string">'img/[name].[ext]'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// font loader</span></span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/(\.(woff2?|eot|ttf|otf)|font.*\.svg)(\?.*)?$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        query: &#123;</span><br><span class="line">          limit: <span class="number">8192</span>,</span><br><span class="line">          name: <span class="string">'fonts/[name].[ext]'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// media file loader</span></span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.(mp4|3gp|avi|mkv|wmv|mpg|vob|flv|swf|mov|rmvb|mp3|wma|wav|aac|ogg|flac|ape|m4a)$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        query: &#123;</span><br><span class="line">          limit: <span class="number">8192</span>,</span><br><span class="line">          name: <span class="string">'media/[name].[ext]'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="6、Babel"><a href="#6、Babel" class="headerlink" title="6、Babel"></a>6、Babel</h4><p>作用：是一个编译 JS 的平台：</p><ul><li>使用下一代的 JS 代码（ES6，ES7…），即使这些标准目前并未被当前的浏览器完全的支持；</li><li>使用基于 JS 进行了拓展的语言，比如React的JSX；<br>安装：<code>npm install --save-dev  babel-core  babel-loader  babel-preset-es2015  babel-preset-react</code><br>Babel其实是几个模块化的包，其核心功能位于称为<code>babel-core</code>的npm包中，webpack可以把其不同的包整合在一起使用，对于每一个需要的功能或拓展，你都需要安装单独的包（用得最多的是解析ES6的<code>babel-preset-es2015</code>包和解析JSX的<code>babel-preset-react</code>包）。</li></ul><h4 id="7、Babel的配置"><a href="#7、Babel的配置" class="headerlink" title="7、Babel的配置"></a>7、Babel的配置</h4><p>Babel 可以完全在<code>webpack.config.js</code>中进行配置，但复杂度增加时会单独有<code>.babelrc</code>的配置文件<br>webpack会自动调用<code>.babelrc</code>里的babel配置选项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: __dirname + <span class="string">'/app/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + <span class="string">'/public'</span>,</span><br><span class="line">    filename: <span class="string">'bundle-[hash:7].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: <span class="string">'eval-source-map'</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./public'</span>,    <span class="comment">// 本地服务器所加载的页面所在的目录</span></span><br><span class="line">    historyApiFallback: <span class="literal">true</span>,   <span class="comment">// 不跳转</span></span><br><span class="line">    inline: <span class="literal">true</span>                <span class="comment">// 实时刷新</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="regexp">/(\.jsx|\.js)/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      exclude: <span class="regexp">/node-module/</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .babelrc</span></span><br><span class="line">&#123;</span><br><span class="line">  persets: [<span class="string">'es2015'</span>, <span class="string">'react'</span>, <span class="string">'stage-0'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8、CSS-module"><a href="#8、CSS-module" class="headerlink" title="8、CSS module"></a>8、CSS module</h4><p>CSS modules 的技术：把JS的模块化思想带入CSS中来，通过CSS模块，所有的类名，动画名默认都只作用于当前模块。<br>Webpack从一开始就对CSS模块化提供了支持，在CSS loader中进行配置后。<br>首先把”modules“传递到所需要的地方<br>然后就可以直接把CSS的类名传递到组件的代码中<br>好处：这样做只对当前组件有效，不必担心在不同的模块中使用相同的类名造成冲突。</p><h4 id="9、CSS预处理器-PostCSS-autoprefixer"><a href="#9、CSS预处理器-PostCSS-autoprefixer" class="headerlink" title="9、CSS预处理器 / PostCSS / autoprefixer"></a>9、CSS预处理器 / PostCSS / autoprefixer</h4><p><code>Sass</code> 和 <code>Less</code> 之类的预处理器是对原生CSS的拓展，它们允许使用类似于variables, nesting, mixins, inheritance等不存在于CSS中的特性来写CSS。<br>在webpack里使用loader进行配置：<code>less-loader、sass-loader、style-loader</code></p><p>PostCSS 是一个允许使用 JS 插件转换样式的工具。 这些插件可以检查（lint）你的 CSS，支持 CSS Variables 和 Mixins，CSS 自动加前缀、使用下一代 CSS 语法等.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: __dirname + <span class="string">'/app/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + <span class="string">'/public'</span>,</span><br><span class="line">    filename: <span class="string">'bundle-[hash:7].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: <span class="string">'eval-source-map'</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./public'</span>,    <span class="comment">// 本地服务器所加载的页面所在的目录</span></span><br><span class="line">    historyApiFallback: <span class="literal">true</span>,   <span class="comment">// 不跳转</span></span><br><span class="line">    inline: <span class="literal">true</span>                <span class="comment">// 实时刷新</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="regexp">/(\.jsx|\.js)/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      exclude: <span class="regexp">/node-module/</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>]</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// postcss.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 需要使用的插件列表</span></span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'postcss-cssnext'</span>)    <span class="comment">// 使用下一代 CSS 语法编写代码</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10、插件（Plugins）—-banner-plugins-HtmlWebpackPlugin-Hot-Module-Replacement"><a href="#10、插件（Plugins）—-banner-plugins-HtmlWebpackPlugin-Hot-Module-Replacement" class="headerlink" title="10、插件（Plugins）— banner-plugins / HtmlWebpackPlugin / Hot Module Replacement"></a>10、插件（Plugins）— banner-plugins / HtmlWebpackPlugin / Hot Module Replacement</h4><p>插件（Plugins）是用来拓展Webpack功能，会在整个构建过程中生效，执行相关的任务。<br>loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，<br>插件并不直接操作单个文件，它直接对整个构建过程其作用。</p><h5 id="1-banner-plugins-添加版权声明"><a href="#1-banner-plugins-添加版权声明" class="headerlink" title="1.banner-plugins: 添加版权声明"></a>1.banner-plugins: 添加版权声明</h5><h5 id="2-HtmlWebpackPlugin（动态生成入口-html）"><a href="#2-HtmlWebpackPlugin（动态生成入口-html）" class="headerlink" title="2.HtmlWebpackPlugin（动态生成入口 html）"></a>2.HtmlWebpackPlugin（动态生成入口 html）</h5><p>依据一个简单的index.html模板，生成一个自动引用你打包后的JS文件的新index.html</p><h5 id="3-Hot-Module-Replacement-允许修改组件代码后，自动刷新实时预览修改后的效果。"><a href="#3-Hot-Module-Replacement-允许修改组件代码后，自动刷新实时预览修改后的效果。" class="headerlink" title="3.Hot Module Replacement: 允许修改组件代码后，自动刷新实时预览修改后的效果。"></a>3.Hot Module Replacement: 允许修改组件代码后，自动刷新实时预览修改后的效果。</h5><p>Hot Module Replacement（HMR）允许修改组件代码后，自动刷新实时预览修改后的效果。<br>配置：<br>1、在webpack配置文件中添加HMR插件；<br>2、在Webpack Dev Server中添加“hot”参数；<br>不过配置完后，JS模块其实还是不能自动热加载的，还需要在JS模块中执行一个Webpack提供的API才能实现热加载。<br>虽然这个API不难使用，但是如果是React模块，使用Babel可以更方便的实现功能热加载。<br>思路：</p><ul><li>HMR是一个webpack插件，它能在浏览器中实时观察模块修改后的效果，但如果想让它工作，需要对模块进行额外的配置；</li><li>Babel 有一个叫做react-transform-hrm 的插件，可以在不对React模块进行额外的配置的前提下让HMR正常工作；</li></ul><h4 id="11、优化插件"><a href="#11、优化插件" class="headerlink" title="11、优化插件"></a>11、优化插件</h4><ul><li><code>OccurenceOrderPlugin</code>:为组件分配ID，通过这个插件webpack可以分析和优先考虑使用最多的模块，并为它们分配最小的ID（内置插件）</li><li><code>UglifyJsPlugin</code>：压缩JS代码；（内置插件）</li><li><code>ExtractTextPlugin</code>：分离CSS和JS文件<br>安装ExtractTextPlugin：<code>npm install --save-dev extract-text-webpack-plugin</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: __dirname + <span class="string">'/app/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + <span class="string">'/public'</span>,</span><br><span class="line">    filename: <span class="string">'bundle-[hash:7].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: <span class="string">'eval-source-map'</span>,</span><br><span class="line">  devServer: &#123;&#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;&#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.BannerPlugins(<span class="string">'版权所有，翻版必究'</span>),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: __dirname + <span class="string">'/app/index.tmpl.html'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),   <span class="comment">// 热加载插件</span></span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.OccurenceOrderPlugin,</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin,</span><br><span class="line">    <span class="keyword">new</span> ExtractTextPlugin(<span class="string">'style.css'</span>)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .babelrc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">'persets'</span>: [<span class="string">'react'</span>, <span class="string">'es2015'</span>, <span class="string">'stage-0'</span>]</span><br><span class="line">  <span class="string">'env'</span>: &#123;</span><br><span class="line">    <span class="string">'devlopment'</span>: &#123;</span><br><span class="line">      <span class="string">'plugins'</span>: [[<span class="string">'react-transform'</span>, &#123;</span><br><span class="line">        transform: [&#123;</span><br><span class="line">          transform:: <span class="string">'react-transform-hmr'</span>,</span><br><span class="line">          imports: [<span class="string">'react'</span>],</span><br><span class="line">          locals: [<span class="string">'module'</span>]</span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;]]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package.json </span></span><br><span class="line"><span class="string">'script'</span>: &#123;</span><br><span class="line">  <span class="string">"test"</span><span class="string">': "echo \"Error: no test specified\" &amp;&amp; exit 1",</span></span><br><span class="line"><span class="string">  "start": "webpack",</span></span><br><span class="line"><span class="string">  "server": "webpack-dev-server --open",</span></span><br><span class="line"><span class="string">  "build": "NODE_ENV=production webpack --config ./webpack.config.js --progress"</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>HtmlWebpackPlugin 参数说明：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">  template: __dirname + <span class="string">'/app/index.tmpl.html'</span>,</span><br><span class="line">  title: <span class="string">'Test'</span>,</span><br><span class="line">  filename: <span class="string">'index.html'</span>,</span><br><span class="line">  inject: <span class="string">'body'</span>,</span><br><span class="line">  favicon: <span class="string">'./images/favico.ico'</span>,</span><br><span class="line">  minify: <span class="literal">true</span>,</span><br><span class="line">  hash: <span class="literal">true</span>,</span><br><span class="line">  cache: <span class="literal">false</span>,</span><br><span class="line">  showErrors: <span class="literal">false</span>,</span><br><span class="line">  xhtml: <span class="literal">false</span>,</span><br><span class="line">  chunks: &#123;</span><br><span class="line">    head: &#123;</span><br><span class="line">      entry: <span class="string">'assets/head_bundle.js'</span>,</span><br><span class="line">      css: [<span class="string">'main.css'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure></p><ul><li>title: 设置title的名字   </li><li>filename: 设置这个html的文件名   </li><li>template:要使用的模块的路径  </li><li>inject: 把模板注入到哪个标签后， ‘body’,</li><li>favicon: 给html添加一个favicon，  ‘./images/favico.ico’,</li><li>minify:是否压缩  {…} | false （最新api变动，原来是ture|false)</li><li>hash:是否hash化 true，false ,     </li><li>cache:是否缓存, </li><li>showErrors:是否显示错误,  </li><li>xhtml:是否自动毕业标签 默认false </li></ul><h4 id="12、缓存"><a href="#12、缓存" class="headerlink" title="12、缓存"></a>12、缓存</h4><p>缓存无处不在，使用缓存的最好方法是保证你的文件名和文件内容是匹配的（内容改变，名称相应改变）<br>解决办法：带hash值</p><p>配置说明：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// entry 表示 入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。</span></span><br><span class="line">  <span class="comment">// 类型可以是 string | object | array   </span></span><br><span class="line">  entry: <span class="string">'./app/entry'</span>, <span class="comment">// 只有1个入口，入口只有1个文件</span></span><br><span class="line">  entry: [<span class="string">'./app/entry1'</span>, <span class="string">'./app/entry2'</span>], <span class="comment">// 只有1个入口，入口有2个文件</span></span><br><span class="line">  entry: &#123; <span class="comment">// 有2个入口</span></span><br><span class="line">    a: <span class="string">'./app/entry-a'</span>,</span><br><span class="line">    b: [<span class="string">'./app/entry-b1'</span>, <span class="string">'./app/entry-b2'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如何输出结果：在 Webpack 经过一系列处理后，如何输出最终想要的代码。</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 输出文件存放的目录，必须是 string 类型的绝对路径。</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出文件的名称</span></span><br><span class="line">    filename: <span class="string">'bundle.js'</span>, <span class="comment">// 完整的名称</span></span><br><span class="line">    filename: <span class="string">'[name].js'</span>, <span class="comment">// 当配置了多个 entry 时，通过名称模版为不同的 entry 生成不同的文件名称</span></span><br><span class="line">    filename: <span class="string">'[chunkhash].js'</span>, <span class="comment">// 根据文件内容 hash 值生成文件名称，用于浏览器长时间缓存文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布到线上的所有资源的 URL 前缀，string 类型</span></span><br><span class="line">    publicPath: <span class="string">'/assets/'</span>, <span class="comment">// 放到指定目录下</span></span><br><span class="line">    publicPath: <span class="string">''</span>, <span class="comment">// 放到根目录下</span></span><br><span class="line">    publicPath: <span class="string">'https://cdn.example.com/'</span>, <span class="comment">// 放到 CDN 上去</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 导出库的名称，string 类型</span></span><br><span class="line">    <span class="comment">// 不填它时，默认输出格式是匿名的立即执行函数</span></span><br><span class="line">    library: <span class="string">'MyLibrary'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 导出库的类型，枚举类型，默认是 var</span></span><br><span class="line">    <span class="comment">// 可以是 umd | umd2 | commonjs2 | commonjs | amd | this | var | assign | window | global | jsonp ，</span></span><br><span class="line">    libraryTarget: <span class="string">'umd'</span>, </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否包含有用的文件路径信息到生成的代码里去，boolean 类型</span></span><br><span class="line">    pathinfo: <span class="literal">true</span>, </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 附加 Chunk 的文件名称</span></span><br><span class="line">    chunkFilename: <span class="string">'[id].js'</span>,</span><br><span class="line">    chunkFilename: <span class="string">'[chunkhash].js'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// JSONP 异步加载资源时的回调函数名称，需要和服务端搭配使用</span></span><br><span class="line">    jsonpFunction: <span class="string">'myWebpackJsonp'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成的 Source Map 文件名称</span></span><br><span class="line">    sourceMapFilename: <span class="string">'[file].map'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 浏览器开发者工具里显示的源码模块名称</span></span><br><span class="line">    devtoolModuleFilenameTemplate: <span class="string">'webpack:///[resource-path]'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步加载跨域的资源时使用的方式</span></span><br><span class="line">    crossOriginLoading: <span class="string">'use-credentials'</span>,</span><br><span class="line">    crossOriginLoading: <span class="string">'anonymous'</span>,</span><br><span class="line">    crossOriginLoading: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 配置模块相关</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [ <span class="comment">// 配置 Loader</span></span><br><span class="line">      &#123;  </span><br><span class="line">        test: <span class="regexp">/\.jsx?$/</span>, <span class="comment">// 正则匹配命中要使用 Loader 的文件</span></span><br><span class="line">        include: [ <span class="comment">// 只会命中这里面的文件</span></span><br><span class="line">          path.resolve(__dirname, <span class="string">'app'</span>)</span><br><span class="line">        ],</span><br><span class="line">        exclude: [ <span class="comment">// 忽略这里面的文件</span></span><br><span class="line">          path.resolve(__dirname, <span class="string">'app/demo-files'</span>)</span><br><span class="line">        ],</span><br><span class="line">        use: [ <span class="comment">// 使用那些 Loader，有先后次序，从后往前执行</span></span><br><span class="line">          <span class="string">'style-loader'</span>, <span class="comment">// 直接使用 Loader 的名称</span></span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,      </span><br><span class="line">            options: &#123; <span class="comment">// 给 html-loader 传一些参数</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    noParse: [ <span class="comment">// 不用解析和处理的模块</span></span><br><span class="line">      /special-library\.js$/  <span class="comment">// 用正则匹配</span></span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 配置插件</span></span><br><span class="line">  plugins: [],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 配置寻找模块的规则</span></span><br><span class="line">  resolve: &#123; </span><br><span class="line">    modules: [ <span class="comment">// 寻找模块的根目录，array 类型，默认以 node_modules 为根目录</span></span><br><span class="line">      <span class="string">'node_modules'</span>,</span><br><span class="line">      path.resolve(__dirname, <span class="string">'app'</span>)</span><br><span class="line">    ],</span><br><span class="line">    extensions: [<span class="string">'.js'</span>, <span class="string">'.json'</span>, <span class="string">'.jsx'</span>, <span class="string">'.css'</span>], <span class="comment">// 模块的后缀名</span></span><br><span class="line">    alias: &#123; <span class="comment">// 模块别名配置，用于映射模块</span></span><br><span class="line">       <span class="comment">// 把 'module' 映射 'new-module'，同样的 'module/path/file' 也会被映射成 'new-module/path/file'</span></span><br><span class="line">      <span class="string">'module'</span>: <span class="string">'new-module'</span>,</span><br><span class="line">      <span class="comment">// 使用结尾符号 $ 后，把 'only-module' 映射成 'new-module'，</span></span><br><span class="line">      <span class="comment">// 但是不像上面的，'module/path/file' 不会被映射成 'new-module/path/file'</span></span><br><span class="line">      <span class="string">'only-module$'</span>: <span class="string">'new-module'</span>, </span><br><span class="line">    &#125;,</span><br><span class="line">    alias: [ <span class="comment">// alias 还支持使用数组来更详细的配置</span></span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">'module'</span>, <span class="comment">// 老的模块</span></span><br><span class="line">        alias: <span class="string">'new-module'</span>, <span class="comment">// 新的模块</span></span><br><span class="line">        <span class="comment">// 是否是只映射模块，如果是 true 只有 'module' 会被映射，如果是 false 'module/inner/path' 也会被映射</span></span><br><span class="line">        onlyModule: <span class="literal">true</span>, </span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    symlinks: <span class="literal">true</span>, <span class="comment">// 是否跟随文件软链接去搜寻模块的路径</span></span><br><span class="line">    descriptionFiles: [<span class="string">'package.json'</span>], <span class="comment">// 模块的描述文件</span></span><br><span class="line">    mainFields: [<span class="string">'main'</span>], <span class="comment">// 模块的描述文件里的描述入口的文件的字段名称</span></span><br><span class="line">    enforceExtension: <span class="literal">false</span>, <span class="comment">// 是否强制导入语句必须要写明文件后缀</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出文件性能检查配置</span></span><br><span class="line">  performance: &#123; </span><br><span class="line">    hints: <span class="string">'warning'</span>, <span class="comment">// 有性能问题时输出警告</span></span><br><span class="line">    hints: <span class="string">'error'</span>, <span class="comment">// 有性能问题时输出错误</span></span><br><span class="line">    hints: <span class="literal">false</span>, <span class="comment">// 关闭性能检查</span></span><br><span class="line">    maxAssetSize: <span class="number">200000</span>, <span class="comment">// 最大文件大小 (单位 bytes)</span></span><br><span class="line">    maxEntrypointSize: <span class="number">400000</span>, <span class="comment">// 最大入口文件大小 (单位 bytes)</span></span><br><span class="line">    assetFilter: <span class="function"><span class="keyword">function</span>(<span class="params">assetFilename</span>) </span>&#123; <span class="comment">// 过滤要检查的文件</span></span><br><span class="line">      <span class="keyword">return</span> assetFilename.endsWith(<span class="string">'.css'</span>) || assetFilename.endsWith(<span class="string">'.js'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  devtool: <span class="string">'source-map'</span>, <span class="comment">// 配置 source-map 类型</span></span><br><span class="line"></span><br><span class="line">  context: __dirname, <span class="comment">// Webpack 使用的根目录，string 类型必须是绝对路径</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 配置输出代码的运行环境</span></span><br><span class="line">  target: <span class="string">'web'</span>, <span class="comment">// 浏览器，默认</span></span><br><span class="line">  target: <span class="string">'webworker'</span>, <span class="comment">// WebWorker</span></span><br><span class="line">  target: <span class="string">'node'</span>, <span class="comment">// Node.js，使用 `require` 语句加载 Chunk 代码</span></span><br><span class="line">  target: <span class="string">'async-node'</span>, <span class="comment">// Node.js，异步加载 Chunk 代码</span></span><br><span class="line">  target: <span class="string">'node-webkit'</span>, <span class="comment">// nw.js</span></span><br><span class="line">  target: <span class="string">'electron-main'</span>, <span class="comment">// electron, 主线程</span></span><br><span class="line">  target: <span class="string">'electron-renderer'</span>, <span class="comment">// electron, 渲染线程</span></span><br><span class="line"></span><br><span class="line">  externals: &#123; <span class="comment">// 使用来自 JavaScript 运行环境提供的全局变量</span></span><br><span class="line">    jquery: <span class="string">'jQuery'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  stats: &#123; <span class="comment">// 控制台输出日志控制</span></span><br><span class="line">    assets: <span class="literal">true</span>,</span><br><span class="line">    colors: <span class="literal">true</span>,</span><br><span class="line">    errors: <span class="literal">true</span>,</span><br><span class="line">    errorDetails: <span class="literal">true</span>,</span><br><span class="line">    hash: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  devServer: &#123; <span class="comment">// DevServer 相关的配置</span></span><br><span class="line">    proxy: &#123; <span class="comment">// 代理到后端服务接口</span></span><br><span class="line">      <span class="string">'/api'</span>: <span class="string">'http://localhost:3000'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    contentBase: path.join(__dirname, <span class="string">'public'</span>), <span class="comment">// 配置 DevServer HTTP 服务器的文件根目录</span></span><br><span class="line">    compress: <span class="literal">true</span>, <span class="comment">// 是否开启 gzip 压缩</span></span><br><span class="line">    historyApiFallback: <span class="literal">true</span>, <span class="comment">// 是否开发 HTML5 History API 网页</span></span><br><span class="line">    hot: <span class="literal">true</span>, <span class="comment">// 是否开启模块热替换功能</span></span><br><span class="line">    https: <span class="literal">false</span>, <span class="comment">// 是否开启 HTTPS 模式</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    profile: <span class="literal">true</span>, <span class="comment">// 是否捕捉 Webpack 构建的性能信息，用于分析什么原因导致构建性能不佳</span></span><br><span class="line"></span><br><span class="line">    cache: <span class="literal">false</span>, <span class="comment">// 是否启用缓存提升构建速度</span></span><br><span class="line"></span><br><span class="line">    watch: <span class="literal">true</span>, <span class="comment">// 是否开始</span></span><br><span class="line">    watchOptions: &#123; <span class="comment">// 监听模式选项</span></span><br><span class="line">    <span class="comment">// 不监听的文件或文件夹，支持正则匹配。默认为空</span></span><br><span class="line">    ignored: <span class="regexp">/node_modules/</span>,</span><br><span class="line">    <span class="comment">// 监听到变化发生后会等300ms再去执行动作，防止文件更新太快导致重新编译频率太高</span></span><br><span class="line">    <span class="comment">// 默认为300ms </span></span><br><span class="line">    aggregateTimeout: <span class="number">300</span>,</span><br><span class="line">    <span class="comment">// 判断文件是否发生变化是不停的去询问系统指定文件有没有变化，默认每秒问 1000 次</span></span><br><span class="line">    poll: <span class="number">1000</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;论述&quot;&gt;&lt;a href=&quot;#论述&quot; class=&quot;headerlink&quot; title=&quot;论述&quot;&gt;&lt;/a&gt;论述&lt;/h2&gt;&lt;p&gt;&lt;code&gt;CommonJS&lt;/code&gt; 是一种使用广泛的 JavaScript 模块化规范，核心思想是通过 require 方法来同步地
      
    
    </summary>
    
      <category term="构建" scheme="http://yoursite.com/categories/%E6%9E%84%E5%BB%BA/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Object 创建/修改/获取属性的方法</title>
    <link href="http://yoursite.com/2018/09/26/%5BJS%5D%20%E5%88%9B%E5%BB%BA%E3%80%81%E4%BF%AE%E6%94%B9%E3%80%81%E8%8E%B7%E5%8F%96%E5%B1%9E%E6%80%A7%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/09/26/[JS] 创建、修改、获取属性的方法/</id>
    <published>2018-09-26T10:08:12.000Z</published>
    <updated>2018-10-08T02:21:39.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Object-defineProperty-obj-prop-descriptor"><a href="#Object-defineProperty-obj-prop-descriptor" class="headerlink" title="Object.defineProperty(obj, prop, descriptor)"></a>Object.defineProperty(obj, prop, descriptor)</h3><p>会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。<br>若不指定configurable, writable, enumerable ，则这些属性默认值为false；<br>若不指定value, get, set，则这些属性默认值为undefined。</p><ul><li>obj: 需要被操作的目标对象</li><li>prop: 目标对象需要定义或修改的属性的名称</li><li>descriptor: 将被定义或修改的属性的描述符</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    value: <span class="string">'张三'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj.name)  <span class="comment">//张三</span></span><br></pre></td></tr></table></figure><h3 id="Object-defineProperties-obj-props"><a href="#Object-defineProperties-obj-props" class="headerlink" title="Object.defineProperties(obj, props)"></a>Object.defineProperties(obj, props)</h3><p>直接在一个对象上定义一个或多个新的属性或修改现有属性，并返回该对象。</p><ul><li>props: 该对象的一个或多个键值对定义了将要为对象添加或修改的属性的具体配置。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(obj, &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        value: <span class="string">'张三'</span>,</span><br><span class="line">        configurable: <span class="literal">false</span>,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        enumerable: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    age: &#123;</span><br><span class="line">        value: <span class="number">18</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj.name, obj.age) <span class="comment">// 张三, 18</span></span><br></pre></td></tr></table></figure><p>在不支持 Object.defineProperties() 方法的浏览器中不能修改[[configurable]]和[[enumerable]]。</p><h3 id="Object-getOwnPropertyDescriptor-obj-prop"><a href="#Object-getOwnPropertyDescriptor-obj-prop" class="headerlink" title="Object.getOwnPropertyDescriptor(obj, prop)"></a>Object.getOwnPropertyDescriptor(obj, prop)</h3><p>返回指定对象上一个自有属性对应的属性描述符。</p><ul><li>prop: 目标对象内属性名称。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'张三'</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">'name'</span>); </span><br><span class="line"><span class="built_in">console</span>.log(desc);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     configurable: true,</span></span><br><span class="line"><span class="comment">//     enumerable: true,</span></span><br><span class="line"><span class="comment">//     writable: true,</span></span><br><span class="line"><span class="comment">//     value: "张三"</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h3 id="Object-getOwnPropertyDescriptors-obj-prop"><a href="#Object-getOwnPropertyDescriptors-obj-prop" class="headerlink" title="Object.getOwnPropertyDescriptors(obj, prop)"></a>Object.getOwnPropertyDescriptors(obj, prop)</h3><p>所指定对象的所有自身属性的描述符，如果没有任何自身属性，则返回空对象。<br>返回值是一个对象，若是访问器属性，该对象有Configurable、Enumberable、Get和set；<br>若是数据属性，该对象有Configurable、Enumberable、Writable和Value；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</span><br><span class="line">    _year: &#123;</span><br><span class="line">        value: <span class="number">2004</span></span><br><span class="line">    &#125;,</span><br><span class="line">    edition: &#123;</span><br><span class="line">        value: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    year: &#123;</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>._year = newValue;</span><br><span class="line">                <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> descriptor =  <span class="built_in">Object</span>.getOwnPropertyDescriptors(book, <span class="string">'_year'</span>);</span><br><span class="line">descriptor.value;               <span class="comment">// 2004</span></span><br><span class="line">descriptor.configurable;        <span class="comment">// false</span></span><br><span class="line"><span class="keyword">typeof</span> descriptor.get;          <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptors(book, <span class="string">'year'</span>);</span><br><span class="line">descriptor.value;               <span class="comment">// undefined</span></span><br><span class="line">descriptor.enumberable;         <span class="comment">// false</span></span><br><span class="line"><span class="keyword">typeof</span> descriptor.get;          <span class="comment">// function</span></span><br></pre></td></tr></table></figure><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p>在调用 Object.defineProperty() 方法时，如果不指定，configrubale、enumerable和writable 默认都为false。</p><h4 id="configrubale"><a href="#configrubale" class="headerlink" title="configrubale"></a>configrubale</h4><p>设置configrubale属性为false，则不可使用delete操作符(在严格模式下抛出错误), 修改所有内部属性值会抛出错误。</p><h4 id="enumerable"><a href="#enumerable" class="headerlink" title="enumerable"></a>enumerable</h4><h4 id="writable"><a href="#writable" class="headerlink" title="writable"></a>writable</h4><h4 id="get-和-set"><a href="#get-和-set" class="headerlink" title="get 和 set"></a>get 和 set</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Object-defineProperty-obj-prop-descriptor&quot;&gt;&lt;a href=&quot;#Object-defineProperty-obj-prop-descriptor&quot; class=&quot;headerlink&quot; title=&quot;Object.def
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
</feed>
