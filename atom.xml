<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-15T06:21:22.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>rubyliuqq</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>移动浏览器的四大内核</title>
    <link href="http://yoursite.com/2018/10/15/%5B%E7%A7%BB%E5%8A%A8%E7%AB%AF%5D%E7%A7%BB%E5%8A%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9B%9B%E5%A4%A7%E5%86%85%E6%A0%B8/"/>
    <id>http://yoursite.com/2018/10/15/[移动端]移动浏览器的四大内核/</id>
    <published>2018-10-15T06:20:45.000Z</published>
    <updated>2018-10-15T06:21:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="四大浏览器内核优缺点"><a href="#四大浏览器内核优缺点" class="headerlink" title="四大浏览器内核优缺点"></a>四大浏览器内核优缺点</h2><ol><li>Trident:因为在早期IE占有大量的市场份额，所以以前有很多网页是根据这个Trident的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好，同时存在许多安全Bug。</li><li>Gecko:优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，缺点是消耗很多的资源，比如内存。</li><li>Webkit:优点就是Webkit拥有清晰的源码结构、极快的渲染速度，缺点是对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。</li><li>Presto：Presto内核被称为公认的浏览网页速度最快的内核，同时也是处理JS脚本最兼容的内核，能在Windows、Mac及Linux操作系统下完美运行。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;四大浏览器内核优缺点&quot;&gt;&lt;a href=&quot;#四大浏览器内核优缺点&quot; class=&quot;headerlink&quot; title=&quot;四大浏览器内核优缺点&quot;&gt;&lt;/a&gt;四大浏览器内核优缺点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Trident:因为在早期IE占有大量的市场份额，所以以前有很多
      
    
    </summary>
    
      <category term="移动端" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="移动端" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>跨域的实现方法</title>
    <link href="http://yoursite.com/2018/10/15/%5BJS%5D%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/10/15/[JS]跨域的实现方法/</id>
    <published>2018-10-15T03:09:12.000Z</published>
    <updated>2018-10-15T05:15:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>同源： “协议 + 域名 + 端口” 三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。<br>同源策略限制下 <code>cookie</code>、<code>localStorage</code>、<code>dom</code>、<code>ajax</code>、<code>IndexDB</code> 都是不支持跨域的。</p><h2 id="方法一、使用-jsonp-跨域"><a href="#方法一、使用-jsonp-跨域" class="headerlink" title="方法一、使用 jsonp 跨域"></a>方法一、使用 jsonp 跨域</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装 jsonp 跨域请求的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">&#123; url, params, cb &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 script 标签帮助我们发送请求</span></span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    params = &#123; ...params, cb &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环构建键值对形式的参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">        arr.push(<span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建全局函数</span></span><br><span class="line">    <span class="built_in">window</span>[cb] = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        resolve(data);</span><br><span class="line">        <span class="comment">// 在跨域拿到数据以后将 script 标签销毁</span></span><br><span class="line">        <span class="built_in">document</span>.body.removeChild(script);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接发送请求的参数并赋值到 src 属性</span></span><br><span class="line">    script.src = <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;arr.join(<span class="string">"&amp;"</span>)&#125;</span>`</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font color="#dd0000">缺点：</font><br>只能发送 get 请求 不支持 post、put、delete；<br>不安全，容易引发 xss 攻击。<br><br>## 方法二、使用 CORS 跨域<br><font color="#dd0000">使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。</font><p>使用场景：多用于开发时，前端与后台在不同的 ip 地址下进行数据访问。<br>案例说明：通过访问 <a href="http://localhost:3000/index.html（服务器1）" target="_blank" rel="noopener">http://localhost:3000/index.html（服务器1）</a> 获取 index.html 文件并执行其中的 Ajax 请求 <a href="http://localhost:4000/getDate（服务器2）" target="_blank" rel="noopener">http://localhost:4000/getDate（服务器2）</a> 接口去获取数据。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// 正常 cookie 是不允许跨域的</span></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'name=hello'</span>;</span><br><span class="line"><span class="comment">// cookie 想要实现跨域必须携带凭证</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// xhr.open('GET', 'http://localhost:4000/getDate', true);</span></span><br><span class="line">xhr.open(<span class="string">'PUT'</span>, <span class="string">'http://localhost:4000/getDate'</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置名为 name 的自定义请求头</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">'name'</span>, <span class="string">'hello'</span>);</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span> || xhr.status === <span class="number">304</span>) &#123;</span><br><span class="line">      <span class="comment">// 打印返回的数据</span></span><br><span class="line">      <span class="built_in">console</span>.log(xhr.response);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 打印后台设置的自定义头信息</span></span><br><span class="line">      <span class="built_in">console</span>.log(xhr.getResponseHeader(<span class="string">'name'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器2</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许访问域的白名单</span></span><br><span class="line"><span class="keyword">let</span> whiteList = [<span class="string">"http://localhost:3000"</span>];</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> origin = req.header.origin;</span><br><span class="line">  <span class="keyword">if</span> (whiteList.includes(origin)) &#123;</span><br><span class="line">    <span class="comment">// 设置那个源可以访问我，参数为 * 时，允许任何人访问，但是不可以和 cookie 凭证的响应头共同使用</span></span><br><span class="line">    res.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>, origin);</span><br><span class="line">    <span class="comment">// 想要获取 ajax 的头信息，需设置响应头</span></span><br><span class="line">    res.setHeader(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"name"</span>);</span><br><span class="line">    <span class="comment">// 处理复杂请求的头</span></span><br><span class="line">    res.setHeader(<span class="string">"Access-Control-Allow-Methods"</span>, <span class="string">"PUT"</span>);</span><br><span class="line">    <span class="comment">// 允许发送 cookie 凭证的响应头</span></span><br><span class="line">    res.setHeader(<span class="string">"Access-Control-Allow-Credentials"</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 允许前端获取哪个头信息</span></span><br><span class="line">    res.setHeader(<span class="string">"Access-Control-Expose-Headers"</span>, <span class="string">"name"</span>);</span><br><span class="line">    <span class="comment">// 处理 OPTIONS 预检的存活时间，单位 s</span></span><br><span class="line">    res.setHeader(<span class="string">"Access-Control-Max-Age"</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 发送 PUT 请求会做一个试探性的请求 OPTIONS，其实是请求了两次，当接收的请求为 OPTIONS 时不做任何处理</span></span><br><span class="line">    <span class="keyword">if</span> (req.method === <span class="string">"OPTIONS"</span>) &#123;</span><br><span class="line">      res.end();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.put(<span class="string">"/getDate"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// res.setHeader('name', 'nihao'); // 设置自定义响应头信息</span></span><br><span class="line">  res.end(<span class="string">"I love you"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">"/getDate"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.end(<span class="string">"I love you"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(express.static(__dirname));</span><br><span class="line">app.listen(<span class="number">4000</span>);</span><br></pre></td></tr></table></figure><h2 id="方法三、使用-postMessage-实现跨域"><a href="#方法三、使用-postMessage-实现跨域" class="headerlink" title="方法三、使用 postMessage 实现跨域"></a>方法三、使用 postMessage 实现跨域</h2><p>postMessage 是 H5 的新 API，跨文档消息传送（cross-document messaging），有时简称为 XMD，指的是在来自不同域的页面间传递消息。</p><p><font color="#dd0000">使用场景：不是使用 Ajax 的数据通信，更多是在两个页面之间的通信，在 A 页面中引入 B 页面，使用iframe 标签, 在 A、B 两个页面之间通信。</font><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- a.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://localhost:4000/b.html"</span> <span class="attr">id</span>=<span class="string">"frame"</span> <span class="attr">onload</span>=<span class="string">"load()"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> frame = <span class="built_in">document</span>.getElementById(<span class="string">'frame'</span>);</span></span><br><span class="line"><span class="javascript">      frame.contentWindow.postMessage(<span class="string">'I love you'</span>, <span class="string">'http://localhost:4000'</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(e.data);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- b.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 打印来自页面 A 的消息</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(e.data);</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 给页面 A 发送回执</span></span></span><br><span class="line"><span class="javascript">      e.source.postMessage(<span class="string">'I love you, too'</span>, e.origin);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="方法四、使用-window-name-实现跨域"><a href="#方法四、使用-window-name-实现跨域" class="headerlink" title="方法四、使用 window.name 实现跨域"></a>方法四、使用 window.name 实现跨域</h2><p>同样是页面之间的通信，需要借助 iframe 标签<br>案例说明：A 页面和 B 页面是同域的 <a href="http://localhost:3000，C" target="_blank" rel="noopener">http://localhost:3000，C</a> 页面在独立的域 <a href="http://localhost:4000。" target="_blank" rel="noopener">http://localhost:4000。</a><br>在 A 页面中将 iframe 的 src 指向 C 页面，在 C 页面中将属性值存入 window.name 中，<br>再把 iframe 的 src 换成同域的 B 页面，在当前的 iframe 的 window 对象中取出 name 的值，访问 <a href="http://localhost:3000/a.html。" target="_blank" rel="noopener">http://localhost:3000/a.html。</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- a.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://localhost:4000/c.html"</span> <span class="attr">id</span>=<span class="string">"frame"</span> <span class="attr">onload</span>=<span class="string">"load()"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 增加一个标识，第一次触发 load 时更改地址，更改后再次触发直接取值</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> isFirst = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> frame = <span class="built_in">document</span>.getElementById(<span class="string">'frame'</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span>(isFirst) &#123;</span></span><br><span class="line"><span class="javascript">        frame.src = <span class="string">'http://localhost:3000/b.html'</span>;</span></span><br><span class="line"><span class="javascript">        isFirst = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(frame.contentWindow.name);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- c.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.name = <span class="string">'I love you'</span>;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="方法五、使用-location-hash-实现跨域"><a href="#方法五、使用-location-hash-实现跨域" class="headerlink" title="方法五、使用 location.hash 实现跨域"></a>方法五、使用 location.hash 实现跨域</h2><p><font color="#dd0000">与 window.name 跨域的情况相同，是不同域的页面间的参数传递</font><br>案例说明：需要借助 iframe 标签，A 页面和 B 页面是同域的 <a href="http://localhost:3000，C" target="_blank" rel="noopener">http://localhost:3000，C</a> 页面是独立的域 <a href="http://localhost:4000。" target="_blank" rel="noopener">http://localhost:4000。</a><br>A 页面通过 iframe 引入 C 页面，并给 C 页面传一个 hash 值，C 页面收到 hash 值后创建 iframe 引入 B 页面，<br>把 hash 值传给 B 页面，B 页面将自己的 hash 值放在 A 页面的 hash 值中，访问 <a href="http://localhost:3000/a.html。" target="_blank" rel="noopener">http://localhost:3000/a.html。</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- a.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://localhost:4000/c.html#Iloveyou"</span> <span class="attr">id</span>=<span class="string">"frame"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 使用 hashchange 事件接收来自 B 页面设置给 A 页面的 hash 值</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(location.hash);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- c.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 打印 A 页面引入 C 页面设置的 hash 值</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(location.hash);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span></span><br><span class="line"><span class="javascript">    iframe.src = <span class="string">'http://localhost:3000/b.html#Iloveyoutoo'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.appendChild(iframe);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- b.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 将 C 页面引入 B 页面设置的 hash 值设置给 A页面</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.parent.parent.location.hash = location.hash;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="方法六、使用-document-domain-实现跨域"><a href="#方法六、使用-document-domain-实现跨域" class="headerlink" title="方法六、使用 document.domain 实现跨域"></a>方法六、使用 document.domain 实现跨域</h2><p><font color="#dd0000">使用场景：不是万能的跨域方式，大多使用于同一公司不同产品间获取数据，必须是一级域名和二级域名的关系，如 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 与 video.baidu.com 之间。</font><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- http://www.domainacross.com:3000/a.html。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是页面 A 的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://sucess.domainacross.com:3000/b.html"</span> <span class="attr">onload</span>=<span class="string">"load()"</span> <span class="attr">id</span>=<span class="string">"frame"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.domain = <span class="string">'domainacross.com'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(frame.contentWindow.message);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是 B 页面的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.domain = <span class="string">'domainacross.com'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> message = <span class="string">'Hello A'</span>;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="方法七、使用-WebSocket-实现跨域"><a href="#方法七、使用-WebSocket-实现跨域" class="headerlink" title="方法七、使用 WebSocket 实现跨域"></a>方法七、使用 WebSocket 实现跨域</h2><p>WebSocket 没有跨域限制，高级 API（不兼容），想要兼容低版本浏览器，可以使用 socket.io 的库，<br>WebSocket 与 HTTP 内部都是基于 TCP 协议，区别在于 HTTP 是单向的（单双工），WebSocket 是双向的（全双工），<br>协议是 ws:// 和 wss:// 对应 http:// 和 https://，因为没有跨域限制，所以使用 file:// 协议也可以进行通信。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 创建 webSocket</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:3000'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 连接上触发</span></span></span><br><span class="line"><span class="javascript">    socket.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      socket.send(<span class="string">'I love you'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 收到消息触发</span></span></span><br><span class="line"><span class="javascript">    socket.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 打印收到的数据</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(e.data); <span class="comment">// I love you, too</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入 webSocket</span></span><br><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">"ws"</span>);</span><br><span class="line"><span class="comment">// 创建连接，端口号与前端相对应</span></span><br><span class="line"><span class="keyword">let</span> wss = <span class="keyword">new</span> WebSocket.Server(&#123; <span class="attr">port</span>: <span class="number">3000</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听连接</span></span><br><span class="line">wss.on(<span class="string">"connection"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ws</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 监听消息</span></span><br><span class="line">  ws.on(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 打印消息</span></span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// I love you</span></span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    ws.send(<span class="string">"I love you, too"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="方法八、使用-nginx-实现跨域"><a href="#方法八、使用-nginx-实现跨域" class="headerlink" title="方法八、使用 nginx 实现跨域"></a>方法八、使用 nginx 实现跨域</h2><h2 id="方法九、使用-http-proxy-middleware-实现跨域"><a href="#方法九、使用-http-proxy-middleware-实现跨域" class="headerlink" title="方法九、使用 http-proxy-middleware 实现跨域"></a>方法九、使用 http-proxy-middleware 实现跨域</h2><p>NodeJS 中间件 http-proxy-middleware 实现跨域代理，原理大致与 nginx 相同，都是通过启一个代理服务器，实现数据的转发，<br>也可以通过设置 cookieDomainRewrite 参数修改响应头中 cookie 中的域名，实现当前域的 cookie 写入，方便接口登录认证。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;同源： “协议 + 域名 + 端口” 三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。&lt;br&gt;同源策略限制下 &lt;code&gt;cookie&lt;/code&gt;、&lt;code&gt;localStorage&lt;/code&gt;、&lt;code&gt;dom&lt;/code&gt;、&lt;code&gt;ajax&lt;/
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Http协议知识</title>
    <link href="http://yoursite.com/2018/10/12/%5BHttp%5DHttp%E5%8D%8F%E8%AE%AE%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2018/10/12/[Http]Http协议知识/</id>
    <published>2018-10-12T07:44:41.000Z</published>
    <updated>2018-10-12T08:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="http协议的请求报文组成格式"><a href="#http协议的请求报文组成格式" class="headerlink" title="http协议的请求报文组成格式"></a>http协议的请求报文组成格式</h2><p>HTTP请求报文组成：请求行（＜request-line＞）、请求头部（＜headers＞）、空行（＜blank line＞）和请求数据（＜request-body＞）。</p><h4 id="1-请求行"><a href="#1-请求行" class="headerlink" title="1. 请求行"></a>1. 请求行</h4><p>请求行组成：请求方法、URL和HTTP协议版本字段组成，它们用空格分隔。<br>例如，GET /index.html HTTP/1.1。</p><font color="#dd0000">HTTP协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。</font><h4 id="2-请求头部"><a href="#2-请求头部" class="headerlink" title="2.请求头部"></a>2.请求头部</h4><p>请求头部通知服务器有关于客户端请求的信息：<br><code>User-Agent</code>：产生请求的浏览器类型。<br><code>Accept</code>：客户端可识别的内容类型列表。<br><code>Host</code>：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。</p><h4 id="3-请求数据"><a href="#3-请求数据" class="headerlink" title="3.请求数据"></a>3.请求数据</h4><p><font color="#dd0000">请求数据不在GET方法中使用，而是在POST方法中使用。</font><br>与请求数据相关的最常使用的请求头是Content-Type和Content-Length。</p><h2 id="http协议的响应报文组成格式"><a href="#http协议的响应报文组成格式" class="headerlink" title="http协议的响应报文组成格式"></a>http协议的响应报文组成格式</h2><p>HTTP响应也组成：状态行（＜status-line＞）、消息报头（＜headers＞）、响应正文（＜response-body＞）。</p><h4 id="1-状态行"><a href="#1-状态行" class="headerlink" title="1.状态行"></a>1.状态行</h4><p>状态行（status line）通过提供一个状态码来说明所请求的资源情况。</p><p>状态行格式：服务器HTTP协议的版本（HTTP-Version） 服务器发回的响应状态代码（Status-Code） 状态代码的文本描述（Reason-Phrase） CRLF<br>状态代码：</p><ul><li>1xx：指示信息–表示请求已接收，继续处理。</li><li>2xx：成功–表示请求已被成功接收、理解、接受。</li><li>3xx：重定向–要完成请求必须进行更进一步的操作。</li><li>4xx：客户端错误–请求有语法错误或请求无法实现。</li><li><p>5xx：服务器端错误–服务器未能实现合法的请求。</p></li><li><p>200 OK：客户端请求成功。</p></li><li>400 Bad Request：客户端请求有语法错误，不能被服务器所理解。</li><li>401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。</li><li>403 Forbidden：服务器收到请求，但是拒绝提供服务。</li><li>404 Not Found：请求资源不存在，举个例子：输入了错误的URL。</li><li>500 Internal Server  Error：服务器发生不可预期的错误。</li><li>503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。</li></ul><h2 id="状态码302与301的区别"><a href="#状态码302与301的区别" class="headerlink" title="状态码302与301的区别"></a>状态码302与301的区别</h2><p>302重定向表示临时性转移(Temporarily Moved )，当一个网页URL需要短期变化时使用。<br>301重定向/跳转一般，表示本网页永久性转移到另一个地址。<br>301是永久性转移(Permanently Moved), SEO常用的招式，会把旧页面的PR等信息转移到新页面<br>301重定向是永久的重定向，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。<br>302重定向是临时的重定向，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;http协议的请求报文组成格式&quot;&gt;&lt;a href=&quot;#http协议的请求报文组成格式&quot; class=&quot;headerlink&quot; title=&quot;http协议的请求报文组成格式&quot;&gt;&lt;/a&gt;http协议的请求报文组成格式&lt;/h2&gt;&lt;p&gt;HTTP请求报文组成：请求行（＜re
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Project Display</title>
    <link href="http://yoursite.com/2018/10/11/Project-Display/"/>
    <id>http://yoursite.com/2018/10/11/Project-Display/</id>
    <published>2018-10-11T05:10:11.000Z</published>
    <updated>2018-10-11T07:35:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="商城首页"><a href="#商城首页" class="headerlink" title="商城首页"></a>商城首页</h2><p><img src="http://pfuoi64aq.bkt.clouddn.com/%E9%A6%96%E9%A1%B5-%E9%A6%96%E9%A1%B5.png" width="70%" height="70%"></p><h2 id="红包雨活动"><a href="#红包雨活动" class="headerlink" title="红包雨活动"></a>红包雨活动</h2><h3 id="图1"><a href="#图1" class="headerlink" title="图1:"></a>图1:</h3><p><img src="http://pfuoi64aq.bkt.clouddn.com/WechatIMG505.jpeg" width="70%" height="70%"></p><h3 id="图2"><a href="#图2" class="headerlink" title="图2:"></a>图2:</h3><p><img src="http://pfuoi64aq.bkt.clouddn.com/WechatIMG506.jpeg" width="70%" height="70%"></p><h2 id="小程序-红包拼团"><a href="#小程序-红包拼团" class="headerlink" title="小程序 红包拼团"></a>小程序 红包拼团</h2><h3 id="图1-1"><a href="#图1-1" class="headerlink" title="图1:"></a>图1:</h3><p><img src="http://pfuoi64aq.bkt.clouddn.com/WechatIMG503.jpeg" width="40%" height="40%"></p><h3 id="图2-1"><a href="#图2-1" class="headerlink" title="图2:"></a>图2:</h3><p><img src="http://pfuoi64aq.bkt.clouddn.com/WechatIMG501.jpeg" width="40%" height="40%"></p><h3 id="图3"><a href="#图3" class="headerlink" title="图3:"></a>图3:</h3><p><img src="http://pfuoi64aq.bkt.clouddn.com/WechatIMG502.jpeg" width="40%" height="40%"></p><h3 id="图4"><a href="#图4" class="headerlink" title="图4:"></a>图4:</h3><p><img src="http://pfuoi64aq.bkt.clouddn.com/%E5%9B%BE%E7%89%87.png" alt="小程序 红包拼团"></p><h2 id="小程序-魅客分销"><a href="#小程序-魅客分销" class="headerlink" title="小程序 魅客分销"></a>小程序 魅客分销</h2><p><img src="http://pfuoi64aq.bkt.clouddn.com/IMG_2419.PNG" alt="小程序 魅客分销"></p><h2 id="前端异常监控-性能检测"><a href="#前端异常监控-性能检测" class="headerlink" title="前端异常监控 性能检测"></a>前端异常监控 性能检测</h2><h3 id="图1-2"><a href="#图1-2" class="headerlink" title="图1:"></a>图1:</h3><p><img src="http://pfuoi64aq.bkt.clouddn.com/WechatIMG499.jpeg" width="70%" height="70%"></p><h3 id="图2-2"><a href="#图2-2" class="headerlink" title="图2:"></a>图2:</h3><p><img src="http://pfuoi64aq.bkt.clouddn.com/WechatIMG500.jpeg" width="70%" height="70%"></p><h3 id="图3-1"><a href="#图3-1" class="headerlink" title="图3:"></a>图3:</h3><p><img src="http://pfuoi64aq.bkt.clouddn.com/WechatIMG498.jpeg" width="70%" height="70%"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;商城首页&quot;&gt;&lt;a href=&quot;#商城首页&quot; class=&quot;headerlink&quot; title=&quot;商城首页&quot;&gt;&lt;/a&gt;商城首页&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://pfuoi64aq.bkt.clouddn.com/%E9%A6%96%E9%A1%B5-
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>关于</title>
    <link href="http://yoursite.com/2018/10/08/about/index/"/>
    <id>http://yoursite.com/2018/10/08/about/index/</id>
    <published>2018-10-08T02:22:49.000Z</published>
    <updated>2018-10-08T02:22:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>个人详细介绍</p>]]></content>
    
    <summary type="html">
    
      个人简介
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Ajax 原理</title>
    <link href="http://yoursite.com/2018/09/30/%5BJS%5D%20Ajax%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/09/30/[JS] Ajax原理/</id>
    <published>2018-09-30T09:20:31.000Z</published>
    <updated>2018-10-08T02:21:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://jartto.wang/2015/09/01/chattered-about-ajax/" target="_blank" rel="noopener">http://jartto.wang/2015/09/01/chattered-about-ajax/</a></p><p><a href="http://jartto.wang/2015/10/01/advantage-and-disadvantages-of-Ajax/" target="_blank" rel="noopener">http://jartto.wang/2015/10/01/advantage-and-disadvantages-of-Ajax/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://jartto.wang/2015/09/01/chattered-about-ajax/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://jartto.wang/2015/09/01/chattered-abou
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Html5知识积累</title>
    <link href="http://yoursite.com/2018/09/30/%5BH5%5D%20Html5%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/"/>
    <id>http://yoursite.com/2018/09/30/[H5] Html5知识积累/</id>
    <published>2018-09-30T06:59:31.000Z</published>
    <updated>2018-10-15T03:22:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sessionStorage-和-localStorage"><a href="#sessionStorage-和-localStorage" class="headerlink" title="sessionStorage 和 localStorage"></a>sessionStorage 和 localStorage</h2><p><code>Web Storage</code>包括了两种存储方式：<code>sessionStorage</code>和<code>localStorage</code>。<br><code>sessionStorage</code>用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁，生命周期为当前窗口或标签页，一旦窗口或标签页被永久关闭了。<br>  因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。<br>  页面及标签页仅指顶级窗口，如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的。<br><code>localStorage</code>用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</p><p><code>web storage</code>和<code>cookie</code>的区别：<br>Web Storage是为了更大容量存储而设计。<br>Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。</p><p>Web Storage拥有<code>setItem</code>,<code>getItem</code>,<code>removeItem</code>,<code>clear</code>等方法，不像cookie需要开发者自己封装<code>setCookie</code>,<code>getCookie</code>。</p><p>Cookie优点：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。</p><p>html5 web storage的浏览器支持情况:<br>浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持。通过简单的代码封装可以统一到所有的浏览器都支持web storage。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.localStorage)&#123; </span><br><span class="line">  <span class="comment">// 浏览支持localStorage</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">// 浏览暂不支持localStorage</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者 </span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">window</span>.localStorage == <span class="string">'undefined'</span>)&#123;</span><br><span class="line">  <span class="comment">// 浏览暂不支持localStorage</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>setItem</code>存储value 用途，.setItem(key, value)<br><code>getItem</code>获取value 用途，.getItem(key)<br><code>removeItem</code>删除key 用途，.removeItem(key)<br><code>clear</code>清除所有的key/value 用途， .clear()<br><code>localStorage</code>和<code>sessionStorage</code>的key和length属性实现遍历: <code>sessionStorage</code>和<code>localStorage</code>提供的key()和length可以方便的实现存储的数据遍历.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.setItem(<span class="string">"key"</span>, <span class="string">"value"</span>);     </span><br><span class="line">localStorage.setItem(<span class="string">"site"</span>, <span class="string">"js8.in"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value = sessionStorage.getItem(<span class="string">"key"</span>);     </span><br><span class="line"><span class="keyword">var</span> site = localStorage.getItem(<span class="string">"site"</span>);</span><br><span class="line"></span><br><span class="line">sessionStorage.removeItem(<span class="string">"key"</span>);     </span><br><span class="line">localStorage.removeItem(<span class="string">"site"</span>);</span><br><span class="line"></span><br><span class="line">sessionStorage.clear();     </span><br><span class="line">localStorage.clear();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> storage = <span class="built_in">window</span>.localStorage; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>, len = storage.length; i &lt; len; i++)&#123;</span><br><span class="line">  <span class="keyword">var</span> key = storage.key(i); </span><br><span class="line">  <span class="keyword">var</span> value = storage.getItem(key); </span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">"="</span> + value); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="web-storage-的离线存储"><a href="#web-storage-的离线存储" class="headerlink" title="web storage 的离线存储"></a>web storage 的离线存储</h2><p>H5 的 Web storage API 采用了离线缓存，会生成一个清单文件（manifest file)，这个清单文件实质就是一系列的URL列表文件，这些URL分别指向页面当中的html,css,javascript,图片等相关内容。<br>当使用离线应用时，应用会引入这一清单文件，浏览器会读取这一文件，下载相应的文件，并将其缓存到本地。<br>使得这些web应用能够脱离网络使用，而用户在离线时的更改也同样会映射到清单文件中，并在重新连线之后将更改返回应用，工作方式与我们现在所使用的网盘有着异曲同工之处。<br>首先，需要在页面头加入manifest属性：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span> = <span class="string">"cache.manifest"</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>然后cache.manifest文件的书写方式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line">#v0.11</span><br><span class="line">CACHE:</span><br><span class="line">js/app.js</span><br><span class="line">css/style.css</span><br><span class="line">NETWORK:</span><br><span class="line">resourse/logo.png</span><br><span class="line">FALLBACK:</span><br><span class="line">/ /offline.html</span><br></pre></td></tr></table></figure></p><p>离线存储的manifest一般由三个部分组成:</p><ol><li>CACHE:表示需要离线存储的资源列表，由于包含manifest文件的页面将被自动离线存储，所以不需要把页面自身也列出来。</li><li>NETWORK:表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在CACHE和NETWORK中有一个相同的资源，那么这个资源还是会被离线存储，也就是说CACHE的优先级更高。</li><li>FALLBACK:表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问offline.html。</li></ol><p><a href="http://jartto.wang/2016/07/25/make-an-inventory-of-html5-api/" target="_blank" rel="noopener">http://jartto.wang/2016/07/25/make-an-inventory-of-html5-api/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;sessionStorage-和-localStorage&quot;&gt;&lt;a href=&quot;#sessionStorage-和-localStorage&quot; class=&quot;headerlink&quot; title=&quot;sessionStorage 和 localStorage&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="H5" scheme="http://yoursite.com/tags/H5/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://yoursite.com/2018/09/29/%5BJS%5D%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/09/29/[JS] 正则表达式/</id>
    <published>2018-09-29T08:20:42.000Z</published>
    <updated>2018-10-08T02:21:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式是匹配模式，要么匹配字符，要么匹配位置。</p><h2 id="正则表达式字符匹配攻略"><a href="#正则表达式字符匹配攻略" class="headerlink" title="正则表达式字符匹配攻略"></a>正则表达式字符匹配攻略</h2><ol><li><p>两种模糊匹配：横向模糊和纵向模糊<br>横向模糊指的是，一个正则可匹配的字符串的长度不是固定的。<br>纵向模糊指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符。</p></li><li><p>字符组<br><code>[123456abcdefGHIJKLM] 可以写成 [1-6a-fG-M]</code><br>可以写成如下的方式：<code>[-az]</code>或<code>[az-]</code>或<code>[a\-z]</code>, 即要么放在开头，要么放在结尾，要么转义</p></li></ol><p>排除字符组：例如<code>[^abc]</code>，表示是一个除”a”、”b”、”c”之外的任意一个字符。字符组的第一位放<code>^（脱字符）</code>，表示求反。</p><blockquote><ul><li><code>\d</code>就是[0-9]。表示是一位数字。记忆方式：其英文是digit（数字）</li><li><code>\D</code>就是[^0-9]。表示除数字外的任意字符。\w就是[0-9a-zA-Z_]。表示数字、大小写字母和下划线。</li><li><code>\W</code>是[^0-9a-zA-Z_]。非单词字符。记忆方式：w是word的简写，也称单词字符。</li><li><code>\s</code>是[ \t\v\n\r\f]。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。记忆方式：s是space character的首字母。</li><li><code>\S</code>是[^ \t\v\n\r\f]。 非空白符。</li><li><code>.</code>就是[^\n\r\u2028\u2029]。通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外。记忆方式：想想省略号…中的每个点，都可以理解成占位符，表示任何类似的东西。</li></ul></blockquote><ol start="3"><li>量词：</li></ol><blockquote><ul><li><code>{m,}</code> 表示至少出现m次。</li><li><code>{m}</code> 等价于{m,m}，表示出现m次。</li><li><code>?</code> 等价于{0,1}，表示出现或者不出现。记忆方式：问号的意思表示，有吗？</li><li><code>+</code> 等价于{1,}，表示出现至少一次。记忆方式：加号是追加的意思，得先有一个，然后才考虑追加。</li><li><code>*</code> 等价于{0,}，表示出现任意次，有可能不出现。记忆方式：看看天上的星星，可能一颗没有，可能零散有几颗，可能数也数不过来。</li></ul></blockquote><p><strong>贪婪匹配</strong>: 尽可能多的匹配<br><strong>惰性匹配</strong>: 尽可能少的匹配</p><ol start="4"><li><p>多选分支<br><code>(p1|p2|p3)</code>，其中p1、p2和p3是子模式，用|（管道符）分隔，表示其中任何之一。</p></li><li><p>案例</p></li></ol><ul><li style="list-style: none"><input type="checkbox" checked> 匹配时间（24小时制）：<code>/^(0?[0-9]|1[0-9]|[2][0-3]):(0?[0-9]|[1-5][0-9])$/</code></li><li style="list-style: none"><input type="checkbox" checked> 匹配日期（yyyy-mm-dd格式）： <code>/^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/</code></li><li style="list-style: none"><input type="checkbox" checked> window操作系统文件路径：<code>/^[a-zA-Z]:\\([^\\:*&lt;&gt;|&quot;?\r\n/]+\\)*([^\\:*&lt;&gt;|&quot;?\r\n/]+)?$/</code><br>eg：盘符:\文件夹\文件夹\文件夹\<br>F:\study\javascript\regex\regular expression.pdf<br>F:\study\javascript\regex\<br>F:\study\javascript<br>F:\</li></ul><p>文件名或者文件夹名，不能包含一些特殊字符，排除字符组<code>[^\\:*&lt;&gt;|&quot;?\r\n/]</code>来表示合法字符<br>路径的最后一部分可以是“文件夹”，没有\，因此需要添加<code>([^\\:*&lt;&gt;|&quot;?\r\n/]+)?</code></p><h2 id="正则表达式位置匹配攻略"><a href="#正则表达式位置匹配攻略" class="headerlink" title="正则表达式位置匹配攻略"></a>正则表达式位置匹配攻略</h2><blockquote><ul><li><code>^</code>（脱字符）匹配开头，在多行匹配中匹配行开头。</li><li><code>$</code>（美元符号）匹配结尾，在多行匹配中匹配行结尾。</li><li><code>\b</code> 是单词边界，具体就是\w和\W之间的位置，也包括\w和^之间的位置，也包括\w和$之间的位置。\w是字符组[0-9a-zA-Z_]的简写形式，</li><li><code>\B</code> 是\b的反面的意思，非单词边界</li><li><code>(?=p)</code> 其中p是一个子模式，即p前面的位置。eg：(?=l)，表示’l’字符前面的位置。（positive lookahead）</li><li><code>(?!p)</code> 是(?=p)的反面意思。（negative lookahead）</li></ul></blockquote><ol><li>案例</li></ol><ul><li style="list-style: none"><input type="checkbox" checked> 不匹配任何东西的正则: <code>/.^/</code></li><li style="list-style: none"><input type="checkbox" checked> 数字的千位分隔符表示法: “12,345,678” 正则为：<code>/(?!^)(?=(\d{3})+$)/g</code><br>“12345678  123456789” 替换成”12,345,678  123,456,789”  正则为: <code>/\B(?=(\d{3})+\b)/g</code>，其中 <code>(?!\b) 为 \B</code></li><li style="list-style: none"><input type="checkbox" checked> 必须包含数字: <code>(?=.*[0-9])</code></li><li style="list-style: none"><input type="checkbox" checked> 同时包含数字和小写字母:  <code>(?=.*[0-9])(?=.*[a-z])</code></li><li style="list-style: none"><input type="checkbox" checked> 密码长度6-12位，由数字、小写字符和大写字母组成，但必须至少包括2种字符。<br><code>/((?=.*[0-9])(?=.*[a-z])|(?=.*[0-9])(?=.*[A-Z])|(?=.*[a-z])(?=.*[A-Z]))^[0-9A-Za-z]{6,12}$/</code></li></ul><h2 id="正则表达式括号的作用"><a href="#正则表达式括号的作用" class="headerlink" title="正则表达式括号的作用"></a>正则表达式括号的作用</h2><ul><li style="list-style: none"><input type="checkbox" checked> “2017-06-12”.replace(/(\d{4})-(\d{2})-(\d{2})/, “$2/$3/$1”); // “06/12/2017”</li><li style="list-style: none"><input type="checkbox" checked> 匹配”2016-06-12”、”2016/06/12”、”2016.06.12” 正则为: <code>/\d{4}(-|\/|\.)\d{2}\1\d{2}/</code><br><strong>注意里面的\1，表示的引用之前的那个分组<code>(-|\/|\.)</code>。不管它匹配到什么（比如-），\1都匹配那个同样的具体某个字符。</strong></li></ul><ol><li>括号嵌套</li><li><p><code>\10</code>表示第10个分组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/(1)(2)(3)(4)(5)(6)(7)(8)(9)(#) \10+/</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"123456789# ######"</span></span><br><span class="line"><span class="built_in">console</span>.log( regex.test(string) );  <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure></li><li><p>引用不存在的分组<br>因为反向引用，是引用前面的分组，但我们在正则里引用了不存在的分组时，此时正则不会报错，只是匹配反向引用的字符本身。</p></li></ol><ul><li><p>[x] 字符串trim方法模拟</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trim</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> str.replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log( trim(<span class="string">"  foobar   "</span>) );   <span class="comment">// =&gt; "foobar"</span></span><br></pre></td></tr></table></figure></li><li><p>[x] 将每个单词的首字母转换为大写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">titleize</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> str.toLowerCase().replace(<span class="regexp">/(?:^|\s)\w/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> c.toUpperCase();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log( titleize(<span class="string">'my name is epeli'</span>) );  <span class="comment">// =&gt; "My Name Is Epeli"</span></span><br></pre></td></tr></table></figure></li><li><p>[x] 驼峰化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">camelize</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> str.replace(<span class="regexp">/[-_\s]+(.)?/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match, c</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> c ? c.toUpperCase() : <span class="string">''</span>;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log( camelize(<span class="string">'-moz-transform'</span>) );  <span class="comment">// =&gt; "MozTransform"</span></span><br></pre></td></tr></table></figure></li><li><p>[x] 匹配成对标签  <code>/&lt;([^&gt;]+)&gt;[\d\D]*&lt;\/\1&gt;/</code><br>开标签: <code>&lt;[^&gt;]+&gt;</code>, 闭标签: <code>&lt;\/[^&gt;]+&gt;</code><br><code>[\d\D]</code>的意思是，这个字符是数字或者不是数字，因此，也就是匹配任意字符的意思。</p></li></ul><h2 id="正则表达式回溯法原理"><a href="#正则表达式回溯法原理" class="headerlink" title="正则表达式回溯法原理"></a>正则表达式回溯法原理</h2><h2 id="正则表达式的拆分"><a href="#正则表达式的拆分" class="headerlink" title="正则表达式的拆分"></a>正则表达式的拆分</h2><h2 id="正则表达式的构建"><a href="#正则表达式的构建" class="headerlink" title="正则表达式的构建"></a>正则表达式的构建</h2><h2 id="正则表达式编程"><a href="#正则表达式编程" class="headerlink" title="正则表达式编程"></a>正则表达式编程</h2><h1 id="正则表达式的一些规则"><a href="#正则表达式的一些规则" class="headerlink" title="正则表达式的一些规则"></a>正则表达式的一些规则</h1><p>RegExp对象的方法：</p><ul><li><ul><li>test：在字符串中测试模式匹配,返回 true 或 false</li></ul></li><li><ul><li>exec：在字符串中执行匹配搜索,返回结果数组</li></ul></li><li><ul><li>match(pattern)：返回 pattern 中的子串或 null</li></ul></li><li><ul><li>replace(pattern, replacement)：用 replacement 替换 pattern</li></ul></li><li><ul><li>search(pattern)：返回字符串中 pattern 开始位置</li></ul></li><li><ul><li>split(pattern)：返回字符串按指定 pattern 拆分的数组</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;正则表达式是匹配模式，要么匹配字符，要么匹配位置。&lt;/p&gt;
&lt;h2 id=&quot;正则表达式字符匹配攻略&quot;&gt;&lt;a href=&quot;#正则表达式字符匹配攻略&quot; class=&quot;headerlink&quot; title=&quot;正则表达式字符匹配攻略&quot;&gt;&lt;/a&gt;正则表达式字符匹配攻略&lt;/h2&gt;&lt;ol&gt;
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>webpack 优化项目策略</title>
    <link href="http://yoursite.com/2018/09/29/%5B%E6%9E%84%E5%BB%BA%5D%20webpack%E4%BC%98%E5%8C%96%E9%A1%B9%E7%9B%AE/"/>
    <id>http://yoursite.com/2018/09/29/[构建] webpack优化项目/</id>
    <published>2018-09-29T02:20:51.000Z</published>
    <updated>2018-10-15T09:06:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>DllReferencePlugin</code>: 将打包好的dll文件传入构建的代码里面<br><code>AddAssetHtmlPlugin</code>: 在生成的html文件中加入dll文件的script引用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;DllReferencePlugin&lt;/code&gt;: 将打包好的dll文件传入构建的代码里面&lt;br&gt;&lt;code&gt;AddAssetHtmlPlugin&lt;/code&gt;: 在生成的html文件中加入dll文件的script引用&lt;/p&gt;

      
    
    </summary>
    
      <category term="构建" scheme="http://yoursite.com/categories/%E6%9E%84%E5%BB%BA/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>parceljs &amp; webpack</title>
    <link href="http://yoursite.com/2018/09/28/%5B%E6%9E%84%E5%BB%BA%5D%20parceljs%20&amp;%20webpack/"/>
    <id>http://yoursite.com/2018/09/28/[构建] parceljs &amp; webpack/</id>
    <published>2018-09-28T06:29:31.000Z</published>
    <updated>2018-10-08T02:21:31.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="构建" scheme="http://yoursite.com/categories/%E6%9E%84%E5%BB%BA/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化</title>
    <link href="http://yoursite.com/2018/09/28/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    <id>http://yoursite.com/2018/09/28/前端工程化/</id>
    <published>2018-09-28T06:29:31.000Z</published>
    <updated>2018-10-08T02:21:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>前端工程化：开发需求、共享需求、性能需求、部署需求。为了简化前端工程化的配置，出现了很多优秀的工具比如：<br>1、前端工作流工具：Gulp，Grunt，Broccoli<br>2、前端 JS 模块编译工具：Babel，Browserify，Webpack<br>3、前端开发系列工具： livereload，数据 mock，代码监控，代码检查</p><h2 id="开发需求"><a href="#开发需求" class="headerlink" title="开发需求"></a>开发需求</h2><p>在开始一个前端项目时，通常需要进行技术选型，定义代码规范以及配合后端和业务进行项目的目录规划</p><ol><li>代码规范：jslint、SASSLint、ESLint/TSLint….</li><li>JS 预处理：（编译过程）</li></ol><ul><li>编程语言：Coffeescript、Livescript、Typescript、React Jsx、Dart、Elm….</li><li>ES6</li><li>CommonJS</li></ul><p>Typescript 中提供静态语法的一些强类型特性。<br>Coffeescript, Livescript 提供现代化语言的语法糖特性，专门针对 xml 优化的 JSX。</p><ol start="3"><li><p>CSS 预处理：less、sass…<br>预处理工具：Autoprefixer、Compass</p></li><li><p>文件处理： src 放置源码，dist 放置编译后的代码</p></li><li>开发效率：webpack的Hot Module Replacement， livereload 自动刷新浏览器</li><li>数据 mock：可构建mock平台</li><li>域名代理</li></ol><h2 id="共享需求"><a href="#共享需求" class="headerlink" title="共享需求"></a>共享需求</h2><p>设计前端项目架构时，一定要考虑业务的组件化和可共享性：</p><ul><li>Base 基础代码共享</li><li>通用工具方法共享</li><li>基础交互组件共享</li><li>业务组件共享</li></ul><h2 id="性能需求"><a href="#性能需求" class="headerlink" title="性能需求"></a>性能需求</h2><p>优化源码的体积是提升首屏加载时间的关键：</p><ol><li>Javascript, Css 代码压缩</li><li>Javascript, Css 代码合并</li><li>图片压缩</li><li>Css 图片精灵或雪碧图（css sprit）</li></ol><p>可以在前端工程的 build 过程中实现。</p><h2 id="部署需求"><a href="#部署需求" class="headerlink" title="部署需求"></a>部署需求</h2><ol><li>多人分支协作流程：用 git flow 来管理代码分支</li><li>代码自动发布：git hookgit hook实现代码自动部署</li></ol><h2 id="前端工作流工具"><a href="#前端工作流工具" class="headerlink" title="前端工作流工具"></a>前端工作流工具</h2><ol><li>Grunt: 基于配置的工作流模式，定义一个配置文件，声明工作流各个环节的相关配置，调用 grunt 就能完成打包编译.</li><li>Broccoli: 以 tree 的基础结构，提供极其高效稳定的工作流。</li><li>Gulp: 基于内存的流的方式，提供高效的性能，极简的 API，定义不同的 task，然后将 task 串联起来。</li></ol><h2 id="前端-Javascript-编译工具"><a href="#前端-Javascript-编译工具" class="headerlink" title="前端 Javascript 编译工具"></a>前端 Javascript 编译工具</h2><ol><li>Babel</li><li>Browserify: 是最先出现的 CommonJs 编译工具，使得我们可以像写 Node 模块一样写前端代码，Browserify 可以 build 使用 npm 中的所有模块。</li><li>Webpack: 是支持 CommonJs 和 AMD 的模块编译工具，逐渐替代 Browserify, 基于 AMD 的好处就是代码可以异步话，这是 Browserify 无法做到的。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前端工程化：开发需求、共享需求、性能需求、部署需求。为了简化前端工程化的配置，出现了很多优秀的工具比如：&lt;br&gt;1、前端工作流工具：Gulp，Grunt，Broccoli&lt;br&gt;2、前端 JS 模块编译工具：Babel，Browserify，Webpack&lt;br&gt;3、前端开
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>webpack进阶</title>
    <link href="http://yoursite.com/2018/09/28/%5B%E6%9E%84%E5%BB%BA%5D%20webpack%E8%BF%9B%E9%98%B6/"/>
    <id>http://yoursite.com/2018/09/28/[构建] webpack进阶/</id>
    <published>2018-09-28T06:09:21.000Z</published>
    <updated>2018-10-08T02:21:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置分离"><a href="#配置分离" class="headerlink" title="配置分离"></a>配置分离</h2><p>在大型项目中，webpack.config.js 会变得越来越臃肿，因此可以利用 webpack-merge 插件。将配置定义在一个目录下面的不同文件中，然后通过 webpack-merge 来合并成最终的配置。</p><h2 id="code-splitting-异步加载"><a href="#code-splitting-异步加载" class="headerlink" title="code splitting 异步加载"></a>code splitting 异步加载</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;配置分离&quot;&gt;&lt;a href=&quot;#配置分离&quot; class=&quot;headerlink&quot; title=&quot;配置分离&quot;&gt;&lt;/a&gt;配置分离&lt;/h2&gt;&lt;p&gt;在大型项目中，webpack.config.js 会变得越来越臃肿，因此可以利用 webpack-merge 插件。将配置定
      
    
    </summary>
    
      <category term="构建" scheme="http://yoursite.com/categories/%E6%9E%84%E5%BB%BA/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack 入门</title>
    <link href="http://yoursite.com/2018/09/28/%5B%E6%9E%84%E5%BB%BA%5D%20webpack%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2018/09/28/[构建] webpack入门/</id>
    <published>2018-09-28T03:42:48.000Z</published>
    <updated>2018-10-08T02:21:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="论述"><a href="#论述" class="headerlink" title="论述"></a>论述</h2><p><code>CommonJS</code> 是一种使用广泛的 JavaScript 模块化规范，核心思想是通过 require 方法来同步地加载依赖的其他模块，通过 module.exports 导出需要暴露的接口。<br><code>CommonJS</code> 的优点在于：</p><ul><li>代码可复用于 Node.js 环境下并运行，例如做同构应用；</li><li>通过 NPM 发布的很多第三方模块都采用了 CommonJS 规范。<br><code>CommonJS</code> 的缺点在于这样的代码无法直接运行在浏览器环境下，必须通过工具转换成标准的 ES5。</li></ul><p><code>AMD</code> 也是一种 JavaScript 模块化规范，与 CommonJS 最大的不同在于它采用异步的方式去加载依赖的模块。 AMD 规范主要是为了解决针对浏览器环境的模块化问题，最具代表性的实现是 requirejs。<br><code>AMD</code> 的优点在于：</p><ul><li>可在不转换代码的情况下直接在浏览器中运行；</li><li>可异步加载依赖；</li><li>可并行加载多个依赖；</li><li>代码可运行在浏览器环境和 Node.js 环境下。<br><code>AMD</code> 的缺点在于JavaScript 运行环境没有原生支持 AMD，需要先导入实现了 AMD 的库后才能正常使用。</li></ul><p><code>TypeScript</code> 的缺点在于语法相对于 JavaScript 更加啰嗦，并且无法直接运行在浏览器或 Node.js 环境下。<br><code>Flow</code> 也是 JavaScript 的一个超集，它的主要特点是为 JavaScript 提供静态类型检查，和 TypeScript 相似但更灵活，可以让你只在需要的地方加上类型检查。</p><h2 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h2><p>构建就是做这件事情，把源代码转换成发布到线上的可执行 JavaScrip、CSS、HTML 代码，包括如下内容。</p><ul><li>代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等。</li><li>文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。</li><li>代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。</li><li>模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。</li><li>自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。</li><li>代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。</li><li>自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。</li></ul><p><a href="http://www.xbhub.com/wiki/webpack/1%E5%85%A5%E9%97%A8/1-2%E5%B8%B8%E8%A7%81%E7%9A%84%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%AF%B9%E6%AF%94.html" target="_blank" rel="noopener">http://www.xbhub.com/wiki/webpack/1%E5%85%A5%E9%97%A8/1-2%E5%B8%B8%E8%A7%81%E7%9A%84%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%AF%B9%E6%AF%94.html</a></p><h2 id="webpack配置"><a href="#webpack配置" class="headerlink" title="webpack配置"></a>webpack配置</h2><p>webpack官方提供的配置方法是通过module.exports返回一个json，但是这种场景不灵活，不能适配多种场景。<br>最佳方式：<br>1、两份配置文件webpack.config.production.js/webpack.config.development.js，然后不同场景下，使用不同的配置文件。<br>2、通过module.exports返回函数，该函数能接受参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">env</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    context: config.context,</span><br><span class="line">    entry: config.src,</span><br><span class="line">    output: &#123;</span><br><span class="line">      path: path.join(config.jsDest, project),</span><br><span class="line">      filename: <span class="string">'[name].js'</span>,</span><br><span class="line">      chunkFilename: <span class="string">'[name].[chunkhash:8].js'</span>,</span><br><span class="line">      publicPath: <span class="string">'/assets/'</span> + project + <span class="string">'/'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    devtool: <span class="string">"eval"</span>,</span><br><span class="line">    watch: <span class="literal">false</span>,</span><br><span class="line">    profile: <span class="literal">true</span>,</span><br><span class="line">    cache: <span class="literal">true</span>,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">      loaders: getLoaders(env)</span><br><span class="line">    &#125;,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">      alias: getAlias(env)</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: getPlugins(env)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>context</code>：上下文。<br><code>entry</code>：入口文件，是所有依赖关系的入口，webpack从这个入口开始静态解析，分析模块之间的依赖关系。<br><code>output</code>：打包输出的配置。<br><code>devtools</code>：SourceMap选项，便于开发模式下调试。<br><code>watch</code>：监听模式，增量更新，开发必备！<br><code>profile</code>：优化。<br><code>cache</code>：webpack构建的过程中会生成很多临时的文件，打开cache可以让这些临时的文件缓存起来，从而更快的构建。<br><code>module.loaders</code>：loaders用来对文件做预处理。这样webpack就可以打包任何静态文件。<br><code>resolve.alias</code>：模块别名，这样可以更方便的引用模块。<br><code>plugins</code>：webpack的一些内置功能均是以插件的形式提供。</p><h2 id="webpack-使用"><a href="#webpack-使用" class="headerlink" title="webpack 使用"></a>webpack 使用</h2><h4 id="1、命令行调用"><a href="#1、命令行调用" class="headerlink" title="1、命令行调用"></a>1、命令行调用</h4><p>webpack可以在终端中使用：</p><ul><li>{extry file}填写入口文件的路径</li><li>{destination for bundled file}处填写打包文件的存放路径</li><li>填写路径的时候不用添加{}<br><code>webpack {entry file}  {destination for bundled file}</code>  （全局模式）<br><code>node_modules/.bin/webpack  app/main.js  public/bundle.js</code> （非全局安装的情况）</li></ul><h4 id="2、入口与输出"><a href="#2、入口与输出" class="headerlink" title="2、入口与输出"></a>2、入口与输出</h4><p>模板<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  entry: [<span class="built_in">String</span> | <span class="built_in">Array</span> | <span class="built_in">Object</span>], <span class="comment">// 入口模块</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: <span class="built_in">String</span>,                   <span class="comment">// 输出路径</span></span><br><span class="line">    filename: <span class="built_in">String</span>                <span class="comment">// 输出名称或名称 pattern</span></span><br><span class="line">    publicPath: <span class="built_in">String</span>              <span class="comment">// 指定静态资源的位置</span></span><br><span class="line">    ...                             <span class="comment">// 其他配置</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li><p>多个入口文件：eg: <code>entry: [&#39;./src/index.js&#39;, &#39;./vendor/bootstrap.min.js&#39;]</code><br>最终 bootstrap 会被追加到打包好的 index.js 中，数组中的最后一个会被 export。</p></li><li><p>多个打包目标</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    a: <span class="string">'./src/a.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: <span class="string">'./dist/'</span>,</span><br><span class="line">    filename: <span class="string">'[name].js'</span> </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="3、生成Source-Maps（使调试更容易）——-devtool"><a href="#3、生成Source-Maps（使调试更容易）——-devtool" class="headerlink" title="3、生成Source Maps（使调试更容易）——  devtool"></a>3、生成Source Maps（使调试更容易）——  devtool</h4><p>webpack就可以在打包时为我们生成的source maps，提供了一种对应编译文件和源文件的方法，使得编译后的代码可读性更高，也更容易调试。<br>在webpack的配置文件中配置source maps，需要配置devtool，有四种不同的配置选项：</p><ul><li><code>source-map</code>：在一个单独的文件中产生一个完整且功能完全的文件，但它会减慢打包速度</li><li><code>cheap-module-source-map</code>：在一个单独的文件中生成一个不带列映射的map，不带列映射提高了打包速度，但不能对应到具体的列（符号），会对调试造成不便；</li><li><code>eval-source-map</code>：使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。其可以在不影响构建速度的前提下生成完整的sourcemap，但对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定不要启用这个选项；</li><li><code>cheap-module-eval-source-map</code>：在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点。（cheap-module-eval-source-map方法构建速度更快，但是不利于调试，推荐在大型项目考虑时间成本时使用。）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: __dirname + <span class="string">'/app/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + <span class="string">'/public'</span>,</span><br><span class="line">    filename: <span class="string">'bundle-[hash:7].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: <span class="string">'eval-source-map'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、使用webpack构建本地服务器（webpack-dev-server）——-devServer"><a href="#4、使用webpack构建本地服务器（webpack-dev-server）——-devServer" class="headerlink" title="4、使用webpack构建本地服务器（webpack-dev-server）—— devServer"></a>4、使用webpack构建本地服务器（webpack-dev-server）—— devServer</h4><p>背景：浏览器监听代码的修改，并自动刷新显示修改后的结果<br>Webpack提供一个可选的本地开发服务器，该本地服务器基于node.js构建<br>先安装：npm install –save-dev webpack-dev-server<br>再配置: devserver</p><ul><li><code>contentBase</code>：默认webpack-dev-server会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录</li><li><code>port</code>：设置默认监听端口，默认“8080”；</li><li><code>inline</code>：设置为true，当源文件改变时会自动刷新页面；</li><li><code>historyApiFallback</code>：若设置true，所有的跳转将指向index.html，在单页应用时有用，它依赖于HTML5 history API</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: __dirname + <span class="string">'/app/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + <span class="string">'/public'</span>,</span><br><span class="line">    filename: <span class="string">'bundle-[hash:7].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: <span class="string">'eval-source-map'</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./public'</span>,    <span class="comment">// 本地服务器所加载的页面所在的目录</span></span><br><span class="line">    historyApiFallback: <span class="literal">true</span>,   <span class="comment">// 不跳转</span></span><br><span class="line">    inline: <span class="literal">true</span>                <span class="comment">// 实时刷新</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、loader"><a href="#5、loader" class="headerlink" title="5、loader"></a>5、loader</h4><p>使用不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理<br>在 webpack 中，通过 loader 可以实现 JSX 、Es6、CoffeeScript 等的转换.</p><ul><li>分析转换scss为css</li><li>把下一代的JS文件（ES6，ES7)转换为现代浏览器兼容的JS文件</li><li>把React的中用到的JSX文件转换为JS文件</li><li>……<br>Loader需要单独安装，并在config.js 中的 modules关键字中进行配置<br>Loader 的配置说明：</li><li><code>test</code>：一个用以匹配loaders所处理文件的拓展名的正则表达式（必须）</li><li><code>loader</code>：loader的名称（必须）</li><li><code>include/exclude</code>:手动添加必须处理的文件/文件夹或屏蔽不需要处理的文件/文件夹（可选）</li><li><code>query</code>：为loaders提供额外的设置选项（可选）</li></ul><p><strong>loader 除了做文件转换以外，还可以创建额外的文件</strong><br>语法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 通过扩展名称和正则表达式来匹配资源文件</span></span><br><span class="line">  test: <span class="built_in">String</span> ,          </span><br><span class="line">  <span class="comment">// 匹配到的资源会应用 loader， loader 可以为 string 也可以为数组</span></span><br><span class="line">  loader: <span class="built_in">String</span> | <span class="built_in">Array</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="6、Babel"><a href="#6、Babel" class="headerlink" title="6、Babel"></a>6、Babel</h4><p>作用：是一个编译JavaScript的平台：</p><ul><li>使用下一代的JavaScript代码（ES6，ES7…），即使这些标准目前并未被当前的浏览器完全的支持；</li><li>使用基于JavaScript进行了拓展的语言，比如React的JSX；<br>安装：<code>npm install --save-dev  babel-core  babel-loader  babel-preset-es2015  babel-preset-react</code><br>Babel其实是几个模块化的包，其核心功能位于称为<code>babel-core</code>的npm包中，webpack可以把其不同的包整合在一起使用，对于每一个需要的功能或拓展，你都需要安装单独的包（用得最多的是解析ES6的<code>babel-preset-es2015</code>包和解析JSX的<code>babel-preset-react</code>包）。</li></ul><h4 id="7、Babel的配置"><a href="#7、Babel的配置" class="headerlink" title="7、Babel的配置"></a>7、Babel的配置</h4><p>Babel 可以完全在<code>webpack.config.js</code>中进行配置，但复杂度增加时会单独有<code>.babelrc</code>的配置文件<br>webpack会自动调用<code>.babelrc</code>里的babel配置选项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: __dirname + <span class="string">'/app/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + <span class="string">'/public'</span>,</span><br><span class="line">    filename: <span class="string">'bundle-[hash:7].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: <span class="string">'eval-source-map'</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./public'</span>,    <span class="comment">// 本地服务器所加载的页面所在的目录</span></span><br><span class="line">    historyApiFallback: <span class="literal">true</span>,   <span class="comment">// 不跳转</span></span><br><span class="line">    inline: <span class="literal">true</span>                <span class="comment">// 实时刷新</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="regexp">/(\.jsx|\.js)/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      exclude: <span class="regexp">/node-module/</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .babelrc</span></span><br><span class="line">&#123;</span><br><span class="line">  persets: [<span class="string">'es2015'</span>, <span class="string">'react'</span>, <span class="string">'stage-0'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8、CSS-module"><a href="#8、CSS-module" class="headerlink" title="8、CSS module"></a>8、CSS module</h4><p>CSS modules 的技术：把JS的模块化思想带入CSS中来，通过CSS模块，所有的类名，动画名默认都只作用于当前模块。<br>Webpack从一开始就对CSS模块化提供了支持，在CSS loader中进行配置后。<br>首先把”modules“传递到所需要的地方<br>然后就可以直接把CSS的类名传递到组件的代码中<br>好处：这样做只对当前组件有效，不必担心在不同的模块中使用相同的类名造成冲突。</p><h4 id="9、CSS预处理器—PostCSS-autoprefixer"><a href="#9、CSS预处理器—PostCSS-autoprefixer" class="headerlink" title="9、CSS预处理器—PostCSS / autoprefixer"></a>9、CSS预处理器—PostCSS / autoprefixer</h4><p><code>Sass</code> 和 <code>Less</code> 之类的预处理器是对原生CSS的拓展，它们允许使用类似于variables, nesting, mixins, inheritance等不存在于CSS中的特性来写CSS。<br>在webpack里使用loader进行配置：<code>Less Loader、Sass Loader、Stylus Loader</code><br>但存在一个CSS的处理平台—— <code>PostCSS（https://github.com/postcss/postcss/blob/master/README.cn.md）</code><br>PostCSS 是一个允许使用 JS 插件转换样式的工具。 这些插件可以检查（lint）你的 CSS，支持 CSS Variables 和 Mixins， 编译尚未被浏览器广泛支持的先进的 CSS 语法，内联图片，以及其它很多优秀的功能</p><p>首先安装postcss-loader 和 autoprefixer（自动添加前缀的插件）, css会自动根据Can I Use里的数据添加不同前缀。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: __dirname + <span class="string">'/app/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + <span class="string">'/public'</span>,</span><br><span class="line">    filename: <span class="string">'bundle-[hash:7].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: <span class="string">'eval-source-map'</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./public'</span>,    <span class="comment">// 本地服务器所加载的页面所在的目录</span></span><br><span class="line">    historyApiFallback: <span class="literal">true</span>,   <span class="comment">// 不跳转</span></span><br><span class="line">    inline: <span class="literal">true</span>                <span class="comment">// 实时刷新</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="regexp">/(\.jsx|\.js)/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      exclude: <span class="regexp">/node-module/</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      use: [&#123;</span><br><span class="line">        loader: <span class="string">'style-loader'</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        loader: <span class="string">'css-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          modules: &#123;</span><br><span class="line">            modules: <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        loader: <span class="string">'postcss-loader'</span></span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// postcss.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10、插件（Plugins）—-banner-plugins-HtmlWebpackPlugin-Hot-Module-Replacement"><a href="#10、插件（Plugins）—-banner-plugins-HtmlWebpackPlugin-Hot-Module-Replacement" class="headerlink" title="10、插件（Plugins）— banner-plugins / HtmlWebpackPlugin / Hot Module Replacement"></a>10、插件（Plugins）— banner-plugins / HtmlWebpackPlugin / Hot Module Replacement</h4><p>插件（Plugins）是用来拓展Webpack功能，会在整个构建过程中生效，执行相关的任务。<br>loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，<br>插件并不直接操作单个文件，它直接对整个构建过程其作用。</p><h5 id="1-banner-plugins-添加版权声明"><a href="#1-banner-plugins-添加版权声明" class="headerlink" title="1.banner-plugins: 添加版权声明"></a>1.banner-plugins: 添加版权声明</h5><h5 id="2-HtmlWebpackPlugin（动态生成入口-html）"><a href="#2-HtmlWebpackPlugin（动态生成入口-html）" class="headerlink" title="2.HtmlWebpackPlugin（动态生成入口 html）"></a>2.HtmlWebpackPlugin（动态生成入口 html）</h5><p>依据一个简单的index.html模板，生成一个自动引用你打包后的JS文件的新index.html<br>安装： npm install –save-dev html-webpack-plugin</p><ul><li>移除public文件夹，利用插件自动生成index.html</li><li>app目录中，创建index.tmpl.html文件模板。插件会依据此模板生成最终的html页面，会自动添加所依赖的 css, js，favicon等文件。</li><li>更新webpack配置。</li></ul><h5 id="3-Hot-Module-Replacement-允许修改组件代码后，自动刷新实时预览修改后的效果。"><a href="#3-Hot-Module-Replacement-允许修改组件代码后，自动刷新实时预览修改后的效果。" class="headerlink" title="3.Hot Module Replacement: 允许修改组件代码后，自动刷新实时预览修改后的效果。"></a>3.Hot Module Replacement: 允许修改组件代码后，自动刷新实时预览修改后的效果。</h5><p>Hot Module Replacement（HMR）允许修改组件代码后，自动刷新实时预览修改后的效果。<br>配置：<br>1、在webpack配置文件中添加HMR插件；<br>2、在Webpack Dev Server中添加“hot”参数；<br>不过配置完后，JS模块其实还是不能自动热加载的，还需要在JS模块中执行一个Webpack提供的API才能实现热加载。<br>虽然这个API不难使用，但是如果是React模块，使用Babel可以更方便的实现功能热加载。<br>思路：</p><ul><li>Babel和webpack是独立的工具</li><li>二者可以一起工作</li><li>二者都可以通过插件拓展功能</li><li>HMR是一个webpack插件，它能在浏览器中实时观察模块修改后的效果，但如果想让它工作，需要对模块进行额外的配置；</li><li>Babel有一个叫做react-transform-hrm的插件，可以在不对React模块进行额外的配置的前提下让HMR正常工作；</li></ul><h4 id="11、优化插件"><a href="#11、优化插件" class="headerlink" title="11、优化插件"></a>11、优化插件</h4><ul><li><code>OccurenceOrderPlugin</code>:为组件分配ID，通过这个插件webpack可以分析和优先考虑使用最多的模块，并为它们分配最小的ID（内置插件）</li><li><code>UglifyJsPlugin</code>：压缩JS代码；（内置插件）</li><li><code>ExtractTextPlugin</code>：分离CSS和JS文件<br>安装ExtractTextPlugin：<code>npm install --save-dev extract-text-webpack-plugin</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: __dirname + <span class="string">'/app/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + <span class="string">'/public'</span>,</span><br><span class="line">    filename: <span class="string">'bundle-[hash:7].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: <span class="string">'eval-source-map'</span>,</span><br><span class="line">  devServer: &#123;&#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;&#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.BannerPlugins(<span class="string">'版权所有，翻版必究'</span>),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: __dirname + <span class="string">'/app/index.tmpl.html'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),   <span class="comment">// 热加载插件</span></span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.OccurenceOrderPlugin,</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin,</span><br><span class="line">    <span class="keyword">new</span> ExtractTextPlugin(<span class="string">'style.css'</span>)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .babelrc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">'persets'</span>: [<span class="string">'react'</span>, <span class="string">'es2015'</span>, <span class="string">'stage-0'</span>]</span><br><span class="line">  <span class="string">'env'</span>: &#123;</span><br><span class="line">    <span class="string">'devlopment'</span>: &#123;</span><br><span class="line">      <span class="string">'plugins'</span>: [[<span class="string">'react-transform'</span>, &#123;</span><br><span class="line">        transform: [&#123;</span><br><span class="line">          transform:: <span class="string">'react-transform-hmr'</span>,</span><br><span class="line">          imports: [<span class="string">'react'</span>],</span><br><span class="line">          locals: [<span class="string">'module'</span>]</span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;]]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package.json </span></span><br><span class="line"><span class="string">'script'</span>: &#123;</span><br><span class="line">  <span class="string">"test"</span><span class="string">': "echo \"Error: no test specified\" &amp;&amp; exit 1",</span></span><br><span class="line"><span class="string">  "start": "webpack",</span></span><br><span class="line"><span class="string">  "server": "webpack-dev-server --open",</span></span><br><span class="line"><span class="string">  "build": "NODE_ENV=production webpack --config ./webpack.config.js --progress"</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>HtmlWebpackPlugin 参数说明：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">  template: __dirname + <span class="string">'/app/index.tmpl.html'</span>,</span><br><span class="line">  title: <span class="string">'Test'</span>,</span><br><span class="line">  filename: <span class="string">'index.html'</span>,</span><br><span class="line">  inject: <span class="string">'body'</span>,</span><br><span class="line">  favicon: <span class="string">'./images/favico.ico'</span>,</span><br><span class="line">  minify: <span class="literal">true</span>,</span><br><span class="line">  hash: <span class="literal">true</span>,</span><br><span class="line">  cache: <span class="literal">false</span>,</span><br><span class="line">  showErrors: <span class="literal">false</span>,</span><br><span class="line">  xhtml: <span class="literal">false</span>,</span><br><span class="line">  chunks: &#123;</span><br><span class="line">    head: &#123;</span><br><span class="line">      entry: <span class="string">'assets/head_bundle.js'</span>,</span><br><span class="line">      css: [<span class="string">'main.css'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure></p><ul><li>title: 设置title的名字   </li><li>filename: 设置这个html的文件名   </li><li>template:要使用的模块的路径  </li><li>inject: 把模板注入到哪个标签后， ‘body’,</li><li>favicon: 给html添加一个favicon，  ‘./images/favico.ico’,</li><li>minify:是否压缩  {…} | false （最新api变动，原来是ture|false)</li><li>hash:是否hash化 true，false ,     </li><li>cache:是否缓存, </li><li>showErrors:是否显示错误,  </li><li>xhtml:是否自动毕业标签 默认false </li></ul><h4 id="12、缓存"><a href="#12、缓存" class="headerlink" title="12、缓存"></a>12、缓存</h4><p>缓存无处不在，使用缓存的最好方法是保证你的文件名和文件内容是匹配的（内容改变，名称相应改变）<br>解决办法：带hash值</p><p>参考资料： <a href="http://www.xbhub.com/wiki/webpack" target="_blank" rel="noopener">http://www.xbhub.com/wiki/webpack</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;论述&quot;&gt;&lt;a href=&quot;#论述&quot; class=&quot;headerlink&quot; title=&quot;论述&quot;&gt;&lt;/a&gt;论述&lt;/h2&gt;&lt;p&gt;&lt;code&gt;CommonJS&lt;/code&gt; 是一种使用广泛的 JavaScript 模块化规范，核心思想是通过 require 方法来同步地
      
    
    </summary>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Object 创建/修改/获取属性的方法</title>
    <link href="http://yoursite.com/2018/09/26/%5BJS%5D%20%E5%88%9B%E5%BB%BA%E3%80%81%E4%BF%AE%E6%94%B9%E3%80%81%E8%8E%B7%E5%8F%96%E5%B1%9E%E6%80%A7%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/09/26/[JS] 创建、修改、获取属性的方法/</id>
    <published>2018-09-26T10:08:12.000Z</published>
    <updated>2018-10-08T02:21:39.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Object-defineProperty-obj-prop-descriptor"><a href="#Object-defineProperty-obj-prop-descriptor" class="headerlink" title="Object.defineProperty(obj, prop, descriptor)"></a>Object.defineProperty(obj, prop, descriptor)</h3><p>会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。<br>若不指定configurable, writable, enumerable ，则这些属性默认值为false；<br>若不指定value, get, set，则这些属性默认值为undefined。</p><ul><li>obj: 需要被操作的目标对象</li><li>prop: 目标对象需要定义或修改的属性的名称</li><li>descriptor: 将被定义或修改的属性的描述符</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    value: <span class="string">'张三'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj.name)  <span class="comment">//张三</span></span><br></pre></td></tr></table></figure><h3 id="Object-defineProperties-obj-props"><a href="#Object-defineProperties-obj-props" class="headerlink" title="Object.defineProperties(obj, props)"></a>Object.defineProperties(obj, props)</h3><p>直接在一个对象上定义一个或多个新的属性或修改现有属性，并返回该对象。</p><ul><li>props: 该对象的一个或多个键值对定义了将要为对象添加或修改的属性的具体配置。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(obj, &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        value: <span class="string">'张三'</span>,</span><br><span class="line">        configurable: <span class="literal">false</span>,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        enumerable: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    age: &#123;</span><br><span class="line">        value: <span class="number">18</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj.name, obj.age) <span class="comment">// 张三, 18</span></span><br></pre></td></tr></table></figure><p>在不支持 Object.defineProperties() 方法的浏览器中不能修改[[configurable]]和[[enumerable]]。</p><h3 id="Object-getOwnPropertyDescriptor-obj-prop"><a href="#Object-getOwnPropertyDescriptor-obj-prop" class="headerlink" title="Object.getOwnPropertyDescriptor(obj, prop)"></a>Object.getOwnPropertyDescriptor(obj, prop)</h3><p>返回指定对象上一个自有属性对应的属性描述符。</p><ul><li>prop: 目标对象内属性名称。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'张三'</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">'name'</span>); </span><br><span class="line"><span class="built_in">console</span>.log(desc);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     configurable: true,</span></span><br><span class="line"><span class="comment">//     enumerable: true,</span></span><br><span class="line"><span class="comment">//     writable: true,</span></span><br><span class="line"><span class="comment">//     value: "张三"</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h3 id="Object-getOwnPropertyDescriptors-obj-prop"><a href="#Object-getOwnPropertyDescriptors-obj-prop" class="headerlink" title="Object.getOwnPropertyDescriptors(obj, prop)"></a>Object.getOwnPropertyDescriptors(obj, prop)</h3><p>所指定对象的所有自身属性的描述符，如果没有任何自身属性，则返回空对象。<br>返回值是一个对象，若是访问器属性，该对象有Configurable、Enumberable、Get和set；<br>若是数据属性，该对象有Configurable、Enumberable、Writable和Value；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</span><br><span class="line">    _year: &#123;</span><br><span class="line">        value: <span class="number">2004</span></span><br><span class="line">    &#125;,</span><br><span class="line">    edition: &#123;</span><br><span class="line">        value: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    year: &#123;</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>._year = newValue;</span><br><span class="line">                <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> descriptor =  <span class="built_in">Object</span>.getOwnPropertyDescriptors(book, <span class="string">'_year'</span>);</span><br><span class="line">descriptor.value;               <span class="comment">// 2004</span></span><br><span class="line">descriptor.configurable;        <span class="comment">// false</span></span><br><span class="line"><span class="keyword">typeof</span> descriptor.get;          <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptors(book, <span class="string">'year'</span>);</span><br><span class="line">descriptor.value;               <span class="comment">// undefined</span></span><br><span class="line">descriptor.enumberable;         <span class="comment">// false</span></span><br><span class="line"><span class="keyword">typeof</span> descriptor.get;          <span class="comment">// function</span></span><br></pre></td></tr></table></figure><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p>在调用 Object.defineProperty() 方法时，如果不指定，configrubale、enumerable和writable 默认都为false。</p><h4 id="configrubale"><a href="#configrubale" class="headerlink" title="configrubale"></a>configrubale</h4><p>设置configrubale属性为false，则不可使用delete操作符(在严格模式下抛出错误), 修改所有内部属性值会抛出错误。</p><h4 id="enumerable"><a href="#enumerable" class="headerlink" title="enumerable"></a>enumerable</h4><h4 id="writable"><a href="#writable" class="headerlink" title="writable"></a>writable</h4><h4 id="get-和-set"><a href="#get-和-set" class="headerlink" title="get 和 set"></a>get 和 set</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Object-defineProperty-obj-prop-descriptor&quot;&gt;&lt;a href=&quot;#Object-defineProperty-obj-prop-descriptor&quot; class=&quot;headerlink&quot; title=&quot;Object.def
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>JS高级程序设计</title>
    <link href="http://yoursite.com/2018/09/26/%5BJS%5D%20JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2018/09/26/[JS] JS高级程序设计/</id>
    <published>2018-09-26T06:48:21.000Z</published>
    <updated>2018-10-08T02:21:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h2><p><a href="#chap5、引用类型">chap5、引用类型</a><br><a href="#chap6、面向对象">chap6、面向对象</a></p><h3 id="chap5、引用类型"><a href="#chap5、引用类型" class="headerlink" title="chap5、引用类型"></a>chap5、引用类型</h3><p>引用类型是一种数据结构，用于将数据和功能组织在一起。</p><ol><li><p>Object类型<br>可以使用.点和[]进行访问对象属性，没有任何去边，但方括号的主要优点：可以通过变量来访问属性。<br>若属性名中包含关键字或保留字或导致语法错误的字符，可以使用方括号表示法。<br><strong>除非必须使用变量来访问属性，否则建议使用点表示法</strong></p></li><li><p>Array类型<br>Array构造函数时可以省略new操作符，const color = new Array(3); const color = Array(3);<br>数组的length并不是只读的，可以被设置。</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> color = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</span><br><span class="line">color.length = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(color[<span class="number">2</span>]);  <span class="comment">// undefined，会被删除</span></span><br><span class="line"></span><br><span class="line">color.length = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(color[<span class="number">3</span>]);  <span class="comment">// undefined，会被添加</span></span><br></pre></td></tr></table></figure><ol start="3"><li>Array类型方法</li></ol><p><strong>转换方法</strong>：所有对象都具有toLocaleString()、toString()和valueod()方法。<br><code>valueOf()</code>函数用于返回指定对象的原始值；<br><code>toString()</code>函数用于返回指定对象的字符串；</p><table><thead><tr><th style="text-align:center">对象</th><th style="text-align:center">valueOf() 返回值</th><th style="text-align:center">toString() 返回值</th></tr></thead><tbody><tr><td style="text-align:center">Number</td><td style="text-align:center">数字值(number)</td><td style="text-align:center">数字值(string)</td></tr><tr><td style="text-align:center">String</td><td style="text-align:center">字符串值</td><td style="text-align:center">字符串值</td></tr><tr><td style="text-align:center">Boolean</td><td style="text-align:center">布尔值</td><td style="text-align:center">字符串值</td></tr><tr><td style="text-align:center">Object</td><td style="text-align:center">对象本身</td><td style="text-align:center">字符串值</td></tr><tr><td style="text-align:center">Function</td><td style="text-align:center">函数本身</td><td style="text-align:center">字符串值</td></tr><tr><td style="text-align:center">Date</td><td style="text-align:center">以毫秒数存储的时间值(number)</td><td style="text-align:center">标准时间输出(string)</td></tr></tbody></table><p>若数组中的某一项的值是null或undefined，在join()、toLocaleString()、toString()、valueof()方法返回的结果中以空字符串表示。</p><p><strong>队列方法(数组：先进后出)：</strong><br><code>shift()</code>: 取出（删除）数组的第一项，最开始的头部<br><code>unshift()</code>：添加一项至数组的第一项头部<br><code>push()</code>：添加一项至数组的第一项尾部<br><code>pop()</code>：取出（删除）数组的最后一项目，尾部</p><p><strong>操作方法：</strong><br><code>concat()</code>：无参数时，复制当前数组并返回；参数为一个或多个数组，将数组汇总的每一项都添加到结果数组中。<br><code>slice()</code>：返回项的起始和结束位置。该函数不影响原是数组。<br><strong>若slice的参数为负数，则用长度去减，若结束位置小于起始位置，则返回空数组。</strong><br>eg：slice(-2, -1)的长度为5的数组调用后为 slice(3,4);<br><code>splice()</code>：向数组的中部插入项，实现删除、插入和替换。<br>    删除：splice(起始位置，项数);<br>    插入：splice(起始位置，0，要插入的项，要插入的项，要插入的项，…);<br>    替换：splice(起始位置，项数，要插入的项，要插入的项，要插入的项，…);删除后再添加</p><p><strong>位置方法：</strong><br><code>indexOf(查找项，查找起点位置的索引)</code>从数组的开头开始（位置0）向后查找。<br><code>lastIndexOf(查找项，查找起点位置的索引)</code>从数组的末尾开始向前查找。</p><p><strong>迭代方法：</strong><br><code>every()</code>：数组中的每一项都必须满足条件，才返回true<br><code>filter()</code>：过滤<br><code>forEach()</code>：遍历循环<br><code>map()</code>：遍历循环<br><code>some()</code>：数组中的只要有满足条件的，就返回true<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">const</span> everyResult = numbers.every(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// everyResult 结果为： false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> someResult = numbers.every(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// someResult 结果为： true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filterResult = numbers.every(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// filterResult 结果为： [3,4,5,4,3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapResult = numbers.every(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// mapResult 结果为： [2,4,6,8,10,8,6,4,2]</span></span><br></pre></td></tr></table></figure></p><p><strong>缩小方法：</strong><br><code>reduce(函数，缩小基础的初始值)</code>和<code>reduceRight(函数，缩小基础的初始值)</code>都会迭代数组的所有项，reduceRight是从最后一项开始。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> val = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="comment">// 前一个值、当前值、项的索引和数组对象</span></span><br><span class="line">val.reduce(<span class="function">(<span class="params">prev, cur, index, array</span>) =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure></p><ol start="4"><li>Function类型<br><code>arguments</code>（保存函数参数）为类数组对象，包含着传入函数中的所有参数。<br><code>callee</code> 为一个指针，指向拥有这个arguments对象的函数。<br><code>this</code> 函数据以执行的环境对象。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阶乘函数的递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> num &lt;= <span class="number">1</span> ? <span class="number">1</span> : num * <span class="built_in">arguments</span>.callee(num<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用callee 松散耦合</span></span><br></pre></td></tr></table></figure><p><code>apply</code>和 <code>call</code> 都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。<br><strong>能够扩充函数赖以运行的作用域</strong><br><code>apply(运行函数的作用域，参数数组Array / arguments))</code><br><code>call(运行函数的作用域，参数1，参数2，....)</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applySum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为在非严格的全局调用，this指向window，严格模式下，this为undefined。</span></span><br><span class="line"><span class="comment">// 除非明确把函数添加到某个对象或者调用者</span></span><br><span class="line"><span class="built_in">console</span>.log(applySum(<span class="number">10</span>,<span class="number">10</span>));    <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum.call(<span class="keyword">this</span>, ...arguments);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(callSum(<span class="number">10</span>,<span class="number">10</span>));    <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.color = <span class="string">'red'</span>;</span><br><span class="line"><span class="keyword">const</span> o = &#123; <span class="attr">color</span>: <span class="string">'blue'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayColor(); <span class="comment">// red</span></span><br><span class="line">sayColor.call(<span class="keyword">this</span>);    <span class="comment">// red</span></span><br><span class="line">sayColor.call(<span class="built_in">window</span>);  <span class="comment">// red</span></span><br><span class="line">sayColor.call(o);       <span class="comment">// blue 此时this指向对象o</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// this值会被绑定到传给bind() 函数的值</span></span><br><span class="line"><span class="keyword">const</span> objSaycolor = sayColor.bind(o);</span><br><span class="line">objSaycolor();      <span class="comment">// blue</span></span><br></pre></td></tr></table></figure></p><ol start="5"><li>基本包装类型<br><code>toFixed()</code> 返回字符串类型；<br><code>toExponential()</code> 指数表示法表示的数值的字符串形式；<br><code>charAt(0开始的字符位置)</code>：该位置对应的字符；<br><code>charCodeAt(0开始的字符位置)</code>：该位置对应的字符编码；<br><code>concat()</code>：将一或多个字符串拼接起来，返回新的；<br><code>slice()</code>、<code>substr()</code>和<code>substring()</code>：裁剪字符串；</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 负数时，存在差异</span></span><br><span class="line"><span class="keyword">const</span> stringVal = <span class="string">'hello world'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringVal.slice(<span class="number">-3</span>));       <span class="comment">// 'rld'</span></span><br><span class="line"><span class="built_in">console</span>.log(stringVal.substring(<span class="number">-3</span>));   <span class="comment">// 'hello world'</span></span><br><span class="line"><span class="built_in">console</span>.log(stringVal.substr(<span class="number">-3</span>));      <span class="comment">// 'rld'</span></span><br><span class="line"><span class="built_in">console</span>.log(stringVal.slice(<span class="number">3</span>, <span class="number">-4</span>));    <span class="comment">// 'lo w'</span></span><br><span class="line"><span class="built_in">console</span>.log(stringVal.substring(<span class="number">3</span>, <span class="number">-4</span>)); <span class="comment">// 'hel'</span></span><br><span class="line"><span class="built_in">console</span>.log(stringVal.substr(<span class="number">3</span>, <span class="number">-4</span>));    <span class="comment">// ''</span></span><br></pre></td></tr></table></figure><p><code>trim()</code> 创建一个字符串副本，删除前置及后缀的所有空格。<br><code>match()</code>：模式匹配方法，类似于<code>RegExp</code>和 <code>exec()</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> text = <span class="string">'cat, bat, sat, fat'</span>;</span><br><span class="line"><span class="keyword">const</span> pattern = <span class="regexp">/.at/</span>;</span><br><span class="line"><span class="keyword">const</span> result = text.match(pattern); <span class="comment">// ["cat", index: 0, input: "cat, bat, sat, fat", groups: undefined]</span></span><br><span class="line"><span class="keyword">const</span> result = pattern.exec(text)  <span class="comment">// ["cat", index: 0, input: "cat, bat, sat, fat", groups: undefined]</span></span><br><span class="line"><span class="keyword">const</span> result = text.search(<span class="regexp">/at/</span>);  <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">const</span> result = text.replace(<span class="string">'at'</span>, <span class="string">'ond'</span>);   <span class="comment">// "cond, bat, sat, fat"</span></span><br><span class="line"><span class="keyword">const</span> result = text.replace(<span class="regexp">/at/g</span>, <span class="string">'ond'</span>);   <span class="comment">// "cond, bond, sond, fond"</span></span><br><span class="line"><span class="keyword">const</span> result = text.replace(<span class="regexp">/(.at)/g</span>, <span class="string">'word($1)'</span>); <span class="comment">// "word(cat), word(bat), word(sat), word(fat)"</span></span><br></pre></td></tr></table></figure></p><p><code>split()</code> 基于指定的分隔符将一个字符串分割成多个子字符串；<br><code>localeCompare()</code>比较两个字符串，返回与字符串在字母表中的排序有关，靠前，返回1，否则-1，相同为0；<br>const stringVal = ‘yellow’;<br>stringVal.localeCompare(‘brick’);   // 1<br><code>fromCharCode()</code>：接收一或多个字符编码，并转换成字符串；<br>String.fromCharCode(104, 101, 108, 108, 111);   // hello</p><hr><h3 id="chap6、面向对象"><a href="#chap6、面向对象" class="headerlink" title="chap6、面向对象"></a>chap6、面向对象</h3><ol><li>对象的属性类型<br>ECMAScript中有两种属性：数据属性和访问器属性。<br>数据属性包含一个数据值的位置，可以读取和写入值。数据属性有4个描述其行为的特性：<br><code>[[Configurable]]</code>：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。默认值为true；<br><code>[[Enumberable]]</code>：表示能否通过 for-in 循环返回属性。默认值为true；<br><code>[[Writable]]</code>：表示能否修改属性的值。<br><code>[[Value]]</code>：包含这个属性的数据值，读取属性值时，从这个位置读，写入属性值时，把新值保存在这个位置。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">'ruby'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要修改属性默认的特性，需要使用 Object.defineProperty()（见“Object 创建/修改/获取属性的方法”）。</p><ol start="2"><li>访问器属性<br>不包含数据值，包含 getter 和 setter 函数。访问器属性有4个特性：<br><code>[[Configurable]]</code>：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。默认值为true；<br><code>[[Enumberable]]</code>：表示能否通过 for-in 循环返回属性。默认值为true；<br><code>[[Get]]</code>：在读取属性时调用的函数，默认为undefined。<br><code>[[Set]]</code>：在写入属性时调用的函数，默认为undefined。</li></ol><p>访问器属性不能直接定义，必须使用Object.defineProperties()来定义。</p><pre><code class="js"></code></pre><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录：&quot;&gt;&lt;a href=&quot;#目录：&quot; class=&quot;headerlink&quot; title=&quot;目录：&quot;&gt;&lt;/a&gt;目录：&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;#chap5、引用类型&quot;&gt;chap5、引用类型&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#chap6、面向对象&quot;&gt;chap
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>JS基础总结</title>
    <link href="http://yoursite.com/2018/09/26/%5BJS%5D%20JS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/09/26/[JS] JS基础总结/</id>
    <published>2018-09-26T06:48:21.000Z</published>
    <updated>2018-10-12T09:20:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h2><p><a href="#一、JS中的数据类型">一、JS 中的数据类型</a><br><a href="#二、JS中类型检测">二、JS 中类型检测</a><br><a href="#三、-extend和-fn-extend">三、$.extend()和$.fn.extend()</a><br><a href="#四、jquery的事件绑定on、bind、dele">四、jquery的事件绑定on、bind、dele</a><br><a href="#五、defer和async">五、defer和async</a><br><a href="#六、module-exports和export的区别">六、module.exports和export的区别</a><br><a href="#七、Promise">七、Promise</a><br><a href="#八、JS中正则表达式的使用">八、JS中正则表达式的使用</a><br><a href="#九、数组">九、数组</a><br><a href="#十、前端的各种排序">十、前端的各种排序</a><br><a href="#十一、列举HTML5新特性">十一、列举HTML5新特性</a><br><a href="#十二、列举Css3新特性">十二、列举Css3新特性</a></p><h3 id="一、JS-中的数据类型"><a href="#一、JS-中的数据类型" class="headerlink" title="一、JS 中的数据类型"></a>一、JS 中的数据类型</h3><p>JavaScript 有 5 种简单数据类型：Undefined、Null、Boolean、Number、String 和 1 种复杂数据类型 Object 。<br>基本类型（值类型）：Undefined、Null、Boolean、Number、String<br>复杂类型（引用类型）：Object、Array、Date、RegExp、Function、基本包装类型（Boolean | Number | String）、单体内置对象（Global | Math）。<br>类型检测：typeof、instanceof、<code>Object.prototype.toString.call()</code>；</p><blockquote><p><strong>值类型与引用类型的差别:</strong></p><ul><li>基本类型在内存中占据固定大小的空间，因此被保存在栈内存中;</li><li>从一个变量向另一个变量复制基本类型的值，复制的是值的副本;</li><li>引用类型的值是对象，保存在堆内存;</li><li>包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针;</li><li>从一个变量向另一个变量复制引用类型的值的时候，复制是引用指针，因此两个变量最终都指向同一个对象。</li></ul></blockquote><hr><h3 id="二、JS中类型检测"><a href="#二、JS中类型检测" class="headerlink" title="二、JS中类型检测"></a>二、JS中类型检测</h3><p>在JavaScript里使用typeof判断数据类型，只能区分基本类型，即：<code>number</code>、<code>string</code>、<code>undefined</code>、<code>boolean</code>、<code>object</code>。<br>对于<code>null</code>、<code>array</code>、<code>function</code>、<code>object</code>来说，使用typeof都会统一返回object字符串。</p><p>要想区分对象、数组、函数、单纯使用typeof是不行的。在JS中，可以通过<code>Object.prototype.toString</code>方法，判断某个对象之属于哪种内置类型。分为null、string、boolean、number、undefined、RegExp、array、function、object、date、math。</p><p>判断原生JSON对象: <code>window.JSON &amp;&amp; Object.prototype.toString.call(JSON)</code> 输出结果为”[object JSON]”说明JSON是原生的，否则不是。<br><strong>注意：Object.prototpye.toString()本身也可能会被修改</strong></p><p>对于自定义的函数，可以使用 instanceof判断，判断一个实例是否属于某种类型。<code>console.log(person instanceof Person);</code></p><hr><h3 id="三、-extend和-fn-extend"><a href="#三、-extend和-fn-extend" class="headerlink" title="三、$.extend和$.fn.extend"></a>三、$.extend和$.fn.extend</h3><ol><li><p><code>extend(dest,src1,src2,src3...)</code>: 将src1,src2,src3…合并到dest中,返回值为合并后的dest,修改了dest的结构。<br> <code>$.extend({},src1,src2,src3...)</code>  // 也就是将”{}”作为dest参数，不修改dest的结构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后面的参数如果和前面的参数存在相同的名称，那么后面的会覆盖前面的参数值。</span></span><br><span class="line">$.extend(&#123;&#125;,&#123;<span class="attr">name</span>:<span class="string">"Tom"</span>,<span class="attr">age</span>:<span class="number">21</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">"Jerry"</span>,<span class="attr">sex</span>:<span class="string">"Boy"</span>&#125;); <span class="comment">// &#123;name:"Jerry",age:21,sex:"Boy"&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>省略 dest 参数<br><code>$.extend(src)</code>: 将src合并到jquery的全局对象中去。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将hello方法合并到jquery的全局对象中</span></span><br><span class="line">$.extend(&#123;</span><br><span class="line">    hello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">'hello'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>$.fn.extend(src): 将src合并到jquery的实例对象中去 (<strong>$.fn=jquery.prototype</strong>)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是在jquery全局对象中扩展一个net命名空间。</span></span><br><span class="line">$.extend(&#123;<span class="attr">net</span>:&#123;&#125;&#125;);</span><br><span class="line">　　 </span><br><span class="line"><span class="comment">// 这是将hello方法扩展到之前扩展的Jquery的net命名空间中去</span></span><br><span class="line">$.extend($.net, &#123;</span><br><span class="line">    hello:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'hello'</span>);&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>extend方法还有一个重载原型：<br><code>extend(boolean,dest,src1,src2,src3...)</code>: boolean代表是否进行深度拷贝。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result=$.extend( <span class="literal">true</span>, &#123;&#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>:<span class="string">"John"</span>, <span class="attr">location</span>: &#123;<span class="attr">city</span>: <span class="string">"Boston"</span>,<span class="attr">county</span>:<span class="string">"USA"</span>&#125; &#125;,</span><br><span class="line">    &#123; <span class="attr">last</span>:<span class="string">"Resig"</span>, <span class="attr">location</span>: &#123;<span class="attr">state</span>: <span class="string">"MA"</span>,<span class="attr">county</span>:<span class="string">"China"</span>&#125; &#125; );</span><br><span class="line"><span class="comment">//  result = &#123;name:"John",last:"Resig",location:&#123;city:"Boston",state:"MA",county:"China"&#125;&#125;</span></span><br><span class="line"><span class="keyword">var</span> result=$.extend( <span class="literal">false</span>, &#123;&#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>:<span class="string">"John"</span>, <span class="attr">location</span>:&#123;<span class="attr">city</span>: <span class="string">"Boston"</span>,<span class="attr">county</span>:<span class="string">"USA"</span>&#125; &#125;,</span><br><span class="line">    &#123; <span class="attr">last</span>:<span class="string">"Resig"</span>, <span class="attr">location</span>: &#123;<span class="attr">state</span>: <span class="string">"MA"</span>,<span class="attr">county</span>:<span class="string">"China"</span>&#125; &#125;);</span><br><span class="line"><span class="comment">// result = &#123;name:"John",last:"Resig",location:&#123;state:"MA",county:"China"&#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="四、jquery的事件绑定on、bind、dele"><a href="#四、jquery的事件绑定on、bind、dele" class="headerlink" title="四、jquery的事件绑定on、bind、dele"></a>四、jquery的事件绑定on、bind、dele</h3><ol><li>sdas</li></ol><hr><h3 id="五、defer和async"><a href="#五、defer和async" class="headerlink" title="五、defer和async"></a>五、defer和async</h3><p>defer可以让脚本在文档完全呈现之后再执行，延迟脚本总是按照指定它们的顺序执行。<br>async可表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚本按照它们在页面中出现的顺序执行。</p><hr><h3 id="六、module-exports和export的区别"><a href="#六、module-exports和export的区别" class="headerlink" title="六、module.exports和export的区别"></a>六、module.exports和export的区别</h3><p>模块化：公共代码抽离成为一个单独的js文件，作为一个模块，模块只有通过module.exports 和 exports 才能对外暴露接口。<br>区别：</p><ul><li>exports 是指向的module.exports 的引用；</li><li>module.exports 初始值为一个空对象{}，所以exports 初始值也是{}；</li><li>require() 返回的是module.exports 而不是exports。</li></ul><h3 id="七、Promise"><a href="#七、Promise" class="headerlink" title="七、Promise"></a>七、Promise</h3><p>Promise代表了某个未来才会知道结果的事件（通常是一个异步操作），可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。<br>Promise对象有三种状态：pending状态（ 等待中），fulfilled状态（操作完成的状态），rejected状态（操作失败的状态），状态不受外界影响，一旦状态改变，就不会再变。</p><p>基本的API有：<br>    <code>Promise.resolve()</code><br>    <code>Promise.reject()</code><br>    <code>Promise.prototype.then()</code><br>    <code>Promise.prototype.catch()</code><br>    <code>Promise.all()</code><br>    <code>Promise.race()</code></p><p>常见使用场景：ajax请求，定时器，数据验证，动画结束回调，多重回调解耦等。</p><hr><h3 id="八、JS中正则表达式的使用"><a href="#八、JS中正则表达式的使用" class="headerlink" title="八、JS中正则表达式的使用"></a>八、JS中正则表达式的使用</h3><ol><li><code>String.prototype.search</code>方法。eg：”abchello”.search(/hello/); // 3</li><li><code>String.prototype.replace</code>方法。eg：”abchello”.replace(/hello/,”hi”); // “abchi”</li><li><code>String.prototype.split</code>方法。 eg: “abchelloasdasdhelloasd”.split(/hello/); //[“abc”, “asdasd”, “asd”]</li><li><code>String.prototype.match</code>方法。 eg:<br>用来捕获字符串中的子字符串到一个数组中。<strong>默认情况下只捕获一个结果到数组中</strong>。<br>eg：  “abchelloasdasdhelloasd”.match(/hello/);  //[“hello”]<br>  “abchelloasdasdhelloasd”.match(/hello/g);  //[“hello”,”hello”]</li><li><p><code>RegExp.prototype.exec</code>方法。<br>1、exec方法一次只能捕获一份子字符串到数组中，无论正则表达式是否有全局属性<br>eg: <code>/hello/g.exec(&quot;abchelloasdasdhelloasd&quot;);</code> // [“hello”]<br>2、正则表达式对象有一个lastIndex属性，用来表示下一次从哪个位置开始捕获，每一次执行exec方法后，lastIndex就会往后推，直到找不到匹配的字符返回null，然后又从头开始捕获。 这个属性可以用来遍历捕获字符串中的子串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg=<span class="regexp">/hello/g</span>;</span><br><span class="line">reg.lastIndex; <span class="comment">//0</span></span><br><span class="line">reg.exec(<span class="string">"abchelloasdasdhelloasd"</span>); <span class="comment">// ["hello"]</span></span><br><span class="line">reg.lastIndex; <span class="comment">//8</span></span><br><span class="line">reg.exec(<span class="string">"abchelloasdasdhelloasd"</span>); <span class="comment">// ["hello"]</span></span><br><span class="line">reg.lastIndex; <span class="comment">//19</span></span><br><span class="line">reg.exec(<span class="string">"abchelloasdasdhelloasd"</span>); <span class="comment">// null</span></span><br><span class="line">reg.lastIndex; <span class="comment">//0</span></span><br></pre></td></tr></table></figure></li><li><p><code>RegExp.prototype.test</code>方法: 用来测试字符串中是否含有子字符串<br>eg: /hello/.test(“abchello”); // true</p></li></ol><h3 id="九、数组"><a href="#九、数组" class="headerlink" title="九、数组"></a>九、数组</h3><ol><li>Array.prototype.flat(depth)（扁平化数组）<br>会递归到指定深度将所有子数组连接，并返回一个新数组。depth 指定嵌套数组中的结构深度，默认值为1<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line">arr1.flat();  <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]];</span><br><span class="line">arr2.flat();  <span class="comment">// [1, 2, 3, 4, [5, 6]]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr3 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]];</span><br><span class="line">arr3.flat(<span class="number">2</span>); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr4 = [<span class="number">1</span>, <span class="number">2</span>, , <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr4.flat();    <span class="comment">// [1, 2, 4, 5] 会移除数组中的空项</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="十、前端的各种排序"><a href="#十、前端的各种排序" class="headerlink" title="十、前端的各种排序"></a>十、前端的各种排序</h3><p><img src="http://pfuoi64aq.bkt.clouddn.com/1093977-20170718164528771-1976850903.jpg" alt="算法导图"></p><ol><li><p>快速排序<br>思想：  1、找基准（一般是以中间项为基准）；2、遍历数组，小于基准的放在left，大于基准的放在right；3、递归</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> times = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//如果数组&lt;=1,则直接返回</span></span><br><span class="line">  <span class="keyword">if</span>(arr.length &lt;= <span class="number">1</span>)&#123; <span class="keyword">return</span> arr; &#125;</span><br><span class="line">  <span class="keyword">var</span> pivotIndex = <span class="built_in">Math</span>.floor(arr.length/<span class="number">2</span>);</span><br><span class="line">  <span class="comment">//找基准，并把基准从原数组删除</span></span><br><span class="line">  <span class="keyword">var</span> pivot = arr.splice(pivotIndex,<span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">//定义左右数组</span></span><br><span class="line">  <span class="keyword">var</span> left = [];</span><br><span class="line">  <span class="keyword">var</span> right = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//比基准小的放在left，比基准大的放在right</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] &lt;= pivot) &#123;</span><br><span class="line">      left.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      right.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"第"</span>+(++times)+<span class="string">"次排序后："</span>+arr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//递归</span></span><br><span class="line">  <span class="keyword">return</span> quickSort(left).concat([pivot],quickSort(right));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数组长度10，排序次数22次。</span></span><br></pre></td></tr></table></figure></li><li><p>冒牌排序<br>思想： 每一次对比相邻两个数据的大小，小的排在前面，如果前面的数据比后面的大就交换这两个数的位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> times=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; arr.length<span class="number">-1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j = i + <span class="number">1</span>;j &lt; arr.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[i] &gt; arr[j]) &#123;</span><br><span class="line">        <span class="comment">//如果前面的数据比后面的大就交换</span></span><br><span class="line">        <span class="keyword">var</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"第"</span>+(++times)+<span class="string">"次排序后："</span>+arr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数组长度10，排序次数45次。</span></span><br></pre></td></tr></table></figure></li><li><p>选择排序<br>思想：每次选择最小的数，将最小的数记录下来，然后排到最前面</p></li></ol><h3 id="十一、列举HTML5新特性"><a href="#十一、列举HTML5新特性" class="headerlink" title="十一、列举HTML5新特性"></a>十一、列举HTML5新特性</h3><ul><li>语意化标签(nav、aside、dialog、header、footer等)</li><li>canvas</li><li>拖放相关api</li><li>Audio、Video</li><li>获取地理位置</li><li>更好的input校验</li><li>web存储(localStorage、sessionStorage)</li><li>webWorkers(类似于多线程并发)</li><li>webSocket</li></ul><h3 id="十二、列举Css3新特性"><a href="#十二、列举Css3新特性" class="headerlink" title="十二、列举Css3新特性"></a>十二、列举Css3新特性</h3><ul><li>选择器</li><li>边框(border-image、border-radius、box-shadow)</li><li>背景(background-clip、background-origin、background-size)</li><li>渐变(linear-gradients、radial-gradents)</li><li>字体(@font-face)</li><li>转换、形变(transform)</li><li>过度(transition)</li><li>动画(animation)</li><li>弹性盒模型(flex-box)</li><li>媒体查询(@media)</li></ul><h3 id="十三、页面渲染机制"><a href="#十三、页面渲染机制" class="headerlink" title="十三、页面渲染机制"></a>十三、页面渲染机制</h3><h4 id="1-CSS加载会阻塞DOM树吗？"><a href="#1-CSS加载会阻塞DOM树吗？" class="headerlink" title="1.CSS加载会阻塞DOM树吗？"></a>1.CSS加载会阻塞DOM树吗？</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>css阻塞<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    h1 &#123;</span></span><br><span class="line"><span class="undefined">      color: red !important</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">h</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelectorAll(<span class="string">'h1'</span>))</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    setTimeout(h, 0)</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是红色的<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://pfuoi64aq.bkt.clouddn.com/1658ea252321cb0f" width="70%" height="70%"><br>由上图可以看出，控制台已打出console.log，说明此时的h1已经被解析，但是并没有显示。</p><p>解释：是浏览器的一种优化机制。因为加载css时，可能会修改下面DOM节点的样式，如果css加载不阻塞DOM树渲染的话，那么当css加载完之后，DOM树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。<br>所以就先把DOM树的结构先解析完，把可以做的工作做完，然后等css加载完之后，在根据最终的样式来渲染DOM树。</p><font color="#d00">css加载不会阻塞DOM树解析，但是会阻塞DOM树渲染</font><h4 id="2-css加载会阻塞js运行吗？"><a href="#2-css加载会阻塞js运行吗？" class="headerlink" title="2.css加载会阻塞js运行吗？"></a>2.css加载会阻塞js运行吗？</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>css阻塞<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'before css'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> startDate = <span class="keyword">new</span> <span class="built_in">Date</span>()</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是红色的<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> endDate = <span class="keyword">new</span> <span class="built_in">Date</span>()</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'after css'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'经过了'</span> + (endDate -startDate) + <span class="string">'ms'</span>)</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://pfuoi64aq.bkt.clouddn.com/1.gif" width="70%" height="70%"></p><p>可以看出，css之前的js代码已经解析完毕，但是css之后的js等到css加载完才执行。</p><font color="#d00">css加载会阻塞后面的js语句的执行</font><br><font color="#d00">css会阻塞Dom渲染和js执行，而js会阻塞Dom解析</font><p>提高css加载速度的方法：</p><ol><li>使用CDN(因为CDN会根据你的网络状况，替你挑选最近的一个具有缓存内容的节点为你提供资源，因此可以减少加载时间)</li><li>对css进行压缩(可以用很多打包工具，比如webpack,gulp等，也可以通过开启gzip压缩)</li><li>合理的使用缓存(设置cache-control,expires,以及E-tag都是不错的，不过要注意一个问题，就是文件更新后，你要避免缓存而带来的影响。其中一个解决防范是在文件名字后面加一个版本号)</li><li>减少http请求数，将多个css文件合并，或者是干脆直接写成内联样式(内联样式的一个缺点就是不能缓存)</li></ol><h4 id="3-说明上述的原因"><a href="#3-说明上述的原因" class="headerlink" title="3. 说明上述的原因"></a>3. 说明上述的原因</h4><p>不用浏览器使用的内核不同，目前主要有两个：<br><strong>webkit渲染过程</strong><br><img src="http://pfuoi64aq.bkt.clouddn.com/2" width="70%" height="70%"><br><strong>Gecko渲染过程</strong><br><img src="http://pfuoi64aq.bkt.clouddn.com/3" width="70%" height="70%"></p><p>从上面两个流程图我们可以看出来，浏览器渲染的流程如下：</p><ol><li>HTML解析文件，生成DOM Tree，解析CSS文件生成CSSOM Tree</li><li>将Dom Tree和CSSOM Tree结合，生成Render Tree(渲染树)</li><li>根据Render Tree渲染绘制，将像素渲染到屏幕上。</li></ol><p>因此：</p><font color="#d00">1. DOM解析和CSS解析是两个并行的进程，所以这也解释了为什么CSS加载不会阻塞DOM的解析。</font><br><font color="#d00">2. 然而，由于Render Tree是依赖于DOM Tree和CSSOM Tree的，所以他必须等待到CSSOM Tree构建完成，也就是CSS资源加载完成(或者CSS资源加载失败)后，才能开始渲染。因此，CSS加载是会阻塞Dom的渲染的。</font><br><font color="#d00">3. 由于js可能会操作之前的Dom节点和css样式，因此浏览器会维持html中css和js的顺序。因此，样式表会在后面的js执行前先加载执行完毕。所以css会阻塞后面js的执行。</font><h4 id="4-DOMContentLoaded"><a href="#4-DOMContentLoaded" class="headerlink" title="4.DOMContentLoaded"></a>4.DOMContentLoaded</h4><p>对于浏览器来说，页面加载主要有两个事件，一个是 DOMContentLoaded ，另一个是 onLoad 。<br>onLoad: 等待页面的所有资源都加载完成才会触发，css、js、图片视频<br>DOMContentLoaded: 当页面的内容解析完成后，则触发该事件</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录：&quot;&gt;&lt;a href=&quot;#目录：&quot; class=&quot;headerlink&quot; title=&quot;目录：&quot;&gt;&lt;/a&gt;目录：&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;#一、JS中的数据类型&quot;&gt;一、JS 中的数据类型&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#二、JS中类型检测&quot;&gt;二、JS
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>CSS3 单位汇总</title>
    <link href="http://yoursite.com/2018/09/12/%5BCSS%5D%20CSS3%20%E5%8D%95%E4%BD%8D/"/>
    <id>http://yoursite.com/2018/09/12/[CSS] CSS3 单位/</id>
    <published>2018-09-12T08:31:38.000Z</published>
    <updated>2018-10-08T02:22:00.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><code>px</code>：绝对单位，页面按精确像素展示。</li><li><code>em</code>：相对单位，基准点为父节点字体的大小。<br>如果自身定义了font-size按自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值。</li><li><code>rem</code>：相对单位，可理解为”root em”, 相对根节点html的字体大小来计算，CSS3新加属性，chrome/firefox/IE9+支持。<br>(另外需注意chrome强制最小字体为12号，即使设置成 10px 最终都会显示成 12px，当把html的font-size设置成10px,子节点rem的计算还是以12px为基准)。</li><li><code>vw</code>：viewpoint width，视窗宽度，1vw等于视窗宽度的1%。</li><li><code>vh</code>：viewpoint height，视窗高度，1vh等于视窗高度的1%。</li><li><code>vmin</code>：vw和vh中较小的那个。</li><li><code>vmax</code>：vw和vh中较大的那个。<br>vw, vh, vmin, vmax：IE9+局部支持，chrome/firefox/safari/opera支持，ios safari 8+支持，android browser4.4+支持，chrome for android39支持</li><li><code>ex</code>：取当前作用效果的字体的x的高度，在无法确定x高度的情况下以0.5em计算(IE11及以下均不支持 firefox/chrome/safari/opera/ios safari/android browser4.4+等均需属性加么有前缀)</li><li><code>ch</code>:以节点所使用字体中的“0”字符为基准，找不到时为0.5em(ie10+,chrome31+,safair7.1+,opera26+,ios safari 7.1+,android browser4.4+支持)</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;code&gt;px&lt;/code&gt;：绝对单位，页面按精确像素展示。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;em&lt;/code&gt;：相对单位，基准点为父节点字体的大小。&lt;br&gt;如果自身定义了font-size按自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="CSS3" scheme="http://yoursite.com/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>JS 函数式编程指南</title>
    <link href="http://yoursite.com/2018/09/06/%5BJS%5D%20JS%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2018/09/06/[JS] JS 函数式编程指南/</id>
    <published>2018-09-06T02:30:23.000Z</published>
    <updated>2018-10-08T02:21:50.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Vue知识点总结</title>
    <link href="http://yoursite.com/2018/09/06/vue%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/09/06/vue知识点总结/</id>
    <published>2018-09-06T02:30:23.000Z</published>
    <updated>2018-10-08T02:21:07.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Vue-nextTick-使用原因"><a href="#1、Vue-nextTick-使用原因" class="headerlink" title="1、Vue nextTick 使用原因"></a>1、Vue nextTick 使用原因</h3><p>Vue批量挂起DOM更新并异步应用它们以防止由多个数据突变导致的不必要的重新呈现。<br>在实践中我们经常不得不Vue.nextTick等待Vue在我们触发某些状态更改之后执行实际的DOM更新。</p><h3 id="2、Vue实现数据双向绑定的原理：Object-defineProperty"><a href="#2、Vue实现数据双向绑定的原理：Object-defineProperty" class="headerlink" title="2、Vue实现数据双向绑定的原理：Object.defineProperty()"></a>2、Vue实现数据双向绑定的原理：Object.defineProperty()</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、Vue-nextTick-使用原因&quot;&gt;&lt;a href=&quot;#1、Vue-nextTick-使用原因&quot; class=&quot;headerlink&quot; title=&quot;1、Vue nextTick 使用原因&quot;&gt;&lt;/a&gt;1、Vue nextTick 使用原因&lt;/h3&gt;&lt;p&gt;Vu
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>git 命令</title>
    <link href="http://yoursite.com/2018/09/06/git%20%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/09/06/git 命令/</id>
    <published>2018-09-06T02:30:23.000Z</published>
    <updated>2018-10-08T02:21:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><p>【git 删除本地分支】：<code>git branch -D br</code><br>【git 删除远程分支】：<code>git push origin :br</code>  (origin 后面有空格)<br>【恢复删除掉的分支】：<code>git branch 分支名 hash_val</code><br>    其中 hash_val 为散列值，如果不知，可利用 reflog。<br>    reflog命令：显示整个本地仓储的commit，包括所有branch的commit，甚至包括已经撤销的commit。<br>    eg: git branch 分支名 HEAD@{4}</p><p>【将远程的某个分支，拉取到本地】：<br>    方法一：<br>      <code>git checkout -b 本地分支名x  origin/远程分支名x</code><br>    方法二：<br>      <code>git fetch origin 远程分支名x:本地分支名x</code></p><h2 id="回退回滚取消提交返回上一版本"><a href="#回退回滚取消提交返回上一版本" class="headerlink" title="回退回滚取消提交返回上一版本"></a>回退回滚取消提交返回上一版本</h2><p>【没有push】：<code>git reset [ --soft || --hard || --mixed ] commitId</code><br>eg：git reset –hard 139dcfaa558e3276b30b6b2e5cbbb9c00bbdca96  (ID)</p><p>–soft    保留源码（work），回退到 commit 信息到某个版本，不涉及index的回退<br>        如果还需要提交，直接commit<br>        <strong>commit 回退，index和work不会</strong></p><p>–hard    源码也会回退到某个版本，commit和index 都回退到某个版本。<br>        commit、index和work都会改变<br>        <strong>push之后千万不要使用，因为线上代码没变，包括commit和index；</strong><br>        <strong>但把本地代码修改完提交时会发生权限冲突  加 force</strong><br>        <strong>把修改推到远程： git push -f -u origin master</strong></p><p>–mixed    会保留源码，只会将 git commit 和index 回退<br>        commit和index会回退，work保留</p><p>【已经push】<code>git revert commintId</code><br>git revert 反转提交（工作树必须干净  三个区域的状态、git status干净）用一个新提交来消除一个历史提交所做的任何修改。<br>revert 本地代码回退，再git push 更新线上代码</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;删除分支&quot;&gt;&lt;a href=&quot;#删除分支&quot; class=&quot;headerlink&quot; title=&quot;删除分支&quot;&gt;&lt;/a&gt;删除分支&lt;/h2&gt;&lt;p&gt;【git 删除本地分支】：&lt;code&gt;git branch -D br&lt;/code&gt;&lt;br&gt;【git 删除远程分支】：&lt;co
      
    
    </summary>
    
      <category term="编码规范" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
</feed>
