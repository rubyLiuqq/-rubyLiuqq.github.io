<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-29T13:04:42.605Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>rubyliuqq</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/10/29/%5BJS%5D%20%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2018/10/29/[JS] 深拷贝与浅拷贝/</id>
    <published>2018-10-29T13:04:42.605Z</published>
    <updated>2018-10-29T13:04:42.605Z</updated>
    
    <content type="html"><![CDATA[<p>[JS] 深拷贝与浅拷贝.md</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[JS] 深拷贝与浅拷贝.md&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>客户端存储技术.md</title>
    <link href="http://yoursite.com/2018/10/29/%5BJS%5D%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF/"/>
    <id>http://yoursite.com/2018/10/29/[JS] 客户端存储技术/</id>
    <published>2018-10-29T08:45:25.000Z</published>
    <updated>2018-10-29T13:04:42.605Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用的客户端存储方法有哪些？"><a href="#常用的客户端存储方法有哪些？" class="headerlink" title="常用的客户端存储方法有哪些？"></a>常用的客户端存储方法有哪些？</h2><p><code>cookie</code>：是客户端用来存储数据的一种选项，它既可以在客户端设置也可以在服务器端设置。cookie会跟随任意HTTP请求一起发送。是「浏览器」提供的一种机制。<br><code>sessionStorage</code>：严格用于一个浏览器会话中存储数据，因为数据在浏览器关闭后会立即删除<br><code>localStorage</code>：用于跨会话持久化地存储数据<br><code>indexedDB</code>：在浏览器中保存结构化数据的一种「数据库」<br>cookie：兼容性好，可以通过<code>document.cookie</code>访问它<br>缺点：1、增加了网络流量；2、它的数据容量有限，最多只能存储4KB的数据，浏览器之间各有不同；3、不安全。<br>SessionStorage、LocalStorage缺点：IE不支持 SessionStorage，低版本IE ( IE6, IE7 ) 不支持 LocalStorage，并且不支持查询语言<br>indexedDB：兼容性不好，未得到大部分浏览器的支持</p><h2 id="cookie、sessionStorage和localStorage的区别？"><a href="#cookie、sessionStorage和localStorage的区别？" class="headerlink" title="cookie、sessionStorage和localStorage的区别？"></a>cookie、sessionStorage和localStorage的区别？</h2><ol><li><p>存储时效：<br>cookie可以手动设置失效期，默认为会话级<br>sessionStorage的存储时长是会话级<br>localStorage的存储时长是永久，除非用户手动利用浏览器的工具删除</p></li><li><p>访问的局限性：<br>cookie可以设置路径path，所以它要比另外两个多了一层访问限制<br>localStorage和sessionStorage的访问限制是文档源级别，即协议、主机名和端口<br>cookie可以通过设置domain属性值，可以在不同二级域名下共享cookie，而Storage不可以，比如<a href="http://image.baidu.com的cookie" target="_blank" rel="noopener">http://image.baidu.com的cookie</a> <a href="http://map.baidu.com是可以访问的，前提是cookie的domain设置为http://baidu.com，而Storage是不可以的" target="_blank" rel="noopener">http://map.baidu.com是可以访问的，前提是cookie的domain设置为http://baidu.com，而Storage是不可以的</a></p></li><li><p>存储大小限制：<br>cookie适合存储少量数据，他的大小限制是个数进行限制，每个浏览器的限制数量不同<br>Storage可以存储数据的量较大，此外它是通过占用空间大小来做限制的，每个浏览器的实现也是不同的</p></li><li><p>操作方法：<br>cookie是作为document的属性存在，并没有提供标准的方法来直接操作cookie<br>Storage提供了setItem()和getItem()还有removeItem()方法，操作方便不易出错</p></li><li><p>其他：<br>cookie在发送http请求时，会将本地的cookie作为http头部信息传递给服务器<br>cookie可以由服务器通过http来设定</p></li></ol><h2 id="cookie由哪些部分组成？"><a href="#cookie由哪些部分组成？" class="headerlink" title="cookie由哪些部分组成？"></a>cookie由哪些部分组成？</h2><p>一般有以下几部分组成:<br><code>set cookie: name=value; domain=.mozilla.org; expires=Feb, 13-Mar-2018 11:47:50; path=/; secure</code><br>1、<code>name名称</code>：一个唯一确定cookie的名称，部分大小写，cookie的名字必须是经过URL编码的，一般可以采用某个前缀在加上当前时间的做法，这样的话名称能够确保是唯一的，也比较方便。<br>2、<code>value值</code>：存储在cookie中的字符串值，必须经过被URL编码<br>3、<code>domain域</code>：对于哪个域是有效的，如果没有设置的话，默认来自设置cookie的那个域，在上诉例子中就是.Mozilla.org<br>4、<code>expires失效时间</code>：表示cookie何时应该被删除的时间戳，这个日期是GMT格式的日期，如果设置是以前的时间，cookie会被立刻删除。上诉cookie的失效时间是Feb,13-Mar-2018 11:47:50。<br>5、<code>path路径</code>：指定域中的那个路径，应该想服务器发送cookie，/ 表示没有限制<br>6、<code>secure安全标志</code>：指定以后，cookie只有在使用SSL连接的时候才可以发送到服务器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常用的客户端存储方法有哪些？&quot;&gt;&lt;a href=&quot;#常用的客户端存储方法有哪些？&quot; class=&quot;headerlink&quot; title=&quot;常用的客户端存储方法有哪些？&quot;&gt;&lt;/a&gt;常用的客户端存储方法有哪些？&lt;/h2&gt;&lt;p&gt;&lt;code&gt;cookie&lt;/code&gt;：是客
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>JS设计模式</title>
    <link href="http://yoursite.com/2018/10/28/%5BJS%5D%20JS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/10/28/[JS] JS设计模式/</id>
    <published>2018-10-28T09:46:34.000Z</published>
    <updated>2018-10-30T10:28:20.586Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>ES6基础知识—Symbol</title>
    <link href="http://yoursite.com/2018/10/26/%5BES6%5D%20ES6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94Symbol/"/>
    <id>http://yoursite.com/2018/10/26/[ES6] ES6基础知识—Symbol/</id>
    <published>2018-10-26T02:38:24.000Z</published>
    <updated>2018-10-29T13:04:42.600Z</updated>
    
    <content type="html"><![CDATA[<p><a href="#1、概述">1、概述</a><br><a href="#2、作为属性名的Symbol">2、作为属性名的Symbol</a><br><a href="#3、消除魔术字符串">3、消除魔术字符串</a><br><a href="#4、属性名的遍历">4、属性名的遍历</a><br><a href="#5、Symbol.for/Symbol.keyFor">5、Symbol.for/Symbol.keyFor</a></p><p>JS 有了第七种数据类型：Symbol，创建一个独一无二的值；它用于对象的属性，设计初衷是为了避免对象属性冲突的问题。要获取对象symbol类型的属性，要用<code>Object.getOwnPropertySymbols()</code>；还提供了<code>Symbol.for()</code>和<code>Symbol.keyFor()</code>方法用于搜索对应的symbol值。</p><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p>1、原始数据类型<code>Symbol</code>：防止属性名的冲突<br>2、它是 JS 语言的第七种数据类型，前六种是：undefined、null、Boolean、String、Number、Object。<br>3、Symbol 值不是对象，不能添加属性，基本上，它是一种类似于字符串的数据类型。<br>4、Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。<br>5、Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。<br>6、Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。<br>7、Symbol 值不能与其他类型的值进行运算，会报错<br>8、Symbol 值可以显式转为字符串，Symbol 值也可以转为布尔值，但是不能转为数值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'bar'</span>);</span><br><span class="line">s;  <span class="comment">// Symbol()</span></span><br><span class="line"><span class="keyword">typeof</span> s  <span class="comment">// "symbol"</span></span><br><span class="line">s1; <span class="comment">// Symbol(foo)</span></span><br><span class="line">s2; <span class="comment">// Symbol(bar)</span></span><br><span class="line">s1.toString() <span class="comment">// "Symbol(foo)"</span></span><br><span class="line">s2.toString() <span class="comment">// "Symbol(bar)"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5、Symbol 的参数是一个对象</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'abc'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(obj);</span><br><span class="line">sym   <span class="comment">// Symbol(abc)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 7、Symbol 值不能与其他类型的值进行运算，会报错</span></span><br><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>(<span class="string">'My symbol'</span>);</span><br><span class="line"><span class="string">"your symbol is "</span> + sym   <span class="comment">// TypeError: can't convert symbol to string</span></span><br><span class="line"><span class="string">`your symbol is <span class="subst">$&#123;sym&#125;</span>`</span> <span class="comment">// TypeError: can't convert symbol to string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Symbol 值可以显式转为字符串、布尔值，不能转为数值</span></span><br><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>(<span class="string">'My symbol'</span>);</span><br><span class="line"><span class="built_in">String</span>(sym) <span class="comment">// 'Symbol(My symbol)'</span></span><br><span class="line">sym.toString() <span class="comment">// 'Symbol(My symbol)'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">Boolean</span>(sym) <span class="comment">// true</span></span><br><span class="line">!sym  <span class="comment">// false</span></span><br><span class="line"><span class="keyword">if</span> (sym) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(sym) <span class="comment">// TypeError</span></span><br><span class="line">sym + <span class="number">2</span> <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure></p><h2 id="2、作为属性名的Symbol"><a href="#2、作为属性名的Symbol" class="headerlink" title="2、作为属性名的Symbol"></a>2、作为属性名的Symbol</h2><p>1、由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。<br>2、Symbol 值作为对象属性名时，不能用点运算符。<br>3、在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。如果不放在方括号中，该属性的键名就是字符串，而不是所代表的那个 Symbol 值。<br>4、Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">'Hello!'</span>;</span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  [mySymbol]: <span class="string">'Hello'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 第三种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, mySymbol, &#123; <span class="attr">value</span>: <span class="string">'Hello!'</span> &#125;);</span><br><span class="line"><span class="comment">// 以上写法都得到同样结果</span></span><br><span class="line">a[mySymbol] <span class="comment">// "Hello!"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、在对象的内部使用 Symbol 值定义属性</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [s]: <span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [s](arg) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj[s](<span class="number">123</span>);</span><br></pre></td></tr></table></figure><h2 id="3、消除魔术字符串"><a href="#3、消除魔术字符串" class="headerlink" title="3、消除魔术字符串"></a>3、消除魔术字符串</h2><p>魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shapeType = &#123;</span><br><span class="line">  triangle: <span class="string">'Triangle'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 等价于 triangle 的值不影响</span></span><br><span class="line"><span class="keyword">const</span> shapeType = &#123;</span><br><span class="line">  triangle: <span class="built_in">Symbol</span>()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span>(<span class="params">shape, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> area = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">switch</span> (shape) &#123;</span><br><span class="line">    <span class="keyword">case</span> shapeType.triangle:</span><br><span class="line">      area = <span class="number">.5</span> * options.width * options.height;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getArea(shapeType.triangle, &#123; <span class="attr">width</span>: <span class="number">100</span>, <span class="attr">height</span>: <span class="number">100</span> &#125;);</span><br></pre></td></tr></table></figure></p><h2 id="4、属性名的遍历"><a href="#4、属性名的遍历" class="headerlink" title="4、属性名的遍历"></a>4、属性名的遍历</h2><p>Symbol 作为属性名，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。但是，它也不是私有属性，有一个<code>Object.getOwnPropertySymbols</code>方法，可以获取指定对象的所有 Symbol 属性名。<br>1、<code>Object.getOwnPropertySymbols</code>方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。<br>2、<code>Reflect.ownKeys</code>方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。<br>3、以 Symbol 值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Symbol</span>(<span class="string">'b'</span>);</span><br><span class="line">obj[a] = <span class="string">'Hello'</span>;</span><br><span class="line">obj[b] = <span class="string">'World'</span>;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(obj);  <span class="comment">// [Symbol(a), Symbol(b)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `Reflect.ownKeys`方法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'my_key'</span>)]: <span class="number">1</span>,</span><br><span class="line">  enum: <span class="number">2</span>,</span><br><span class="line">  nonEnum: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj)    <span class="comment">//  ["enum", "nonEnum", Symbol(my_key)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以 Symbol 值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性</span></span><br><span class="line"><span class="keyword">let</span> size = <span class="built_in">Symbol</span>(<span class="string">'size'</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>[size] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  add(item) &#123;</span><br><span class="line">    <span class="keyword">this</span>[<span class="keyword">this</span>[size]] = item;</span><br><span class="line">    <span class="keyword">this</span>[size]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> sizeOf(instance) &#123;</span><br><span class="line">    <span class="keyword">return</span> instance[size];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> x = <span class="keyword">new</span> Collection();</span><br><span class="line">Collection.sizeOf(x) <span class="comment">// 0</span></span><br><span class="line">x.add(<span class="string">'foo'</span>);</span><br><span class="line">Collection.sizeOf(x) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Object</span>.keys(x) <span class="comment">// ['0']</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(x) <span class="comment">// ['0']</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(x) <span class="comment">// [Symbol(size)]</span></span><br></pre></td></tr></table></figure></p><h2 id="5、Symbol-for-Symbol-keyFor"><a href="#5、Symbol-for-Symbol-keyFor" class="headerlink" title="5、Symbol.for/Symbol.keyFor"></a>5、Symbol.for/Symbol.keyFor</h2><p>1、<code>Symbol.for</code>方法重新使用同一个 Symbol 值。<code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。<code>Symbol.for()</code>不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。<br>2、<code>Symbol()</code>写法没有登记机制，所以每次调用都会返回一个不同的值。<br>3、<code>Symbol.for</code>为 Symbol 值登记的名字，是全局环境的，可以在不同的 iframe 或 service worker 中取到同一个值。<br>4、<code>Symbol.keyFor</code>方法返回一个已登记的 Symbol 类型值的key。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>.for(<span class="string">"bar"</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>(<span class="string">"bar"</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、`Symbol.for`为 Symbol 值登记的名字，是全局环境的</span></span><br><span class="line">iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">iframe.src = <span class="built_in">String</span>(<span class="built_in">window</span>.location);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line">iframe.contentWindow.Symbol.for(<span class="string">'foo'</span>) === <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>)  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、`Symbol.keyFor`</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1) <span class="comment">// "foo"</span></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2) <span class="comment">// undefined  变量s2属于未登记的 Symbol 值</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;#1、概述&quot;&gt;1、概述&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2、作为属性名的Symbol&quot;&gt;2、作为属性名的Symbol&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3、消除魔术字符串&quot;&gt;3、消除魔术字符串&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#4、属性名的遍历&quot;&gt;4、属
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6基础知识—Set和Map数据结构</title>
    <link href="http://yoursite.com/2018/10/26/%5BES6%5D%20ES6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2018/10/26/[ES6] ES6基础知识—Set和Map数据结构/</id>
    <published>2018-10-26T02:23:14.000Z</published>
    <updated>2018-10-29T13:04:42.599Z</updated>
    
    <content type="html"><![CDATA[<p><a href="#1、Set">1、Set</a><br><a href="#2、Set实例的属性和方法">2、Set实例的属性和方法</a><br><a href="#"></a><br><a href="#"></a></p><h2 id="1、Set"><a href="#1、Set" class="headerlink" title="1、Set"></a>1、Set</h2><p>1、Set类似于数组，但是成员的值都是唯一的，没有重复的值。<br>2、Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，类似于精确相等运算符（===），<br>主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。<br>3、在 Set 内部，两个NaN是相等。<br>4、由于两个空对象不相等，所以Set 内部视为两个值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]);</span><br><span class="line">[...set]    <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>]);</span><br><span class="line">items.size    <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例三</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(<span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>));</span><br><span class="line">set.size    <span class="comment">// 56</span></span><br></pre></td></tr></table></figure></p><h2 id="2、Set实例的属性和方法"><a href="#2、Set实例的属性和方法" class="headerlink" title="2、Set实例的属性和方法"></a>2、Set实例的属性和方法</h2><p>1、属性<br><code>Set.prototype.constructor</code>：构造函数，默认就是Set函数。<br><code>Set.prototype.size</code>：返回Set实例的成员总数。<br>2、方法<br>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）<br><code>Array.from</code>方法可以将 Set 结构转为数组。</p><p>操作方法（用于操作数据）<br><code>add(value)</code>：添加某个值，返回 Set 结构本身。<br><code>delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。<br><code>has(value)</code>：返回一个布尔值，表示该值是否为Set的成员。<br><code>clear()</code>：清除所有成员，没有返回值。</p><p>遍历方法（用于遍历成员）<br><code>keys()</code>：返回键名的遍历器<br><code>values()</code>：返回键值的遍历器<br><code>entries()</code>：返回键值对的遍历器<br><code>forEach()</code>：使用回调函数遍历每个成员</p><p>3、Set的遍历顺序就是插入顺序<br>4、<code>keys</code>方法、<code>values</code>方法、<code>entries</code>方法返回的都是遍历器对象。<br>由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。<br>5、Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。这意味着，可以省略values方法，直接用for…of循环遍历 Set。<br>6、数组的<code>map</code>和<code>filter</code>方法也可以间接用于 Set。<br>7、使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去除数组重复成员</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedupe</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array));</span><br><span class="line">&#125;</span><br><span class="line">dedupe([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">[...new <span class="built_in">Set</span>([<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>])]; <span class="comment">// [3, 5, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6、数组的`map`和`filter`方法也可以间接用于 Set。</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>([...new <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])].map(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>));  <span class="comment">// 返回Set结构：&#123;2, 4, 6&#125;</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>([...new <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])].filter(<span class="function"><span class="params">x</span> =&gt;</span> (x % <span class="number">2</span>) == <span class="number">0</span>));    <span class="comment">// 返回Set结构：&#123;2, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 7、使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]);</span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b]);  <span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> b.has(x)));  <span class="comment">// set &#123;2, 3&#125;</span></span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> !b.has(x)));  <span class="comment">// Set &#123;1&#125;</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;#1、Set&quot;&gt;1、Set&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2、Set实例的属性和方法&quot;&gt;2、Set实例的属性和方法&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;1、Set&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6基础知识—class类</title>
    <link href="http://yoursite.com/2018/10/25/%5BES6%5D%20ES6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94class%E7%B1%BB/"/>
    <id>http://yoursite.com/2018/10/25/[ES6] ES6基础知识—class类/</id>
    <published>2018-10-25T14:01:41.000Z</published>
    <updated>2018-10-29T13:04:42.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>1、constructor是构造方法，this代表实例对象<br>2、方法之间不需要逗号分隔<br>3、类的数据类型就是函数，类本身就指向构造函数<br>4、类的所有方法都定义在类的prototype属性上<br>5、实例的constructor方法 === 类原型的constructor方法<br>6、类的方法定义在prototype对象上，所以类的新方法可添加在prototype对象上。Object.assign方法可以很方便地一次向类添加多个方法。<br>7、prototype对象的constructor属性，直接指向“类”的本身，这与 ES5 的行为是一致的。<br>8、类的内部所有定义的方法，都是不可枚举的，这与 ES5 的行为是不一致的。<br>9、类的属性名，可以采用表达式。<br>10、类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式<br>11、constructor方法是类的默认方法，如果没有显式定义，一个空的constructor方法会被默认添加。<br>12、constructor 方法默认返回实例对象（即this），完全可以指定返回另外一个对象<br>13、类不存在变量提升（hoist），这一点与 ES5 完全不同，原因与继承有关<br>14、name属性总是返回紧跟在class关键字后面的类名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4、类的所有方法都定义在类的prototype属性上</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">  toString() &#123;&#125;</span><br><span class="line">  toValue() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">Point.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;,</span><br><span class="line">  toString() &#123;&#125;,</span><br><span class="line">  toValue() &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">Point.prototype.constructor === Point <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5、实例的constructor方法 === 类原型的constructor方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line">b.constructor === B.prototype.constructor <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 8、类的内部所有定义的方法，都是不可枚举的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123; &#125;</span><br><span class="line">  toString() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.keys(Point.prototype)  <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Point.prototype)   <span class="comment">// ["constructor","toString"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// toString方法是Point类内部定义的方法，它是不可枚举的。这一点与 ES5 的行为不一致。</span></span><br><span class="line"><span class="keyword">var</span> Point = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;&#125;;</span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.keys(Point.prototype);    <span class="comment">// ["toString"]</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Point.prototype);    <span class="comment">// ["constructor","toString"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 9、类的属性名，可以采用表达式。</span></span><br><span class="line"><span class="keyword">let</span> methodName = <span class="string">'getArea'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;&#125;</span><br><span class="line">  [methodName]() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 14、name属性总是返回紧跟在class关键字后面的类名。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;&#125;</span><br><span class="line">Point.name <span class="comment">// "Point"</span></span><br></pre></td></tr></table></figure><h2 id="2、类的实例对象"><a href="#2、类的实例对象" class="headerlink" title="2、类的实例对象"></a>2、类的实例对象</h2><p>1、实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）；<br>2、类的所有实例共享一个原型对象，与 ES5 一样。<br>3、可以通过实例的<code>__proto__</code>属性为“类”添加方法(必须谨慎，不推荐使用)。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> point = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">point.toString() <span class="comment">// (2, 3)</span></span><br><span class="line">point.hasOwnProperty(<span class="string">'x'</span>) <span class="comment">// true</span></span><br><span class="line">point.hasOwnProperty(<span class="string">'y'</span>) <span class="comment">// true</span></span><br><span class="line">point.hasOwnProperty(<span class="string">'toString'</span>) <span class="comment">// false</span></span><br><span class="line">point.__proto__.hasOwnProperty(<span class="string">'toString'</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Point(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">p1.__proto__ === p2.__proto__; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">p1.__proto__.printName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'Oops'</span> &#125;;</span><br><span class="line">p1.printName() <span class="comment">// "Oops"</span></span><br><span class="line">p2.printName() <span class="comment">// "Oops"</span></span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> Point(<span class="number">4</span>,<span class="number">2</span>);</span><br><span class="line">p3.printName() <span class="comment">// "Oops"</span></span><br></pre></td></tr></table></figure></p><h2 id="3、私有方法和私有属性"><a href="#3、私有方法和私有属性" class="headerlink" title="3、私有方法和私有属性"></a>3、私有方法和私有属性</h2><p>1、在方法前加下划线，表示这是一个只限于内部使用的私有方法。<br>但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。<br>2、将私有方法移出模块。<br>3、利用<code>Symbol</code>值的唯一性，将私有方法的名字命名为一个Symbol值。<br>4、在属性名之前使用<code>#</code>表示.<br>5、私有属性也可以设置 getter 和 setter 方法<br>6、私有属性不限于从this引用，类的实例也可以引用私有属性<br>7、直接从实例上引用私有属性是不可以的，只能在类的定义中引用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 公有方法</span></span><br><span class="line">  foo (baz) &#123;</span><br><span class="line">    <span class="keyword">this</span>._bar(baz);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 私有方法</span></span><br><span class="line">  _bar (baz) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.snaf = baz;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2、将私有方法移出模块；</span></span><br><span class="line">  foo1 (baz) &#123;</span><br><span class="line">    bar.call(<span class="keyword">this</span>, baz);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">baz</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.snaf = baz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、利用`Symbol`值的唯一性</span></span><br><span class="line"><span class="keyword">const</span> bar = <span class="built_in">Symbol</span>(<span class="string">'bar'</span>);</span><br><span class="line"><span class="keyword">const</span> snaf = <span class="built_in">Symbol</span>(<span class="string">'snaf'</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">myClass</span></span>&#123;</span><br><span class="line">  <span class="comment">// 公有方法</span></span><br><span class="line">  foo(baz) &#123;</span><br><span class="line">    <span class="keyword">this</span>[bar](baz);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 私有方法</span></span><br><span class="line">  [bar](baz) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[snaf] = baz;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// bar和snaf都是Symbol值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5、私有属性也可以设置 getter 和 setter 方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">  #xValue = 0;</span><br><span class="line">  get #x() &#123; return #xValue; &#125;</span><br><span class="line">  set #x(value) &#123;</span><br><span class="line">    this.#xValue = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6、私有属性不限于从this引用，类的实例也可以引用私有属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  #privateValue = 42;</span><br><span class="line">  <span class="keyword">static</span> getPrivateValue(foo) &#123;</span><br><span class="line">    return foo.#privateValue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getPrivateValue(<span class="keyword">new</span> Foo()); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure></p><h2 id="4、this-的指向"><a href="#4、this-的指向" class="headerlink" title="4、this 的指向"></a>4、this 的指向</h2><p>1、类的方法内部如果含有this，它默认指向类的实例。但不能单独使用该方法，很可能报错。<br>2、解决办法：在构造方法中绑定this。<br>3、解决办法：使用箭头函数。<br>4、解决办法：使用Proxy，获取方法的时候，自动绑定this。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  printName(name = <span class="string">'there'</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.print(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  print(text) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> logger = <span class="keyword">new</span> Logger();</span><br><span class="line"><span class="keyword">const</span> &#123; printName &#125; = logger;</span><br><span class="line">printName();  <span class="comment">// TypeError: Cannot read property 'print' of undefined</span></span><br><span class="line">logger.printName(); <span class="comment">// Hello there</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、在构造方法中绑定this</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.printName = <span class="keyword">this</span>.printName.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、使用箭头函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.printName = <span class="function">(<span class="params">name = <span class="string">'there'</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.print(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、使用Proxy</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selfish</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">  <span class="keyword">const</span> handler = &#123;</span><br><span class="line">    get (target, key) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = <span class="built_in">Reflect</span>.get(target, key);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!cache.has(value)) &#123;</span><br><span class="line">        cache.set(value, value.bind(target));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> cache.get(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> logger = selfish(<span class="keyword">new</span> Logger());</span><br></pre></td></tr></table></figure></p><h2 id="5、Class-的取值函数（getter）和存值函数（setter）"><a href="#5、Class-的取值函数（getter）和存值函数（setter）" class="headerlink" title="5、Class 的取值函数（getter）和存值函数（setter）"></a>5、Class 的取值函数（getter）和存值函数（setter）</h2><p>在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  get prop() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'getter'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  set prop(value) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setter: '</span>+value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> MyClass();</span><br><span class="line">inst.prop = <span class="number">123</span>;  <span class="comment">// setter: 123</span></span><br><span class="line">inst.prop;   <span class="comment">// 'getter'</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、简介&quot;&gt;&lt;a href=&quot;#1、简介&quot; class=&quot;headerlink&quot; title=&quot;1、简介&quot;&gt;&lt;/a&gt;1、简介&lt;/h2&gt;&lt;p&gt;1、constructor是构造方法，this代表实例对象&lt;br&gt;2、方法之间不需要逗号分隔&lt;br&gt;3、类的数据类型就是函数
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>关于前端异常的捕获</title>
    <link href="http://yoursite.com/2018/10/25/%5BJS%5D%20%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8D%95%E8%8E%B7/"/>
    <id>http://yoursite.com/2018/10/25/[JS] 关于前端异常的捕获/</id>
    <published>2018-10-25T09:47:42.000Z</published>
    <updated>2018-10-29T13:04:42.604Z</updated>
    
    <content type="html"><![CDATA[<p>开发过程中，有不少bug能够逃过各种test、QA、review，最终出现在线上，对于线上bug，如果没有足够的log分析，那会大大增加定位时间。所以不论前后端开发，日志系统都是必不可少的一个环节。前端日志系统不像后端有比较成熟统一的解决方案，对于前端异常日志的处理通常采用前端埋点或其它异常捕获方式收集错误日志，然后提交给服务器持久化。</p><h2 id="收集日志的方法"><a href="#收集日志的方法" class="headerlink" title="收集日志的方法"></a>收集日志的方法</h2><p>js的异常机制并不如其它编译型语言严谨，比如java中对可检查异常需要强制捕获处理，而js代码可能就会在运行时才发现有个异常直接导致线程终止。平时收集日志的手段，可以归类为两个方面，一个是逻辑中的错误判断，为主动判断；一个是利用语言给我们提供的捷径，暴力式获取错误信息，如 try..catch 和 window.onerror。所以在js项目中，更需要对异常捕获机制有统一约定，一般来说基本方法有几种：</p><h3 id="1-直接捕获"><a href="#1-直接捕获" class="headerlink" title="1.直接捕获"></a>1.直接捕获</h3><p>对于很明确的某些达到约定异常条件的（接口返回状态不对，客户端认证异常等），直接捕获提交服务端，在可预测范围内反馈异常并记录，比如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">asyncRequest(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="comment">// 接口返回的数据不在约定范围内，直接捕获提交</span></span><br><span class="line"> <span class="keyword">if</span> (data !== <span class="string">'someValue'</span>) &#123;</span><br><span class="line">   reportToServer(&#123;</span><br><span class="line">     <span class="comment">// error message</span></span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="2-主动判断"><a href="#2-主动判断" class="headerlink" title="2.主动判断"></a>2.主动判断</h3><p>我们在一些运算之后，得到一个期望的结果，然而结果不是我们想要的，这种属于逻辑错误/状态错误的反馈，在接口 status 判断中用的比较多。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// code...</span></span><br><span class="line">  <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(calc() !== <span class="string">"someVal"</span>)&#123;</span><br><span class="line">  Reporter.send(&#123;</span><br><span class="line">    position: <span class="string">"test.js::&lt;Function&gt;calc"</span></span><br><span class="line">    msg: <span class="string">"calc error"</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-try…catch-捕获"><a href="#3-try…catch-捕获" class="headerlink" title="3.try…catch 捕获"></a>3.try…catch 捕获</h3><p>java中如果某段代码可能抛出checked Exception，那么就需要强制在外层加上try…catch，类似于这样的处理机制，js中，在有可能抛出异常的地方，使用try…catch进行异常捕获处理，比如，对于一个有可能为undefined的数组参数arr，常规处理和try..catch方式对比：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// normal</span></span><br><span class="line"><span class="comment">// 会报TypeError: Cannot read property 'length' of undefined错误，并且线程终止</span></span><br><span class="line">doSomething(a.length);</span><br><span class="line">doOtherthings();</span><br><span class="line"><span class="comment">// try...catch</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> doSomething(a.length);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line"> reportToServer(e);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'HaHa, I catch the error'</span>);</span><br><span class="line">&#125;</span><br><span class="line">doOtherthings();</span><br></pre></td></tr></table></figure></p><h3 id="4-window-onerror-window-addEventListener-‘error’"><a href="#4-window-onerror-window-addEventListener-‘error’" class="headerlink" title="4.window.onerror/window.addEventListener(‘error’)"></a>4.window.onerror/window.addEventListener(‘error’)</h3><p>捕获全局错误：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> errInfo = format(<span class="built_in">arguments</span>);</span><br><span class="line">  Reporter.send(errInfo);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在上面的函数中返回 return true，错误便不会暴露到控制台中。下面是它的参数信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125;  errorMessage   错误信息</span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125;  scriptURI      出错的文件</span></span><br><span class="line"><span class="comment"> * @param &#123;Long&#125;    lineNumber     出错代码的行号</span></span><br><span class="line"><span class="comment"> * @param &#123;Long&#125;    columnNumber   出错代码的列号</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125;  errorObj       错误的详细信息，Anything</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">errorMessage, scriptURI, lineNumber,columnNumber,errorObj</span>) </span>&#123; </span><br><span class="line">    <span class="comment">// code..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>window.addEventListener(&#39;error)</code>监听error事件时，只有一个ErrorEvent事件参数，继承自Event，包含以下属性：<br><code>ErrorEvent.message</code>：错误信息<br><code>ErrorEvent.filename</code>：出错文件位置<br><code>ErrorEvent.lineno</code>：出错位置行号<br><code>ErrorEvent.colno</code>：出错位置列号<br><code>ErrorEvent.error</code>：错误详细信息<br>window.onerror 算是一种特别暴力的容错手段，try..catch 也是如此，他们底层的实现就是利用 C/C++ 中的 goto 语句实现，一旦发现错误，不管目前的堆栈有多深，不管代码运行到了何处，直接跑到顶层或者 try..catch 捕获的那一层，这种一脚踢开错误的处理方式并不是很好。</p><h2 id="收集日志存在的问题"><a href="#收集日志存在的问题" class="headerlink" title="收集日志存在的问题"></a>收集日志存在的问题</h2><p>收集日志的目的是为了及时发现问题，最好日志能够告诉我们，错误在哪里，更优秀的做法是，不仅告诉错误在哪里，还告诉我们，如何处理这个错误。终极目标是，发现错误，自动容错，这一步是最难的。</p><h3 id="1-无具体报错信息，Script-error"><a href="#1-无具体报错信息，Script-error" class="headerlink" title="1.无具体报错信息，Script error."></a>1.无具体报错信息，Script error.</h3><p>具体原因 <a href="https://stackoverflow.com/questions/5913978/cryptic-script-error-reported-in-javascript-in-chrome-and-firefox" target="_blank" rel="noopener">可看这里</a>，修改方式为：<br>1、<font color="#d00">在script标签中加入crossorigin属性</font><br><code>&lt;script crossorigin=&quot;anonymous&quot; src=&quot;your.crossorigin.script&quot;&gt;&lt;/script&gt;</code><br>2、<font color="#d00">响应头增加Access-Control-Allow-Origin</font><br><code>Access-Control-Allow-Origin: *</code></p><h3 id="2-上报方式"><a href="#2-上报方式" class="headerlink" title="2.上报方式"></a>2.上报方式</h3><p>常使用的方式有两种：</p><font color="#d00">1、ajax请求上报</font><br><font color="#d00">2、利用img标签的src属性上报(考虑解析性能和多站点服务，更常用的上报方式)</font><p>需要注意的是，尽量避免简单直接的捕获–&gt; 上报这样的流程，可能造成日志量过大、阻塞用户操作等问题。所以一些错误合并、延迟上报、抽样采集还是有必要做的。</p><h2 id="压缩混淆的线上代码"><a href="#压缩混淆的线上代码" class="headerlink" title="压缩混淆的线上代码"></a>压缩混淆的线上代码</h2><p>对于线上经压缩混淆后的代码，即使拿到错误行列信息也很难去代码中定位问题，看到的解决方案有：  </p><p><font color="#d00">生成不同文件配合sourceMap</font></p><p><font color="#d00">后台实现功能：上传源码，选择压缩平台产生对应sourceMap，再通过转换将压缩的行列信息对应到源码的行列信息</font><br>这部分目前缺少实践经验，实践后再补充实现方案。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开发过程中，有不少bug能够逃过各种test、QA、review，最终出现在线上，对于线上bug，如果没有足够的log分析，那会大大增加定位时间。所以不论前后端开发，日志系统都是必不可少的一个环节。前端日志系统不像后端有比较成熟统一的解决方案，对于前端异常日志的处理通常采用
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>macrotasks&amp;microtasks执行顺序总结</title>
    <link href="http://yoursite.com/2018/10/23/%5BJS%5D%20macrotasks&amp;microtasks%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/10/23/[JS] macrotasks&amp;microtasks执行顺序总结/</id>
    <published>2018-10-23T13:15:43.000Z</published>
    <updated>2018-10-30T15:49:20.349Z</updated>
    
    <content type="html"><![CDATA[<p>macrotasks：<br><code>setTimeout</code>，<code>setInterval</code>， <code>setImmediate</code>，<code>requestAnimationFrame</code>, <code>I/O</code>，<code>UI渲染</code><br>microtasks:<br><code>Promise</code>， <code>process.nextTick</code>， <code>Object.observe</code>， <code>MutationObserver</code><br>再简单点可以总结为：</p><ol><li>在 macrotask 队列中执行最早的那个 task ，然后移出</li><li>再执行 microtask 队列中所有可用的任务，然后移出</li><li>下一个循环，执行下一个 macrotask 中的任务 (再跳到第2步)</li></ol><p>任务队列的总结<br>1、一个事件循环有一个或者多个任务队列；<br>2、每个事件循环都有一个microtask队列；<br>3、macrotask队列就是我们常说的任务队列，microtask队列不是任务队列；<br>4、一个任务可以被放入到macrotask队列，也可以放入microtask队列；<br>5、当一个任务被放入microtask或者macrotask队列后，准备工作就已经结束，这时候可以开始执行任务了。</p><p>microtasks 的作用是用来调度应在当前执行的脚本执行结束后立即执行的任务。例如响应事件、或者异步操作，以避免付出额外的一个task的费用。<br>microtask会在两种情况下执行：<br>任务队列(macrotask = task queue)回调后执行，前提条件是当前没有其他执行中的代码。每个task末尾执行。<br>另外在处理microtask期间，如果有新添加的microtasks，也会被添加到队列的末尾并执行。</p><p>也就是说执行顺序是：<br>开始 -&gt; 取task queue第一个task执行 -&gt; 取microtask全部任务依次执行 -&gt; 取task queue下一个任务执行 -&gt; 再次取出microtask全部任务执行 -&gt; … 这样循环往复<br>Promise一旦状态置为完成态，便为其回调(.then内的函数)安排一个microtask。<br>Promise是一个立即执行函数，但是其是否成功（或失败：reject）的回调函数resolve却是一个异步执行的回调。<br>当执行到resolve()时，这个任务会被放入到回调队列中，等待调用栈有空闲时事件循环再来取走它。</p><p>HTML5中规定setTimeout的最小时间延迟是4ms，也就是说理想环境下异步回调最快也是4ms才能触发。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">100000</span> ; i&gt;<span class="number">0</span> ; i-- )&#123;</span><br><span class="line">        i==<span class="number">1</span> &amp;&amp; resolve()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 3 5 4 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 当运行到setTimeout时，会把setTimeout的回调函数console.log(1)放到任务队列里去，然后继续向下执行。</span></span><br><span class="line"><span class="comment">// 2. 接下来会遇到一个Promise。首先执行打印console.log(2)，然后执行for循环，即时for循环要累加到10万，也是在执行栈里面，等待for循环执行完毕以后，将Promise的状态从fulfilled切换到resolve，随后把要执行的回调函数，也就是then里面的console.log(4)推到microtask里面去。接下来马上执行马上console.log(3)。</span></span><br><span class="line"><span class="comment">// 3. 然后出Promise，还剩一个同步的console.log(5)，直接打印。这样第一轮下来，已经依次打印了2，3，5。</span></span><br><span class="line"><span class="comment">// 4. 现在第一轮任务队列已经执行完毕，没有正在执行的代码。符合上面讲的microtask执行条件，因此会将microtask中的任务优先执行，因此执行console.log(4);</span></span><br><span class="line"><span class="comment">// 5. 最后还剩macrotask里的setTimeout放入的函数console.log(1)最后执行。</span></span><br></pre></td></tr></table></figure><font color="#d00"><br>当一个程序有：<code>setTimeout</code>， <code>setInterval</code>，<code>setImmediate</code>， <code>I/O</code>， <code>UI渲染</code>，<code>Promise</code>，<code>process.nextTick</code>， <code>Object.observe</code>， <code>MutationObserver</code>的时候：<br>1. 先执行 macrotasks：I/O –&gt; UI渲染<br>2. 再执行 microtasks ：process.nextTick –&gt; Promise –&gt; MutationObserver –&gt; Object.observe<br>3. 再把setTimeout setInterval setImmediate 塞入一个新的macrotasks，依次：<br>setImmediate –&gt; setTimeout ，setInterval<br><br>综上，nextTick的目的就是产生一个回调函数加入task或者microtask中，当前栈执行完以后（可能中间还有别的排在前面的函数）调用该回调函数，起到了异步触发（即下一个tick时触发）的目的。<br></font><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    resolve();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">8</span>);</span><br><span class="line"><span class="comment">// 结果是：3 4 6 8 7 5 1 2</span></span><br></pre></td></tr></table></figure><p>还有acync和await</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;macrotasks：&lt;br&gt;&lt;code&gt;setTimeout&lt;/code&gt;，&lt;code&gt;setInterval&lt;/code&gt;， &lt;code&gt;setImmediate&lt;/code&gt;，&lt;code&gt;requestAnimationFrame&lt;/code&gt;, &lt;code&gt;I/O&lt;
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>webpack流程</title>
    <link href="http://yoursite.com/2018/10/20/%5B%E6%9E%84%E5%BB%BA%5D%20webpack%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/10/20/[构建] webpack流程/</id>
    <published>2018-10-20T14:49:14.000Z</published>
    <updated>2018-10-20T15:40:37.077Z</updated>
    
    <content type="html"><![CDATA[<h2 id="流程概括"><a href="#流程概括" class="headerlink" title="流程概括"></a>流程概括</h2><p>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p><p>1、<code>初始化参数</code>：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；<br>2、<code>开始编译</code>：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；<br>3、<code>确定入口</code>：根据配置中的 entry 找出所有的入口文件；<br>4、<code>编译模块</code>：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；<br>5、<code>完成模块编译</code>：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；<br>6、<code>输出资源</code>：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；<br>7、<code>输出完成</code>：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</p><p>在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</p><h2 id="流程细节"><a href="#流程细节" class="headerlink" title="流程细节"></a>流程细节</h2><p>Webpack 的构建流程可以分为以下三大阶段：<br>1、<code>初始化</code>：启动构建，读取与合并配置参数，加载 <code>Plugin</code>，实例化<code>Compiler</code>。<br>2、<code>编译</code>：从 <code>Entry</code> 发出，针对每个 <code>Module</code> 串行调用对应的 <code>Loader</code> 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理。<br>3、<code>输出</code>：对编译后的 Module 组合成 <code>Chunk</code>，把 Chunk 转换成文件，输出到文件系统。</p><p>在每个大阶段中又会发生很多事件，Webpack 会把这些事件广播出来供给 Plugin 使用，下面来一一介绍。</p><h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><table><thead><tr><th>事件名</th><th>解释</th></tr></thead><tbody><tr><td>初始化参数</td><td>从配置文件和 Shell 语句中读取与合并参数，得出最终的参数。 这个过程中还会执行配置文件中的插件实例化语句 <code>new Plugin()</code>。</td></tr><tr><td>实例化 <code>Compiler</code></td><td>用上一步得到的参数初始化 <code>Compiler</code> 实例，<code>Compiler</code> 负责文件监听和启动编译。<code>Compiler</code> 实例中包含了完整的 Webpack 配置，全局只有一个 <code>Compiler</code> 实例。</td></tr><tr><td>加载插件</td><td>依次调用插件的 <code>apply</code> 方法，让插件可以监听后续的所有事件节点。同时给插件传入 <code>compiler</code> 实例的引用，以方便插件通过 <code>compiler</code> 调用 Webpack 提供的 API。</td></tr><tr><td><code>environment</code></td><td>开始应用 Node.js 风格的文件系统到 <code>compiler</code> 对象，以方便后续的文件寻找和读取。</td></tr><tr><td><code>entry-option</code></td><td>读取配置的 <code>Entrys</code>，为每个 <code>Entry</code> 实例化一个对应的 <code>EntryPlugin</code>，为后面该 <code>Entry</code> 的递归解析工作做准备。</td></tr><tr><td><code>after-plugins</code></td><td>调用完所有内置的和配置的插件的 <code>apply</code> 方法。</td></tr><tr><td><code>after-resolvers</code></td><td>根据配置初始化完 <code>resolver</code>，<code>resolver</code>负责在文件系统中寻找指定路径的文件。</td></tr></tbody></table><h3 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h3><table><thead><tr><th>事件名</th><th>解释</th></tr></thead><tbody><tr><td><code>run</code></td><td>启动一次新的编译。</td></tr><tr><td><code>watch-run</code></td><td>和 run 类似，区别在于它是在监听模式下启动的编译，在这个事件中可以获取到是哪些文件发生了变化导致重新启动一次新的编译。</td></tr><tr><td><code>compile</code></td><td>该事件是为了告诉插件一次新的编译将要启动，同时会给插件带上 compiler 对象。</td></tr><tr><td><code>compilation</code></td><td>当 Webpack 以开发模式运行时，每当检测到文件变化，一次新的 <code>Compilation</code> 将被创建。一个 <code>Compilation</code> 对象包含了当前的模块资源、编译生成资源、变化的文件等。<code>Compilation</code> 对象也提供了很多事件回调供插件做扩展。</td></tr><tr><td><code>make</code></td><td>一个新的 <code>Compilation</code> 创建完毕，即将从 <code>Entry</code> 开始读取文件，根据文件类型和配置的 Loader 对文件进行编译，编译完后再找出该文件依赖的文件，递归的编译和解析。</td></tr><tr><td><code>after-compile</code></td><td>一次 Compilation 执行完成。</td></tr><tr><td><code>invalid</code></td><td>当遇到文件不存在、文件编译错误等异常时会触发该事件，该事件不会导致 Webpack 退出。</td></tr></tbody></table><p>在编译阶段中，最重要的要数 compilation 事件了，因为在 compilation 阶段调用了 Loader 完成了每个模块的转换操作，在 compilation 阶段又包括很多小的事件，它们分别是：</p><table><thead><tr><th>事件名</th><th>解释</th></tr></thead><tbody><tr><td><code>build-module</code></td><td>使用对应的 Loader 去转换一个模块。</td></tr><tr><td><code>normal-module-loader</code></td><td>在用 Loader 对一个模块转换完后，使用 acorn 解析转换后的内容，输出对应的抽象语法树（AST），以方便 Webpack 后面对代码的分析。</td></tr><tr><td><code>program</code></td><td>从配置的入口模块开始，分析其 AST，当遇到 require 等导入其它模块语句时，便将其加入到依赖的模块列表，同时对新找出的依赖模块递归分析，最终搞清所有模块的依赖关系。</td></tr><tr><td><code>seal</code></td><td>所有模块及其依赖的模块都通过 Loader 转换完成后，根据依赖关系开始生成 Chunk。</td></tr></tbody></table><h3 id="输出阶段"><a href="#输出阶段" class="headerlink" title="输出阶段"></a>输出阶段</h3><table><thead><tr><th>事件名</th><th>解释</th></tr></thead><tbody><tr><td><code>should-emit</code></td><td>所有需要输出的文件已经生成好，询问插件哪些文件需要输出，哪些不需要。</td></tr><tr><td><code>emit</code></td><td>确定好要输出哪些文件后，执行文件输出，可以在这里获取和修改输出内容。</td></tr><tr><td><code>after-emit</code></td><td>文件输出完毕。</td></tr><tr><td><code>done</code></td><td>成功完成一次完成的编译和输出流程。</td></tr><tr><td><code>failed</code></td><td>如果在编译和输出流程中遇到异常导致 Webpack 退出时，就会直接跳转到本步骤，插件可以在本事件中获取到具体的错误原因。</td></tr></tbody></table><h2 id="输出文件分析"><a href="#输出文件分析" class="headerlink" title="输出文件分析"></a>输出文件分析</h2><p>bundle.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line">    <span class="comment">// webpackBootstrap 启动函数</span></span><br><span class="line">    <span class="comment">// modules 即为存放所有模块的数组，数组中的每一个元素都是一个函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">modules</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 安装过的模块都存放在这里面</span></span><br><span class="line">        <span class="comment">// 作用是把已经加载过的模块缓存在内存中，提升性能</span></span><br><span class="line">        <span class="keyword">var</span> installedModules = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去数组中加载一个模块，moduleId 为要加载模块在数组中的 index</span></span><br><span class="line">        <span class="comment">// 作用和 Node.js 中 require 语句相似</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 如果需要加载的模块已经被加载过，就直接从内存缓存中返回</span></span><br><span class="line">            <span class="keyword">if</span> (installedModules[moduleId]) &#123;</span><br><span class="line">                <span class="keyword">return</span> installedModules[moduleId].exports;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果缓存中不存在需要加载的模块，就新建一个模块，并把它存在缓存中</span></span><br><span class="line">            <span class="keyword">var</span> <span class="built_in">module</span> = installedModules[moduleId] = &#123;</span><br><span class="line">                <span class="comment">// 模块在数组中的 index</span></span><br><span class="line">                i: moduleId,</span><br><span class="line">                <span class="comment">// 该模块是否已经加载完毕</span></span><br><span class="line">                l: <span class="literal">false</span>,</span><br><span class="line">                <span class="comment">// 该模块的导出值</span></span><br><span class="line">                exports: &#123;&#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从 modules 中获取 index 为 moduleId 的模块对应的函数</span></span><br><span class="line">            <span class="comment">// 再调用这个函数，同时把函数需要的参数传入</span></span><br><span class="line">            modules[moduleId].call(<span class="built_in">module</span>.exports, <span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line">            <span class="comment">// 把这个模块标记为已加载</span></span><br><span class="line">            <span class="built_in">module</span>.l = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 返回这个模块的导出值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Webpack 配置中的 publicPath，用于加载被分割出去的异步代码</span></span><br><span class="line">        __webpack_require__.p = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 __webpack_require__ 去加载 index 为 0 的模块，并且返回该模块导出的内容</span></span><br><span class="line">        <span class="comment">// index 为 0 的模块就是 main.js 对应的文件，也就是执行入口模块</span></span><br><span class="line">        <span class="comment">// __webpack_require__.s 的含义是启动模块对应的 index</span></span><br><span class="line">        <span class="keyword">return</span> __webpack_require__(__webpack_require__.s = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;)(</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有的模块都存放在了一个数组里，根据每个模块在数组的 index 来区分和定位模块</span></span><br><span class="line">    [</span><br><span class="line">        <span class="comment">/* 0 */</span></span><br><span class="line">        (<span class="function"><span class="keyword">function</span> (<span class="params">module, exports, __webpack_require__</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 通过 __webpack_require__ 规范导入 show 函数，show.js 对应的模块 index 为 1</span></span><br><span class="line">            <span class="keyword">const</span> show = __webpack_require__(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 执行 show 函数</span></span><br><span class="line">            show(<span class="string">'Webpack'</span>);</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="comment">/* 1 */</span></span><br><span class="line">        (<span class="function"><span class="keyword">function</span> (<span class="params">module, exports</span>) </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">window</span>.document.getElementById(<span class="string">'app'</span>).innerText = <span class="string">'Hello,'</span> + content;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 通过 CommonJS 规范导出 show 函数</span></span><br><span class="line">            <span class="built_in">module</span>.exports = show;</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>以上看上去复杂的代码其实是一个立即执行函数，可以简写为如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模拟 require 语句</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行存放所有模块数组中的第0个模块</span></span><br><span class="line">  __webpack_require__(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;)([<span class="comment">/*存放所有模块的数组*/</span>])</span><br></pre></td></tr></table></figure></p><p>bundle.js 能直接运行在浏览器中的原因在于输出的文件中通过 <code>__webpack_require__</code> 函数定义了一个可以在浏览器中执行的加载函数来模拟 Node.js 中的 require 语句。</p><p>原来一个个独立的模块文件被合并到了一个单独的 bundle.js 的原因在于浏览器不能像 Node.js 那样快速地去本地加载一个个模块文件，而必须通过网络请求去加载还未得到的文件。<br>如果模块数量很多，加载时间会很长，因此把所有模块都存放在了数组中，执行一次网络加载。</p><p>如果仔细分析 _<code>_webpack_require__</code> 函数的实现，还有发现 Webpack 做了缓存优化： <strong>执行加载过的模块不会再执行第二次，执行结果会缓存在内存中，当某个模块第二次被访问时会直接去内存中读取被缓存的返回值。</strong></p><h3 id="分割代码时的输出"><a href="#分割代码时的输出" class="headerlink" title="分割代码时的输出"></a>分割代码时的输出</h3><p>把源码中的 main.js 修改为如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步加载 show.js</span></span><br><span class="line"><span class="keyword">import</span>(<span class="string">'./show'</span>).then(<span class="function">(<span class="params">show</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 执行 show 函数</span></span><br><span class="line">  show(<span class="string">'Webpack'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>重新构建后会输出两个文件，分别是执行入口文件 bundle.js 和 异步加载文件 0.bundle.js。</p><p>其中 0.bundle.js 内容如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载在本文件(0.bundle.js)中包含的模块</span></span><br><span class="line">webpackJsonp(</span><br><span class="line">  <span class="comment">// 在其它文件中存放着的模块的 ID</span></span><br><span class="line">  [<span class="number">0</span>],</span><br><span class="line">  <span class="comment">// 本文件所包含的模块</span></span><br><span class="line">  [</span><br><span class="line">    <span class="comment">// show.js 所对应的模块</span></span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">module, exports</span>) </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">window</span>.document.getElementById(<span class="string">'app'</span>).innerText = <span class="string">'Hello,'</span> + content;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">module</span>.exports = show;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>bundle.js 内容如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">modules</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/***</span></span><br><span class="line"><span class="comment">   * webpackJsonp 用于从异步加载的文件中安装模块。</span></span><br><span class="line"><span class="comment">   * 把 webpackJsonp 挂载到全局是为了方便在其它文件中调用。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param chunkIds 异步加载的文件中存放的需要安装的模块对应的 Chunk ID</span></span><br><span class="line"><span class="comment">   * @param moreModules 异步加载的文件中存放的需要安装的模块列表</span></span><br><span class="line"><span class="comment">   * @param executeModules 在异步加载的文件中存放的需要安装的模块都安装成功后，需要执行的模块对应的 index</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="built_in">window</span>[<span class="string">"webpackJsonp"</span>] = <span class="function"><span class="keyword">function</span> <span class="title">webpackJsonpCallback</span>(<span class="params">chunkIds, moreModules, executeModules</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 把 moreModules 添加到 modules 对象中</span></span><br><span class="line">    <span class="comment">// 把所有 chunkIds 对应的模块都标记成已经加载成功 </span></span><br><span class="line">    <span class="keyword">var</span> moduleId, chunkId, i = <span class="number">0</span>, resolves = [], result;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; chunkIds.length; i++) &#123;</span><br><span class="line">      chunkId = chunkIds[i];</span><br><span class="line">      <span class="keyword">if</span> (installedChunks[chunkId]) &#123;</span><br><span class="line">        resolves.push(installedChunks[chunkId][<span class="number">0</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">      installedChunks[chunkId] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (moduleId <span class="keyword">in</span> moreModules) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(moreModules, moduleId)) &#123;</span><br><span class="line">        modules[moduleId] = moreModules[moduleId];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (resolves.length) &#123;</span><br><span class="line">      resolves.shift()();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 缓存已经安装的模块</span></span><br><span class="line">  <span class="keyword">var</span> installedModules = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储每个 Chunk 的加载状态；</span></span><br><span class="line">  <span class="comment">// 键为 Chunk 的 ID，值为0代表已经加载成功</span></span><br><span class="line">  <span class="keyword">var</span> installedChunks = &#123;</span><br><span class="line">    <span class="number">1</span>: <span class="number">0</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模拟 require 语句，和上面介绍的一致</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ... 省略和上面一样的内容</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 用于加载被分割出去的，需要异步加载的 Chunk 对应的文件</span></span><br><span class="line"><span class="comment">   * @param chunkId 需要异步加载的 Chunk 对应的 ID</span></span><br><span class="line"><span class="comment">   * @returns &#123;Promise&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  __webpack_require__.e = <span class="function"><span class="keyword">function</span> <span class="title">requireEnsure</span>(<span class="params">chunkId</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 从上面定义的 installedChunks 中获取 chunkId 对应的 Chunk 的加载状态</span></span><br><span class="line">    <span class="keyword">var</span> installedChunkData = installedChunks[chunkId];</span><br><span class="line">    <span class="comment">// 如果加载状态为0表示该 Chunk 已经加载成功了，直接返回 resolve Promise</span></span><br><span class="line">    <span class="keyword">if</span> (installedChunkData === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        resolve();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// installedChunkData 不为空且不为0表示该 Chunk 正在网络加载中</span></span><br><span class="line">    <span class="keyword">if</span> (installedChunkData) &#123;</span><br><span class="line">      <span class="comment">// 返回存放在 installedChunkData 数组中的 Promise 对象</span></span><br><span class="line">      <span class="keyword">return</span> installedChunkData[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// installedChunkData 为空，表示该 Chunk 还没有加载过，去加载该 Chunk 对应的文件</span></span><br><span class="line">    <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      installedChunkData = installedChunks[chunkId] = [resolve, reject];</span><br><span class="line">    &#125;);</span><br><span class="line">    installedChunkData[<span class="number">2</span>] = promise;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 DOM 操作，往 HTML head 中插入一个 script 标签去异步加载 Chunk 对应的 JavaScript 文件</span></span><br><span class="line">    <span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">    script.charset = <span class="string">'utf-8'</span>;</span><br><span class="line">    script.async = <span class="literal">true</span>;</span><br><span class="line">    script.timeout = <span class="number">120000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件的路径为配置的 publicPath、chunkId 拼接而成</span></span><br><span class="line">    script.src = __webpack_require__.p + <span class="string">""</span> + chunkId + <span class="string">".bundle.js"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置异步加载的最长超时时间</span></span><br><span class="line">    <span class="keyword">var</span> timeout = setTimeout(onScriptComplete, <span class="number">120000</span>);</span><br><span class="line">    script.onerror = script.onload = onScriptComplete;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 script 加载和执行完成时回调</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onScriptComplete</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 防止内存泄露</span></span><br><span class="line">      script.onerror = script.onload = <span class="literal">null</span>;</span><br><span class="line">      clearTimeout(timeout);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 去检查 chunkId 对应的 Chunk 是否安装成功，安装成功时才会存在于 installedChunks 中</span></span><br><span class="line">      <span class="keyword">var</span> chunk = installedChunks[chunkId];</span><br><span class="line">      <span class="keyword">if</span> (chunk !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chunk) &#123;</span><br><span class="line">          chunk[<span class="number">1</span>](<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Loading chunk '</span> + chunkId + <span class="string">' failed.'</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        installedChunks[chunkId] = <span class="literal">undefined</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    head.appendChild(script);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载并执行入口模块，和上面介绍的一致</span></span><br><span class="line">  <span class="keyword">return</span> __webpack_require__(__webpack_require__.s = <span class="number">0</span>);</span><br><span class="line">&#125;)</span><br><span class="line">(</span><br><span class="line">  <span class="comment">// 存放所有没有经过异步加载的，随着执行入口文件加载的模块</span></span><br><span class="line">  [</span><br><span class="line">    <span class="comment">// main.js 对应的模块</span></span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">module, exports, __webpack_require__</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 通过 __webpack_require__.e 去异步加载 show.js 对应的 Chunk</span></span><br><span class="line">      __webpack_require__.e(<span class="number">0</span>).then(__webpack_require__.bind(<span class="literal">null</span>, <span class="number">1</span>)).then(<span class="function">(<span class="params">show</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 执行 show 函数</span></span><br><span class="line">        show(<span class="string">'Webpack'</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>这里的 bundle.js 和上面所讲的 bundle.js 非常相似，区别在于：<br>1、多了一个 <code>__webpack_require__.e</code> 用于加载被分割出去的，需要异步加载的 Chunk 对应的文件;<br>2、多了一个 <code>webpackJsonp</code> 函数用于从异步加载的文件中安装模块。</p><p>在使用了 CommonsChunkPlugin 去提取公共代码时输出的文件和使用了异步加载时输出的文件是一样的，都会有 <strong>webpack_require</strong>.e 和 webpackJsonp。 原因在于提取公共代码和异步加载本质上都是代码分割。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;流程概括&quot;&gt;&lt;a href=&quot;#流程概括&quot; class=&quot;headerlink&quot; title=&quot;流程概括&quot;&gt;&lt;/a&gt;流程概括&lt;/h2&gt;&lt;p&gt;Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：&lt;/p&gt;
&lt;p&gt;1、&lt;code&gt;初始化参数&lt;/c
      
    
    </summary>
    
      <category term="构建" scheme="http://yoursite.com/categories/%E6%9E%84%E5%BB%BA/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>vue官网阅读</title>
    <link href="http://yoursite.com/2018/10/19/%5BVue%5D%20Vue%E5%AE%98%E7%BD%91/"/>
    <id>http://yoursite.com/2018/10/19/[Vue] Vue官网/</id>
    <published>2018-10-19T08:38:36.000Z</published>
    <updated>2018-10-29T13:04:42.606Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Vue实例"><a href="#一、Vue实例" class="headerlink" title="一、Vue实例"></a>一、Vue实例</h2><p>只有当实例被创建时 data 中存在的属性才是响应式的。<br>vm.b = ‘hi’;  // 对 b 的改动将不会触发任何视图的更新。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: data</span><br><span class="line">&#125;);</span><br><span class="line">vm.a == data.a <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="comment">// 设置属性也会影响到原始数据</span></span><br><span class="line">vm.a = <span class="number">2</span></span><br><span class="line">data.a <span class="comment">// =&gt; 2</span></span><br><span class="line"><span class="comment">// 反之亦然</span></span><br><span class="line">data.a = <span class="number">3</span></span><br><span class="line">vm.a <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure></p><p><code>Object.freeze()</code>会阻止修改现有的属性，也意味着响应系统无法再追踪变化。</p><h4 id="实例提供的属性和方法"><a href="#实例提供的属性和方法" class="headerlink" title="实例提供的属性和方法"></a>实例提供的属性和方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example'</span>,</span><br><span class="line">  data: data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.$data === data <span class="comment">// =&gt; true</span></span><br><span class="line">vm.$el === <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>) <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// $watch 是一个实例方法</span></span><br><span class="line">vm.$watch(<span class="string">'a'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">newValue, oldValue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这个回调将在 `vm.a` 改变后调用</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="二、模板语法-修饰符"><a href="#二、模板语法-修饰符" class="headerlink" title="二、模板语法 - 修饰符"></a>二、模板语法 - 修饰符</h2><p>修饰符 (Modifiers) 是以半角句号 <code>.</code> 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。<br>例如，<code>.prevent</code> 修饰符告诉 <code>v-on</code> 指令对于触发的事件调用 <code>event.preventDefault()</code>：</p><form v-on:submit.prevent="onSubmit">…</form><h2 id="三、计算属性和侦听器"><a href="#三、计算属性和侦听器" class="headerlink" title="三、计算属性和侦听器"></a>三、计算属性和侦听器</h2><h4 id="1、计算属性缓存computed-vs-方法methods"><a href="#1、计算属性缓存computed-vs-方法methods" class="headerlink" title="1、计算属性缓存computed vs 方法methods"></a>1、计算属性缓存computed vs 方法methods</h4><p>可以将同一函数定义为一个方法methods而不是一个计算属性computed。两种方式的最终结果确实是完全相同的。<br>然而，不同的是<code>计算属性是基于它们的依赖进行缓存的</code>，只在相关依赖发生改变时它们才会重新求值。</p><h4 id="2、计算属性computed-vs-侦听属性watch"><a href="#2、计算属性computed-vs-侦听属性watch" class="headerlink" title="2、计算属性computed vs 侦听属性watch"></a>2、计算属性computed vs 侦听属性watch</h4><h4 id="计算属性的-setter"><a href="#计算属性的-setter" class="headerlink" title="计算属性的 setter"></a>计算属性的 setter</h4><p>计算属性默认只有 getter ，不过在需要时也可以提供一个 setter ：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> names = newValue.split(<span class="string">' '</span>)</span><br><span class="line">      <span class="keyword">this</span>.firstName = names[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">this</span>.lastName = names[names.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></p><p>现在再运行 <code>vm.fullName = &#39;John Doe&#39;</code> 时，<code>setter</code> 会被调用，<code>vm.firstName</code> 和 <code>vm.lastName</code> 也会相应地被更新。</p><h4 id="3、侦听器watch"><a href="#3、侦听器watch" class="headerlink" title="3、侦听器watch"></a>3、侦听器watch</h4><p>当需要在数据变化时执行异步或开销较大的操作时，<code>侦听器</code>最有用的<br><a href="https://cn.vuejs.org/v2/guide/computed.html#%E4%BE%A6%E5%90%AC%E5%99%A8" target="_blank" rel="noopener">查看官网demo</a></p><h2 id="四、Class与Style绑定"><a href="#四、Class与Style绑定" class="headerlink" title="四、Class与Style绑定"></a>四、Class与Style绑定</h2><h4 id="1、绑定-HTML-Class-对象语法"><a href="#1、绑定-HTML-Class-对象语法" class="headerlink" title="1、绑定 HTML Class - 对象语法"></a>1、绑定 HTML Class - 对象语法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"static"</span> v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"&#123; active: isActive, 'text-danger': hasError &#125;"</span>&gt; <span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  isActive: <span class="literal">true</span>,</span><br><span class="line">  hasError: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"classObject"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  classObject: &#123;</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">'text-danger'</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法三</span></span><br><span class="line">data: &#123;</span><br><span class="line">  isActive: <span class="literal">true</span>,</span><br><span class="line">  error: <span class="literal">null</span></span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  classObject: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      active: <span class="keyword">this</span>.isActive &amp;&amp; !<span class="keyword">this</span>.error,</span><br><span class="line">      <span class="string">'text-danger'</span>: <span class="keyword">this</span>.error &amp;&amp; <span class="keyword">this</span>.error.type === <span class="string">'fatal'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、绑定-HTML-Class-数组语法"><a href="#2、绑定-HTML-Class-数组语法" class="headerlink" title="2、绑定 HTML Class - 数组语法"></a>2、绑定 HTML Class - 数组语法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"[activeClass, errorClass]"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  activeClass: <span class="string">'active'</span>,</span><br><span class="line">  errorClass: <span class="string">'text-danger'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染结果为：</span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"active text-danger"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="3、绑定-HTML-Class-用在组件上"><a href="#3、绑定-HTML-Class-用在组件上" class="headerlink" title="3、绑定 HTML Class - 用在组件上"></a>3、绑定 HTML Class - 用在组件上</h4><p>当在一个自定义组件上使用 class 属性时，这些类将被添加到该组件的根元素上面。这个元素上已经存在的类不会被覆盖。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义组件</span></span><br><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;p class="foo bar"&gt;Hi&lt;/p&gt;'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件的引用</span></span><br><span class="line">&lt;my-component <span class="class"><span class="keyword">class</span></span>=<span class="string">"baz boo"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// HTML 将被渲染为:</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"foo bar baz boo"</span>&gt;</span>Hi<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><h2 id="五、条件渲染-v-if-vs-v-show"><a href="#五、条件渲染-v-if-vs-v-show" class="headerlink" title="五、条件渲染 - v-if vs v-show"></a>五、条件渲染 - v-if vs v-show</h2><p><code>v-if</code> 是惰性的：如果在初始渲染时条件为假，则什么也不做，直到条件第一次变为真时，才会开始渲染条件块。<br><code>v-show</code> 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p><font color="#d00">v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。</font><br><font color="#d00">因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。</font><h2 id="六、列表渲染"><a href="#六、列表渲染" class="headerlink" title="六、列表渲染"></a>六、列表渲染</h2><h3 id="1、v-if-v-show"><a href="#1、v-if-v-show" class="headerlink" title="1、v-if/v-show"></a>1、v-if/v-show</h3><p><code>变异方法</code>：会改变被这些方法调用的原始数组。push(), pop(), shift(), unshift(), splice(), sort(), reverse()。<br><code>非变异方法</code>，例如：filter(), concat() 和 slice() 。这些不会改变原始数组，但总是返回一个新数组。</p><font color="#d00">注意事项：</font><br>由于 JavaScript 的限制，Vue 不能检测以下变动的数组：<br>1、利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue；<br>2、修改数组的长度时，例如：vm.items.length = newLength；<br><font color="#d00">解决第一类问题：</font><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue.set</span></span><br><span class="line">Vue.set(vm.items, indexOfItem, newValue);</span><br><span class="line"><span class="comment">// 也可以使用 vm.$set 实例方法，该方法是全局方法 Vue.set 的一个别名：</span></span><br><span class="line">vm.$set(vm.items, indexOfItem, newValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.prototype.splice</span></span><br><span class="line">vm.items.splice(indexOfItem, <span class="number">1</span>, newValue);</span><br></pre></td></tr></table></figure><br><br><font color="#d00">解决第二类问题：</font><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.items.splice(newLength)</span><br></pre></td></tr></table></figure><br><br>### 2、对象更改检测注意事项<br>由于 JS 的限制，Vue 不能检测对象属性的添加或删除。<br>可以使用 <code>Vue.set(object, key, value)</code> 方法向嵌套对象添加响应式属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    userProfile: &#123;</span><br><span class="line">      name: <span class="string">'Anika'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Vue.set(vm.userProfile, <span class="string">'age'</span>, <span class="number">27</span>);</span><br><span class="line">vm.$set(vm.userProfile, <span class="string">'age'</span>, <span class="number">27</span>);</span><br></pre></td></tr></table></figure><br><br>可能需要为已有对象赋予多个新属性，比如使用 <code>Object.assign()</code> 或 <code>_.extend()</code>。<br>在这种情况下，你应该用两个对象的属性创建一个新的对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vm.userProfile = <span class="built_in">Object</span>.assign(&#123;&#125;, vm.userProfile, &#123;</span><br><span class="line">  age: <span class="number">27</span>,</span><br><span class="line">  favoriteColor: <span class="string">'Vue Green'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br><br>### 3、v-for with v-if<br><font color="#d00">当它们处于同一节点，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。</font><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-<span class="keyword">for</span>=<span class="string">"todo in todos"</span> v-<span class="keyword">if</span>=<span class="string">"!todo.isComplete"</span>&gt;</span><br><span class="line">  &#123;&#123; todo &#125;&#125;</span><br><span class="line">&lt;<span class="regexp">/li&gt;</span></span><br></pre></td></tr></table></figure><br><br>### 4、一个组件的 v-for<br>is=”todo-item” 属性。这种做法在使用 DOM 模板时是十分必要的，<br>因为在 <code>&lt;ul&gt;</code> 元素内只有 <code>&lt;li&gt;</code> 元素会被看作有效内容。这样做实现的效果与 <code>&lt;todo-item&gt;</code> 相同，但是可以避开一些潜在的浏览器解析错误。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li</span><br><span class="line">    is=<span class="string">"todo-item"</span></span><br><span class="line">    v-<span class="keyword">for</span>=<span class="string">"(todo, index) in todos"</span></span><br><span class="line">    v-bind:key=<span class="string">"todo.id"</span></span><br><span class="line">    v-bind:title=<span class="string">"todo.title"</span></span><br><span class="line">    v-on:remove=<span class="string">"todos.splice(index, 1)"</span></span><br><span class="line">  &gt;<span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/ul&gt;</span></span><br></pre></td></tr></table></figure><br><br>## 七、事件处理<br>有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 <code>$event</code> 把它传入方法<br><br>### 1、事件修饰符<br><code>.stop</code>、<code>.prevent</code>、<code>.capture</code>、<code>.self</code>、<code>.once</code>、<code>.passive</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阻止单击事件继续传播</span></span><br><span class="line">&lt;a v-on:click.stop=<span class="string">"doThis"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交事件不再重载页面</span></span><br><span class="line">&lt;form v-on:submit.prevent=<span class="string">"onSubmit"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修饰符可以串联</span></span><br><span class="line">&lt;a v-on:click.stop.prevent=<span class="string">"doThat"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有修饰符</span></span><br><span class="line">&lt;form v-on:submit.prevent&gt;<span class="xml"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加事件监听器时使用事件捕获模式</span></span><br><span class="line"><span class="comment">// 即元素自身触发的事件先在此处理，然后才交由内部元素进行处理</span></span><br><span class="line">&lt;div v-on:click.capture=<span class="string">"doThis"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只当在 event.target 是当前元素自身时触发处理函数</span></span><br><span class="line"><span class="comment">// 即事件不是从内部元素触发的</span></span><br><span class="line">&lt;div v-on:click.self=<span class="string">"doThat"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击事件将只会触发一次</span></span><br><span class="line">&lt;a v-on:click.once=<span class="string">"doThis"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 滚动事件的默认行为 (即滚动行为) 将会立即触发</span></span><br><span class="line"><span class="comment">// 而不会等待 `onScroll` 完成</span></span><br><span class="line"><span class="comment">// 这其中包含 `event.preventDefault()` 的情况</span></span><br><span class="line">&lt;div v-on:scroll.passive=<span class="string">"onScroll"</span>&gt;...&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><br><br>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。<br>因此，用 <code>v-on:click.prevent.self</code> 会阻止所有的点击，而 <code>v-on:click.self.prevent</code>只会阻止对元素自身的点击。<br>不要把 <code>.passive</code> 和 <code>.prevent</code> 一起使用，因为 <code>.prevent</code> 将会被忽略，同时浏览器可能会向你展示一个警告。<br>请记住，<code>.passive</code> 会告诉浏览器你不想阻止事件的默认行为。<br><br>### 2、按键修饰符<br>可以通过全局 <code>config.keyCodes</code> 对象自定义按键修饰符别名<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input @keyup.enter=<span class="string">"submit"</span>&gt;</span><br><span class="line"><span class="comment">// 可以使用 `v-on:keyup.f1`</span></span><br><span class="line">Vue.config.keyCodes.f1 = <span class="number">112</span></span><br></pre></td></tr></table></figure><br><br>### 3、系统修饰符<br><code>.exact</code> 修饰符允许你控制由精确的系统修饰符组合触发的事件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 即使 Alt 或 Shift 被一同按下时也会触发</span></span><br><span class="line">&lt;button @click.ctrl=<span class="string">"onClick"</span>&gt;A&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 有且只有 Ctrl 被按下的时候才触发</span></span><br><span class="line"><span class="regexp">&lt;button @click.ctrl.exact="onCtrlClick"&gt;A&lt;/</span>button&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有任何系统修饰符被按下的时候才触发</span></span><br><span class="line">&lt;button @click.exact=<span class="string">"onClick"</span>&gt;A&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><br><br>## 八、表单输入绑定<br>可以用 <code>v-model</code> 指令在表单 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code> 及 <code>&lt;select&gt;</code> 元素上创建双向数据绑定。<br>它会根据控件类型自动选取正确的方法来更新元素。<br><code>v-model</code> 会忽略所有表单元素的 <code>value</code>、<code>checked</code>、<code>selected</code> 特性的初始值而总是将 Vue 实例的数据作为数据来源。<br>你应该通过 JS 在组件的 data 选项中声明初始值。<br>对于需要使用<code>输入法 (如中文、日文、韩文等) 的语言</code>，会发现 <code>v-model</code> 不会在输入法组合文字过程中得到更新。<br>如果你也想处理这个过程，请使用 input 事件。<br><br>### 1、选择框<br>如果 v-model 表达式的初始值未能匹配任何选项，<select> 元素将被渲染为“未选中”状态。<br>在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 change 事件。因此，更推荐像上面这样提供一个值为空的禁用选项。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"example-5"</span>&gt;</span><br><span class="line">  &lt;select v-model=<span class="string">"selected"</span>&gt;</span><br><span class="line">    &lt;option disabled value=<span class="string">""</span>&gt;请选择&lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">    &lt;option&gt;A&lt;/</span>option&gt;</span><br><span class="line">    &lt;option&gt;B&lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">    &lt;option&gt;C&lt;/</span>option&gt;</span><br><span class="line">  &lt;<span class="regexp">/select&gt;</span></span><br><span class="line"><span class="regexp">  &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/</span>span&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">new Vue(&#123;</span></span><br><span class="line"><span class="regexp">  el: '...',</span></span><br><span class="line"><span class="regexp">  data: &#123;</span></span><br><span class="line"><span class="regexp">    selected: ''</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 用 v-for 渲染的动态选项</span></span><br><span class="line"><span class="regexp">&lt;select v-model="selected"&gt;</span></span><br><span class="line"><span class="regexp">  &lt;option v-for="option in options" v-bind:value="option.value"&gt;</span></span><br><span class="line"><span class="regexp">    &#123;&#123; option.text &#125;&#125;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>option&gt;</span><br><span class="line">&lt;<span class="regexp">/select&gt;</span></span><br><span class="line"><span class="regexp">&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/</span>span&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'...'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    selected: <span class="string">'A'</span>,</span><br><span class="line">    options: [</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">'One'</span>, <span class="attr">value</span>: <span class="string">'A'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">'Two'</span>, <span class="attr">value</span>: <span class="string">'B'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">'Three'</span>, <span class="attr">value</span>: <span class="string">'C'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值绑定</span></span><br><span class="line">&lt;select v-model=<span class="string">"selected"</span>&gt;</span><br><span class="line">  <span class="comment">// 内联对象字面量</span></span><br><span class="line">  &lt;option v-bind:value=<span class="string">"&#123; number: 123 &#125;"</span>&gt;<span class="number">123</span>&lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>select&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当选中时</span></span><br><span class="line"><span class="keyword">typeof</span> vm.selected <span class="comment">// =&gt; 'object'</span></span><br><span class="line">vm.selected.number <span class="comment">// =&gt; 123</span></span><br></pre></td></tr></table></figure><br><br>### 2、修饰符<br><code>.lazy</code>: 在默认情况下，<code>v-model</code> 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。<br>你可以添加 <code>lazy</code> 修饰符，从而转变为使用 <code>change</code> 事件进行同步.<br><code>.number</code>: 如果想自动将用户的输入值转为数值类型，可以给 <code>v-mode</code>l 添加 <code>number</code> 修饰符。<br><font color="#d00">如果这个值无法被 parseFloat() 解析，则会返回原始的值。</font><br><code>.trim</code>: 如果要自动过滤用户输入的首尾空白字符，可以给 <code>v-model</code> 添加 <code>trim</code> 修饰符。<br><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在“change”时而非“input”时更新</span></span><br><span class="line">&lt;input v-model.lazy=<span class="string">"msg"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 即使在 type="number" 时，HTML 输入元素的值也总会返回字符串</span></span><br><span class="line">&lt;input v-model.number=<span class="string">"age"</span> type=<span class="string">"number"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;input v-model.trim=<span class="string">"msg"</span>&gt;</span><br></pre></td></tr></table></figure><br><br>### 3、解析DOM模版时需要注意<br>有些 HTML 元素，诸如 <code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;table&gt;</code> 和 <code>&lt;select&gt;</code>，对于哪些元素可以出现在其内部是有严格限制的。<br>而有些元素，诸如 <code>&lt;li&gt;</code>、<code>&lt;tr&gt;</code> 和 <code>&lt;option&gt;</code>，只能出现在其它某些特定的元素内部。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">  &lt;tr is=<span class="string">"blog-post-row"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/table&gt;</span></span><br></pre></td></tr></table></figure><br><br>需要注意的是<font color="#d00">如果我们从以下来源使用模板的话，这条限制是不存在</font>的：<br>1、字符串 (例如：template: ‘…’)<br>2、单文件组件 (.vue)<br>3、<code>&lt;script type=&quot;text/x-template&quot;&gt;</code><br><br>如果使用了 webpack，那么就可以使用 require.context 只全局注册这些非常通用的基础组件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> upperFirst <span class="keyword">from</span> <span class="string">'lodash/upperFirst'</span></span><br><span class="line"><span class="keyword">import</span> camelCase <span class="keyword">from</span> <span class="string">'lodash/camelCase'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> requireComponent = <span class="built_in">require</span>.context(</span><br><span class="line">  <span class="comment">// 其组件目录的相对路径</span></span><br><span class="line">  <span class="string">'./components'</span>,</span><br><span class="line">  <span class="comment">// 是否查询其子目录</span></span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 匹配基础组件文件名的正则表达式</span></span><br><span class="line">  /Base[A-Z]\w+\.(vue|js)$/</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">requireComponent.keys().forEach(<span class="function"><span class="params">fileName</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 获取组件配置</span></span><br><span class="line">  <span class="keyword">const</span> componentConfig = requireComponent(fileName)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取组件的 PascalCase 命名</span></span><br><span class="line">  <span class="keyword">const</span> componentName = upperFirst(</span><br><span class="line">    camelCase(</span><br><span class="line">      <span class="comment">// 剥去文件名开头的 `./` 和结尾的扩展名</span></span><br><span class="line">      fileName.replace(<span class="regexp">/^\.\/(.*)\.\w+$/</span>, <span class="string">'$1'</span>)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 全局注册组件</span></span><br><span class="line">  Vue.component(</span><br><span class="line">    componentName,</span><br><span class="line">    <span class="comment">// 如果这个组件选项是通过 `export default` 导出的，</span></span><br><span class="line">    <span class="comment">// 那么就会优先使用 `.default`，</span></span><br><span class="line">    <span class="comment">// 否则回退到使用模块的根。</span></span><br><span class="line">    componentConfig.default || componentConfig</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br><br><font color="#d00">全局注册的行为必须在根 Vue 实例 (通过 new Vue) 创建之前发生</font></select>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Vue实例&quot;&gt;&lt;a href=&quot;#一、Vue实例&quot; class=&quot;headerlink&quot; title=&quot;一、Vue实例&quot;&gt;&lt;/a&gt;一、Vue实例&lt;/h2&gt;&lt;p&gt;只有当实例被创建时 data 中存在的属性才是响应式的。&lt;br&gt;vm.b = ‘hi’;  // 对
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>单页面应用的权限管理</title>
    <link href="http://yoursite.com/2018/10/19/%5BVue%5D%20%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E7%9A%84%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2018/10/19/[Vue] 单页面应用的权限管理/</id>
    <published>2018-10-19T02:26:43.000Z</published>
    <updated>2018-10-29T13:04:42.606Z</updated>
    
    <content type="html"><![CDATA[<p>Vue 单页面应用的权限管理有两种方法：<code>接口级权限</code>；<code>页面级权限</code></p><h3 id="接口级权限"><a href="#接口级权限" class="headerlink" title="接口级权限"></a>接口级权限</h3><p>例子：后台好多接口发ajax请求获取数据的时候后端都会需要获取用户是否登录，并在登录的情况反馈到前端，前端跳转到登录页面。这个就可以使用这个拦截器来实现。<br>在请求或响应被 then 或 catch 处理前拦截它们。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;, error =&gt; &#123;</span><br><span class="line">  <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="params">config</span>  =&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">&#125;, error =&gt; &#123;</span><br><span class="line">  <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="页面级权限"><a href="#页面级权限" class="headerlink" title="页面级权限"></a>页面级权限</h3><p>页面及权限主要靠vue-router来实现。基本思路是为全局注册一个“前置守卫”钩子函数router.beforeEach。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123; ... &#125;)</span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这里检查权限并进行跳转</span></span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>每个守卫方法接收三个参数：<br>1、<code>to</code>:Route 即将要进入的目标<br>2、<code>from</code>: Route 当前导航正要离开的路由<br>3、<code>next</code>: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。<br><code>next()</code>: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed （确认的）。<br><code>next(false)</code>: 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 from 路由对应的地址。<br><code>next(&#39;/&#39;)</code>或者 <code>next({ path: &#39;/&#39; })</code>: 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。<br>你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: ‘home’ 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项。<br><code>next(error)</code>: (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Vue 单页面应用的权限管理有两种方法：&lt;code&gt;接口级权限&lt;/code&gt;；&lt;code&gt;页面级权限&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;接口级权限&quot;&gt;&lt;a href=&quot;#接口级权限&quot; class=&quot;headerlink&quot; title=&quot;接口级权限&quot;&gt;&lt;/a&gt;接口级权限&lt;
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vue数据传递</title>
    <link href="http://yoursite.com/2018/10/18/%5BVue%5D%20Vue%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/"/>
    <id>http://yoursite.com/2018/10/18/[Vue] Vue数据传递/</id>
    <published>2018-10-18T08:47:41.000Z</published>
    <updated>2018-10-30T10:36:15.651Z</updated>
    
    <content type="html"><![CDATA[<h2 id="父组件到子组件"><a href="#父组件到子组件" class="headerlink" title="父组件到子组件"></a>父组件到子组件</h2><h3 id="方法一：Prop方法"><a href="#方法一：Prop方法" class="headerlink" title="方法一：Prop方法"></a>方法一：Prop方法</h3><p>在父组件调用子组件时通过v-bind(:)绑定动态数据，在子组件，使用Prop方法（单项绑定，防止数据倒流）<br>父：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;edit-dialog :dialogData=<span class="string">"dialogData"</span> :rendom=<span class="string">"new Date().getTime()"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">edit-dialog</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  dialogData: <span class="built_in">Object</span>,</span><br><span class="line">  rendom: <span class="built_in">Number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>子组件中通过watch方法来监控数据是否改变，可触发相应的方法。</p><h3 id="方法二：provide-inject"><a href="#方法二：provide-inject" class="headerlink" title="方法二：provide/inject"></a>方法二：provide/inject</h3><p>provider/inject：在父组件中通过provider来提供变量，在子组件中通过inject来注入变量。<br>不论子组件有多深，只要调用了inject那么就可以注入provider中的数据。而不是局限于只能从当前父组件的prop属性来获取数据，只要在父组件的生命周期内，子组件都可以调用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">"Parent"</span>,</span><br><span class="line">  provide: &#123;     <span class="comment">//重要一步，在父组件中注入一个变量</span></span><br><span class="line">    <span class="keyword">for</span>: <span class="string">"demo"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  components:&#123;</span><br><span class="line">    childOne</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">"childOne"</span>,</span><br><span class="line">  inject: [<span class="string">'for'</span>],   <span class="comment">//子孙组件中使用inject接住变量即可</span></span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      demo: <span class="keyword">this</span>.for</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="子组件到父组件"><a href="#子组件到父组件" class="headerlink" title="子组件到父组件"></a>子组件到父组件</h2><h3 id="方法一：发送-监听事件"><a href="#方法一：发送-监听事件" class="headerlink" title="方法一：发送/监听事件"></a>方法一：发送/监听事件</h3><p>在父组件中使用v-on(@)绑定自定义事件接收，在子组件中使用$emit来监控，并传给回掉。<br>父：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;edit-dialog @message=<span class="string">"recieveMessage"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">edit-dialog</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>子：<br>this.$emit(‘message’, data)</p><h3 id="方法二：-children、-ref或-parent"><a href="#方法二：-children、-ref或-parent" class="headerlink" title="方法二：$children、$ref或$parent"></a>方法二：$children、$ref或$parent</h3><p><code>$children</code>: 返回所有子组件的实例，是一个数组。如果能清楚的知道子组件的顺序，也可以使用下标来操作；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.$children.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.$children[i].children_data);</span><br><span class="line">  <span class="keyword">this</span>.$children[i].children_fun();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>1、<code>$ref</code>：给子组件做标记，即可在父组件中调用到子组件的数据和方法<br>首先在子组件做标记： <firstchild ref="one"></firstchild><br>然后在父组件中，通过<code>this.$refs.one</code>就可以访问该子组件，包括访问子组件的data里面的数据，调用它的函数。<br>2、<code>ref</code> 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。<br>如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素;<br>如果用在子组件上，引用就指向组件实例。<br>3、子组件访问根组件<code>$root</code>当前组件树的根 Vue 实例。如果当前实例没有父实例，此实例将会是其自已。<br>4、<code>$parent</code>在子组件中调用父组件的方法或获得其数据。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parents.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">'parents'</span>&gt;</span><br><span class="line">            &lt;p&gt;我是父组件</span><br><span class="line">              &lt;button @click=<span class="string">"click1hanlde"</span>&gt;获取子组件<span class="number">1</span>的数据与方法&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">              &lt;button @click="click2hanlde"&gt;获取所有子组件的数据和方法&lt;/</span>button&gt;<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">             &lt;children1 ref=<span class="string">"children1"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">children1</span>&gt;</span></span></span><br><span class="line">             &lt;children2 ref=<span class="string">"children2"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">children2</span>&gt;</span></span></span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">import</span> children1 <span class="keyword">from</span> <span class="string">'./children1.vue'</span></span><br><span class="line">  <span class="keyword">import</span> children2 <span class="keyword">from</span> <span class="string">'./children2.vue'</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    components:&#123;</span><br><span class="line">      children1, children2</span><br><span class="line">    &#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ParentData:<span class="string">'AAA'</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">      click1hanlde()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$refs.children1.children_data)</span><br><span class="line">        <span class="keyword">this</span>.$refs.children1.children_fun();</span><br><span class="line">      &#125;,</span><br><span class="line">      click2hanlde()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.$children.length;i++)&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="keyword">this</span>.$children[i].children_data);</span><br><span class="line">          <span class="keyword">this</span>.$children[i].children_fun();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      showParentData()&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.ParentData)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="非父子组件-eventBus-vuex"><a href="#非父子组件-eventBus-vuex" class="headerlink" title="非父子组件 eventBus / vuex"></a>非父子组件 eventBus / vuex</h2><p>有时候两个组件也需要通信(非父子关系)。在简单的场景下，可以使用一个空的 Vue 实例作为中央事件总线：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eventBus.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vue();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送事件（发送数据）</span></span><br><span class="line"><span class="keyword">import</span> bus <span class="keyword">from</span> <span class="string">'@/bus'</span>;</span><br><span class="line">bus.$emit(<span class="string">'childa-message'</span>, <span class="keyword">this</span>.data); <span class="comment">// 方法内执行下面动作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件内监听（接收数据组件）</span></span><br><span class="line"><span class="keyword">import</span> bus <span class="keyword">from</span> <span class="string">'@/bus'</span>;</span><br><span class="line">bus.$on(<span class="string">'childa-message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;    <span class="comment">// 方法内执行下面动作</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'I get it'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><a href="http://pfuoi64aq.bkt.clouddn.com/vue.webp" target="_blank" rel="noopener">了解整个vue</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;父组件到子组件&quot;&gt;&lt;a href=&quot;#父组件到子组件&quot; class=&quot;headerlink&quot; title=&quot;父组件到子组件&quot;&gt;&lt;/a&gt;父组件到子组件&lt;/h2&gt;&lt;h3 id=&quot;方法一：Prop方法&quot;&gt;&lt;a href=&quot;#方法一：Prop方法&quot; class=&quot;head
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>webpack 到应用</title>
    <link href="http://yoursite.com/2018/10/18/%5B%E6%9E%84%E5%BB%BA%5D%20webpack%E5%88%B0%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2018/10/18/[构建] webpack到应用/</id>
    <published>2018-10-17T16:39:31.000Z</published>
    <updated>2018-10-18T17:01:39.616Z</updated>
    
    <content type="html"><![CDATA[<p><a href="#ES6项目">ES6项目</a><br><a href="#TypeScript项目">TypeScript项目</a><br><a href="#Flow检查器">Flow 检查器</a><br><a href="#SCSS">SCSS</a><br><a href="#PostCSS">PostCSS</a><br><a href="#Vue框架">Vue框架</a></p><h3 id="ES6项目"><a href="#ES6项目" class="headerlink" title="ES6项目"></a>ES6项目</h3><p>可以使用.bablerc对ES6、ES7进行配置<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: [<span class="string">'babel-loader'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 输出 source-map 方便直接调试 ES6 源码</span></span><br><span class="line">  devtool: <span class="string">'source-map'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安装依赖</span></span><br><span class="line"><span class="comment">// Webpack 接入 Babel 必须依赖的模块</span></span><br><span class="line">npm i -D babel-core babel-loader </span><br><span class="line"><span class="comment">// 根据你的需求选择不同的 Plugins 或 Presets</span></span><br><span class="line">npm i -D babel-preset-env</span><br></pre></td></tr></table></figure></p><h3 id="TypeScript项目"><a href="#TypeScript项目" class="headerlink" title="TypeScript项目"></a>TypeScript项目</h3><p>Ts 是 Js 的一个超集，主要提供了类型检查系统和对 ES6 语法的支持，但不支持新的 API。<br>方法一：建立配置编译选项的<code>tsconfig.json</code>文件<br>方法二：集成Webpack<br>需要解决以下2个问题：<br>1、通过 Loader 把 Ts 转换成 Js。 推荐 <code>awesome-typescript-loader</code>。<br>  安装：npm i -D typescript awesome-typescript-loader<br>2、Webpack 在寻找模块对应的文件时需要尝试 ts 后缀，解决办法：修改默认的 <code>resolve.extensions</code> 配置项<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tsconfig.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="string">"module"</span>: <span class="string">"commonjs"</span>, <span class="comment">// 编译出的代码采用的模块规范</span></span><br><span class="line">    <span class="string">"target"</span>: <span class="string">"es5"</span>, <span class="comment">// 编译出的代码采用 ES 的哪个版本</span></span><br><span class="line">    <span class="string">"sourceMap"</span>: <span class="literal">true</span>, <span class="comment">// 输出 Source Map 方便调试</span></span><br><span class="line">    <span class="string">"importHelpers"</span>: <span class="literal">true</span>   <span class="comment">// 避免代码冗余</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"exclude"</span>: [ <span class="comment">// 不编译这些目录里的文件</span></span><br><span class="line">    <span class="string">"node_modules"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集成 Webpack</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 执行入口文件</span></span><br><span class="line">  entry: <span class="string">'./main'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'./dist'</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">'.ts'</span>, <span class="string">'.js'</span>]  <span class="comment">// 先尝试 ts 后缀的 TypeScript 源码文件</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">        loader: <span class="string">'awesome-typescript-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: <span class="string">'source-map'</span>,  <span class="comment">// 输出 Source Map 方便在浏览器里调试 TypeScript 代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="Flow检查器"><a href="#Flow检查器" class="headerlink" title="Flow检查器"></a>Flow检查器</h3><p>Flow 是一个 Facebook 开源的 JS 静态类型检测器，它是 JS 语言的超集，在需要的地方加上类型检查。<br>采用了 Flow 静态类型语法的 JS 是无法直接在目前已有的 JS 引擎中运行，要让代码可以运行需要把这些静态类型语法去掉。<br>有两种方式可以做到这点：<br>1、<code>flow-remove-types</code> 可单独使用，速度快。<br>2、<code>babel-preset-flow</code> 与 <code>Babel</code> 集成。<br>方法二：采用webpack<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改 .babelrc 配置文件，加入 Flow Preset</span></span><br><span class="line"><span class="comment">// 安装 npm i -D babel-preset-flow 依赖到项目</span></span><br><span class="line"><span class="string">"presets"</span>: [</span><br><span class="line">  ...[],</span><br><span class="line">  <span class="string">"flow"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="SCSS"><a href="#SCSS" class="headerlink" title="SCSS"></a>SCSS</h3><p>SCSS 可以让你用更灵活的方式写 CSS。 它是一种 CSS 预处理器，语法和 CSS 相似，但加入了变量、逻辑、等编程元素。<br>好处：可以方便地管理代码，抽离公共的部分，通过逻辑写出更灵活的代码。<br>SCSS 又叫 SASS，区别在于 SASS 语法类似 Ruby，而 SCSS 语法类似 CSS。</p><h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><p>通过 node-sass 编译 .scss 文件  <code>node-sass main.scss main.css</code></p><h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><p>接入 Webpack：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 增加对 SCSS 文件的支持</span></span><br><span class="line">        test: <span class="regexp">/\.scss/</span>,</span><br><span class="line">        <span class="comment">// SCSS 文件的处理顺序为先 sass-loader 再 css-loader 再 style-loader</span></span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'sass-loader'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>1、通过 sass-loader 把 SCSS 源码转换为 CSS 代码，再把 CSS 代码交给 css-loader 去处理。<br>2、css-loader 会找出 CSS 代码中的 @import 和 url() 这样的导入语句，告诉 Webpack 依赖这些资源。同时还支持 CSS Modules、压缩 CSS 等功能。处理完后再把结果交给 style-loader 去处理。<br>3、style-loader 会把 CSS 代码转换成字符串后，注入到 JS 代码中去，通过 JS 去给 DOM 增加样式。<br>如果你想把 CSS 代码提取到一个单独的文件而不是和 JS 混在一起，可以使用 <code>ExtractTextPlugin。</code><br>4、注意：<code>sass-loader 依赖 node-sass</code></p><h3 id="PostCSS"><a href="#PostCSS" class="headerlink" title="PostCSS"></a>PostCSS</h3><p><code>PostCSS</code> 是一个 CSS 处理工具，和 SCSS 不同的地方在于它通过插件机制可以灵活的扩展其支持的特性，而不是像 SCSS 那样语法是固定的。<br><code>PostCSS</code> 的用处非常多，包括<strong>给 CSS 自动加前缀</strong>、<strong>使用下一代 CSS 语法</strong>等</p><h4 id="方法一：postcss-config-js"><a href="#方法一：postcss-config-js" class="headerlink" title="方法一：postcss.config.js"></a>方法一：<code>postcss.config.js</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 需要使用的插件列表</span></span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'postcss-cssnext'</span>)    <span class="comment">// postcss-cssnext 插件: 使用下一代 CSS 语法编写代码</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法一：接入-Webpack"><a href="#方法一：接入-Webpack" class="headerlink" title="方法一：接入 Webpack"></a>方法一：接入 Webpack</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 使用 PostCSS 处理 CSS 文件</span></span><br><span class="line">        test: <span class="regexp">/\.css/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Vue框架"><a href="#Vue框架" class="headerlink" title="Vue框架"></a>Vue框架</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">      use: [<span class="string">'vue-loader'</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><p>安装依赖：npm i -D vue-loader css-loader vue-template-compiler。它们的作用分别是：<br>1、<code>vue-loader</code>：解析和转换 .vue 文件，提取出其中的逻辑代码 script、样式代码 style、以及 HTML 模版 template，再分别把它们交给对应的 Loader 去处理。<br>2、<code>css-loader</code>：加载由 vue-loader 提取出的 CSS 代码。<br>3、<code>vue-template-compiler</code>：把 vue-loader 提取出的 HTML 模版编译成对应的可执行的 JS 代码，这和 React 中的 JSX 语法被编译成 JS 代码类似。预先编译好 HTML 模版相对于在浏览器中再去编译 HTML 模版的好处在于性能更好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;#ES6项目&quot;&gt;ES6项目&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#TypeScript项目&quot;&gt;TypeScript项目&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#Flow检查器&quot;&gt;Flow 检查器&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#SCSS&quot;&gt;SCSS&lt;/a&gt;&lt;br&gt;
      
    
    </summary>
    
      <category term="构建" scheme="http://yoursite.com/categories/%E6%9E%84%E5%BB%BA/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>ES6基础知识 — 字符串的扩展</title>
    <link href="http://yoursite.com/2018/10/17/%5BES6%5D%20ES6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/2018/10/17/[ES6] ES6基础知识—字符串的扩展/</id>
    <published>2018-10-17T12:28:31.000Z</published>
    <updated>2018-10-29T13:04:42.601Z</updated>
    
    <content type="html"><![CDATA[<p><a href="#1、字符的Unicode表示法">1、字符的Unicode表示法</a><br><a href="#2、codePointAt">2、codePointAt</a><br><a href="#3、String.fromCodePoint">3、String.fromCodePoint</a><br><a href="#4、字符串的遍历器接口for...of...">4、字符串的遍历器接口for…of…</a><br><a href="#5、normalize">5、normalize</a><br><a href="#6、includes, startsWith, endsWith">6、includes(), startsWith(), endsWith()</a><br><a href="#7、repeat">7、repeat</a><br><a href="#8、padStart，padEnd">8、padStart，padEnd</a><br><a href="#9、matchAll">9、matchAll</a><br><a href="#10、模板字符串">10、模板字符串</a><br><a href="#11、String.raw">11、String.raw</a></p><h3 id="1、字符的Unicode表示法"><a href="#1、字符的Unicode表示法" class="headerlink" title="1、字符的Unicode表示法"></a>1、字符的Unicode表示法</h3><p>JS允许采用<code>\uxxxx</code>形式表示一个字符，其中<code>xxxx</code>表示字符的<code>Unicode</code>码点， 只限于码点在<code>\u0000</code>~<code>\uFFFF</code><br>JS 共有 6 种方法可以表示一个字符:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\z'</span> === <span class="string">'z'</span>      <span class="comment">// true</span></span><br><span class="line"><span class="string">'\172'</span> === <span class="string">'z'</span>    <span class="comment">// true</span></span><br><span class="line"><span class="string">'\x7A'</span> === <span class="string">'z'</span>    <span class="comment">// true</span></span><br><span class="line"><span class="string">'\u007A'</span> === <span class="string">'z'</span>  <span class="comment">// true</span></span><br><span class="line"><span class="string">'\u&#123;7A&#125;'</span> === <span class="string">'z'</span>  <span class="comment">// true   ES6的改进</span></span><br></pre></td></tr></table></figure></p><h3 id="2、codePointAt"><a href="#2、codePointAt" class="headerlink" title="2、codePointAt"></a>2、codePointAt</h3><p>能够正确说明字符的字节数，返回字符码点的十进制数</p><h3 id="3、String-fromCodePoint"><a href="#3、String-fromCodePoint" class="headerlink" title="3、String.fromCodePoint"></a>3、String.fromCodePoint</h3><p><code>String.fromCharCode</code>从码点返回对应字符，但不能识别 32 位的 UTF-16 字符<br><code>String.fromCodePoint</code>方法弥补不足，有多个参数，则它们会被合并成一个字符串返回</p><font color="#dd0000"><code>fromCodePoint</code>方法定义在<code>String</code>对象上，而<code>codePointAt</code>方法定义在字符串的实例对象上。</font><h3 id="4、字符串的遍历器接口for…of…"><a href="#4、字符串的遍历器接口for…of…" class="headerlink" title="4、字符串的遍历器接口for…of…"></a>4、字符串的遍历器接口for…of…</h3><p>for…of…：字符串可被循环遍历，可以识别大于0xFFFF的码点</p><h3 id="5、normalize"><a href="#5、normalize" class="headerlink" title="5、normalize"></a>5、normalize</h3><p>用来将字符的不同表示方法统一为同样的形式，称为 Unicode 正规化（该方法可传参，具体需要再查）</p><h3 id="6、includes-startsWith-endsWith"><a href="#6、includes-startsWith-endsWith" class="headerlink" title="6、includes, startsWith, endsWith"></a>6、includes, startsWith, endsWith</h3><p><code>indexOf</code>一个字符串是否包含在另一个字符串中<br><code>includes(str, n)</code>是否找到了参数字符串，n表示开始搜索的位置：<br><code>startsWith(str, n)</code>参数字符串是否在原字符串的头部，n表示开始搜索的位置：<br><code>endsWith(str, n)</code>参数字符串是否在原字符串的尾部，n表示开始搜索的位置：</p><h3 id="7、repeat"><a href="#7、repeat" class="headerlink" title="7、repeat"></a>7、repeat</h3><p>将原字符串重复n次，参数若是小数，会被取整；参数是负数或者Infinity，会报错；参数NaN等同于 0。</p><h3 id="8、padStart，padEnd"><a href="#8、padStart，padEnd" class="headerlink" title="8、padStart，padEnd"></a>8、padStart，padEnd</h3><p><code>padStart(n, str)</code>：用于字符串在头部补全，n指定字符串的最小长度，arr用来补全的字符串。<br><code>padEnd(n, str)</code>：字符串在尾部补全，n指定字符串的最小长度，arr用来补全的字符串。<br>如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。<br>如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。<br>如果省略第二个参数，默认使用空格补全长度。</p><h3 id="9、matchAll"><a href="#9、matchAll" class="headerlink" title="9、matchAll"></a>9、matchAll</h3><p>返回一个正则表达式在当前字符串的所有匹配</p><h3 id="10、模板字符串"><a href="#10、模板字符串" class="headerlink" title="10、模板字符串"></a>10、模板字符串</h3><p><code>${}和引号</code>的使用</p><h3 id="11、String-raw"><a href="#11、String-raw" class="headerlink" title="11、String.raw"></a>11、String.raw</h3><p>模板字符串的处理函数<br>返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串<br>String.raw<code>Hi\n${2+3}!</code>;    // 返回 “Hi\n5!”<br>String.raw<code>Hi\u000A!</code>;    // 返回 “Hi\u000A!”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、codePointAt</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"𠮷"</span>;</span><br><span class="line">str.length;   <span class="comment">// length为2，无法正确返回，其为4字节的字符</span></span><br><span class="line">str.charAt(<span class="number">0</span>);  <span class="comment">//'�' 会导致乱码</span></span><br><span class="line">str.charAt(<span class="number">1</span>);  <span class="comment">//'�' 会导致乱码</span></span><br><span class="line">str.codePointAt();  <span class="comment">// 结果:134071</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、fromCodePoint</span></span><br><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0x20BB7</span>)</span><br><span class="line"><span class="comment">// "𠮷"</span></span><br><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0x78</span>, <span class="number">0x1f680</span>, <span class="number">0x79</span>) === <span class="string">'x\uD83D\uDE80y'</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、字符串的遍历器接口for...of...</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> codePoint <span class="keyword">of</span> <span class="string">'foo'</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(codePoint);      <span class="comment">// "f"  // "o"  // "o"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> text = <span class="built_in">String</span>.fromCodePoint(<span class="number">0x20BB7</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> text) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);       <span class="comment">// "𠮷"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、includes(), startsWith(), endsWith()</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="string">'Hello world!'</span>;</span><br><span class="line">s.startsWith(<span class="string">'world'</span>, <span class="number">6</span>)  <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">'Hello'</span>, <span class="number">5</span>)    <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">'Hello'</span>, <span class="number">6</span>)    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5、repeat</span></span><br><span class="line"><span class="string">'hello'</span>.repeat(<span class="number">2</span>) <span class="comment">// "hellohello"</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="number">2.9</span>) <span class="comment">// "nana"</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="string">'na'</span>) <span class="comment">// ""</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="string">'3'</span>) <span class="comment">// "nanana"</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="number">-0.9</span>) <span class="comment">// ""</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="literal">NaN</span>) <span class="comment">// ""</span></span><br><span class="line"></span><br><span class="line"><span class="string">'xxx'</span>.padStart(<span class="number">2</span>, <span class="string">'ab'</span>)     <span class="comment">// 'xxx'</span></span><br><span class="line"><span class="string">'xxx'</span>.padEnd(<span class="number">2</span>, <span class="string">'ab'</span>)       <span class="comment">// 'xxx'  </span></span><br><span class="line"><span class="string">'abc'</span>.padStart(<span class="number">10</span>, <span class="string">'0123456789'</span>)    <span class="comment">// '0123456abc'</span></span><br><span class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>)         <span class="comment">// '   x'</span></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">4</span>)           <span class="comment">// 'x   '</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;#1、字符的Unicode表示法&quot;&gt;1、字符的Unicode表示法&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2、codePointAt&quot;&gt;2、codePointAt&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3、String.fromCodePoint&quot;&gt;3、Strin
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6基础知识 — let和const命令</title>
    <link href="http://yoursite.com/2018/10/17/%5BES6%5D%20ES6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94let%E5%92%8Cconst%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/10/17/[ES6] ES6基础知识—let和const命令/</id>
    <published>2018-10-17T12:23:12.000Z</published>
    <updated>2018-10-29T13:04:42.601Z</updated>
    
    <content type="html"><![CDATA[<p><a href="#1、let和const的性质">1、let和const的性质</a><br><a href="#2、块级作用域">2、块级作用域</a><br><a href="#3、顶层对象的属性">3、顶层对象的属性</a><br><a href="#4、global 对象">4、global 对象</a></p><h3 id="1、let和const的性质"><a href="#1、let和const的性质" class="headerlink" title="1、let和const的性质"></a>1、let和const的性质</h3><p>1、<code>let</code>、<code>const</code>声明的变量只在声明所在的块级作用域内有效；<strong>const 一旦声明变量，就必须立即初始化，不能留到以后赋值。</strong><br>2、不存在变量提升；<br>3、暂时性死区: 在代码块内，只能在声明的位置后面使用；<br>4、不允许在相同作用域内，重复声明同一个变量；</p><font color="#dd0000">对于简单类型的数据（数值、字符串、布尔值），const等同于常量。</font><br><font color="#dd0000">对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。</font><br><font color="#dd0000">如果将对象冻结，可以使用Object.freeze方法。</font><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、变量声明提升</span></span><br><span class="line"><span class="comment">// var 的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 输出undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// let 的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// 报错ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、暂时性死区案例</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// TDZ开始</span></span><br><span class="line">  tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> tmp; <span class="comment">// TDZ结束</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">  tmp = <span class="number">123</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、对象冻结</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line"><span class="comment">// 常规模式时，下面一行不起作用；严格模式时，该行会报错</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、除了将对象本身冻结，对象的属性也应该冻结。</span></span><br><span class="line"><span class="keyword">var</span> constantize = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach( <span class="function">(<span class="params">key, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span> ) &#123;</span><br><span class="line">      constantize( obj[key] );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2、块级作用域"><a href="#2、块级作用域" class="headerlink" title="2、块级作用域"></a>2、块级作用域</h3><p>提出原因：内层变量可能会覆盖外层变量；用来计数的循环变量泄露为全局变量……<br>实现作用：是在块内使用，不影响外面，外面的变量，内部也能定义。</p><font color="#dd0000">ES6 有 6 种声明变量的方法：<code>var</code>、<code>function</code>、<code>let</code>、<code>const</code>、<code>import</code>、<code>class</code></font><h3 id="3、顶层对象的属性"><a href="#3、顶层对象的属性" class="headerlink" title="3、顶层对象的属性"></a>3、顶层对象的属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.a = 1;</span><br><span class="line">a   // 返回 1</span><br><span class="line">a = 2;</span><br><span class="line">window.a // 返回 2</span><br></pre></td></tr></table></figure><p>上述代码的弊端：<br>1、不能在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；<br>2、其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；<br>3、顶层对象的属性是到处可以读写的，这非常不利于模块化编程。<br>4、window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</p><p><font color="#dd0000"><code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象的属性；</font></p><p><font color="#dd0000"><code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。</font><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果在 Node 的 REPL 环境，可以写成 global.a</span></span><br><span class="line"><span class="comment">// 或者采用通用方法，写成 this.a</span></span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 返回 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">window</span>.b <span class="comment">// 返回 undefined</span></span><br></pre></td></tr></table></figure></p><h3 id="4、global-对象"><a href="#4、global-对象" class="headerlink" title="4、global 对象"></a>4、global 对象</h3><p>目的：为了在不同的环境中都能获取到顶层对象。<br>ES5顶层对象的获取：<br>1、浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。<br>2、浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。<br>3、Node 里面，顶层对象是global，但其他环境都不支持。</p><p>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。<br>1、全局环境中，this会返回顶层对象。但Node 模块和 ES6 模块中，this返回的是当前模块。<br>2、函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。<br>3、不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么eval、new Function这些方法都可能无法使用。</p><p>提出了<code>垫片库system.global</code>.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS 的写法</span></span><br><span class="line"><span class="keyword">var</span> global = <span class="built_in">require</span>(<span class="string">'system.global'</span>)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 模块的写法</span></span><br><span class="line"><span class="keyword">import</span> getGlobal <span class="keyword">from</span> <span class="string">'system.global'</span>;</span><br><span class="line"><span class="keyword">const</span> global = getGlobal();</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;#1、let和const的性质&quot;&gt;1、let和const的性质&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2、块级作用域&quot;&gt;2、块级作用域&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3、顶层对象的属性&quot;&gt;3、顶层对象的属性&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#4、globa
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>移动浏览器的四大内核</title>
    <link href="http://yoursite.com/2018/10/15/%5B%E7%A7%BB%E5%8A%A8%E7%AB%AF%5D%20%E7%A7%BB%E5%8A%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9B%9B%E5%A4%A7%E5%86%85%E6%A0%B8/"/>
    <id>http://yoursite.com/2018/10/15/[移动端] 移动浏览器的四大内核/</id>
    <published>2018-10-15T06:20:45.000Z</published>
    <updated>2018-10-29T13:04:42.606Z</updated>
    
    <content type="html"><![CDATA[<h2 id="四大浏览器内核优缺点"><a href="#四大浏览器内核优缺点" class="headerlink" title="四大浏览器内核优缺点"></a>四大浏览器内核优缺点</h2><ol><li>Trident:因为在早期IE占有大量的市场份额，所以以前有很多网页是根据这个Trident的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好，同时存在许多安全Bug。</li><li>Gecko:优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，缺点是消耗很多的资源，比如内存。</li><li>Webkit:优点就是Webkit拥有清晰的源码结构、极快的渲染速度，缺点是对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。</li><li>Presto：Presto内核被称为公认的浏览网页速度最快的内核，同时也是处理JS脚本最兼容的内核，能在Windows、Mac及Linux操作系统下完美运行。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;四大浏览器内核优缺点&quot;&gt;&lt;a href=&quot;#四大浏览器内核优缺点&quot; class=&quot;headerlink&quot; title=&quot;四大浏览器内核优缺点&quot;&gt;&lt;/a&gt;四大浏览器内核优缺点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Trident:因为在早期IE占有大量的市场份额，所以以前有很多
      
    
    </summary>
    
      <category term="移动端" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="移动端" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>跨域的实现方法</title>
    <link href="http://yoursite.com/2018/10/15/%5BJS%5D%20%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/10/15/[JS] 跨域的实现方法/</id>
    <published>2018-10-15T03:09:12.000Z</published>
    <updated>2018-10-30T12:56:56.451Z</updated>
    
    <content type="html"><![CDATA[<p>同源： “协议 + 域名 + 端口” 三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。<br>同源策略限制下 <code>cookie</code>、<code>localStorage</code>、<code>IndexedDB</code>、<code>dom</code>、<code>ajax</code> 都是不支持跨域的。<br>但是有三个标签是允许跨域加载资源：<code>&lt;img src=XXX&gt;</code>、<code>&lt;link href=XXX&gt;</code>、<code>&lt;script src=XXX&gt;</code></p><h2 id="方法一、使用-jsonp-跨域"><a href="#方法一、使用-jsonp-跨域" class="headerlink" title="方法一、使用 jsonp 跨域"></a>方法一、使用 jsonp 跨域</h2><p>jsonp 和 ajax 相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。但 ajax 属于同源策略，jsonp 属于非同源策略（跨域请求）<br>JSONP优点是兼容性好，可用于解决主流浏览器的跨域数据访问的问题。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装 jsonp 跨域请求的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">&#123; url, params, cb &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 script 标签帮助我们发送请求</span></span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    params = &#123; ...params, cb &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环构建键值对形式的参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">        arr.push(<span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建全局函数</span></span><br><span class="line">    <span class="built_in">window</span>[cb] = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        resolve(data);</span><br><span class="line">        <span class="comment">// 在跨域拿到数据以后将 script 标签销毁</span></span><br><span class="line">        <span class="built_in">document</span>.body.removeChild(script);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接发送请求的参数并赋值到 src 属性</span></span><br><span class="line">    script.src = <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;arr.join(<span class="string">"&amp;"</span>)&#125;</span>`</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><font color="#dd0000">缺点：</font><br>只能发送 get 请求 不支持 post、put、delete；<br>不安全，容易引发 xss 攻击。</p><h2 id="方法二、使用-CORS-跨域"><a href="#方法二、使用-CORS-跨域" class="headerlink" title="方法二、使用 CORS 跨域"></a>方法二、使用 CORS 跨域</h2><p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。<br>CORS要求浏览器(&gt;IE10)和服务器的同时支持，是跨域的根本解决方法，由浏览器自动完成。<br>优点在于功能更加强大支持各种HTTP Method，缺点是兼容性不如JSONP。</p><p><font color="#dd0000">使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。</font><br>使用场景：多用于开发时，前端与后台在不同的 ip 地址下进行数据访问。<br>案例说明：通过访问 <a href="http://localhost:3000/index.html（服务器1）" target="_blank" rel="noopener">http://localhost:3000/index.html（服务器1）</a> 获取 index.html 文件并执行其中的 Ajax 请求 <a href="http://localhost:4000/getDate（服务器2）" target="_blank" rel="noopener">http://localhost:4000/getDate（服务器2）</a> 接口去获取数据。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// 正常 cookie 是不允许跨域的</span></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'name=hello'</span>;</span><br><span class="line"><span class="comment">// cookie 想要实现跨域必须携带凭证</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// xhr.open('GET', 'http://localhost:4000/getDate', true);</span></span><br><span class="line">xhr.open(<span class="string">'PUT'</span>, <span class="string">'http://localhost:4000/getDate'</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置名为 name 的自定义请求头</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">'name'</span>, <span class="string">'hello'</span>);</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span> || xhr.status === <span class="number">304</span>) &#123;</span><br><span class="line">      <span class="comment">// 打印返回的数据</span></span><br><span class="line">      <span class="built_in">console</span>.log(xhr.response);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 打印后台设置的自定义头信息</span></span><br><span class="line">      <span class="built_in">console</span>.log(xhr.getResponseHeader(<span class="string">'name'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器2</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许访问域的白名单</span></span><br><span class="line"><span class="keyword">let</span> whiteList = [<span class="string">"http://localhost:3000"</span>];</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> origin = req.header.origin;</span><br><span class="line">  <span class="keyword">if</span> (whiteList.includes(origin)) &#123;</span><br><span class="line">    <span class="comment">// 设置那个源可以访问我，参数为 * 时，允许任何人访问，但是不可以和 cookie 凭证的响应头共同使用</span></span><br><span class="line">    res.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>, origin);</span><br><span class="line">    <span class="comment">// 想要获取 ajax 的头信息，需设置响应头</span></span><br><span class="line">    res.setHeader(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"name"</span>);</span><br><span class="line">    <span class="comment">// 处理复杂请求的头</span></span><br><span class="line">    res.setHeader(<span class="string">"Access-Control-Allow-Methods"</span>, <span class="string">"PUT"</span>);</span><br><span class="line">    <span class="comment">// 允许发送 cookie 凭证的响应头</span></span><br><span class="line">    res.setHeader(<span class="string">"Access-Control-Allow-Credentials"</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 允许前端获取哪个头信息</span></span><br><span class="line">    res.setHeader(<span class="string">"Access-Control-Expose-Headers"</span>, <span class="string">"name"</span>);</span><br><span class="line">    <span class="comment">// 处理 OPTIONS 预检的存活时间，单位 s</span></span><br><span class="line">    res.setHeader(<span class="string">"Access-Control-Max-Age"</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 发送 PUT 请求会做一个试探性的请求 OPTIONS，其实是请求了两次，当接收的请求为 OPTIONS 时不做任何处理</span></span><br><span class="line">    <span class="keyword">if</span> (req.method === <span class="string">"OPTIONS"</span>) &#123;</span><br><span class="line">      res.end();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.put(<span class="string">"/getDate"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// res.setHeader('name', 'nihao'); // 设置自定义响应头信息</span></span><br><span class="line">  res.end(<span class="string">"I love you"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">"/getDate"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.end(<span class="string">"I love you"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(express.static(__dirname));</span><br><span class="line">app.listen(<span class="number">4000</span>);</span><br></pre></td></tr></table></figure><h2 id="方法三、使用-postMessage-实现跨域"><a href="#方法三、使用-postMessage-实现跨域" class="headerlink" title="方法三、使用 postMessage 实现跨域"></a>方法三、使用 postMessage 实现跨域</h2><p>postMessage 是 H5 的新 API，跨文档消息传送（cross-document messaging），有时简称为 XMD，指的是在来自不同域的页面间传递消息。</p><p><font color="#dd0000">使用场景：不是使用 Ajax 的数据通信，更多是在两个页面之间的通信，在 A 页面中引入 B 页面，使用iframe 标签, 在 A、B 两个页面之间通信。</font><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- a.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://localhost:4000/b.html"</span> <span class="attr">id</span>=<span class="string">"frame"</span> <span class="attr">onload</span>=<span class="string">"load()"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> frame = <span class="built_in">document</span>.getElementById(<span class="string">'frame'</span>);</span></span><br><span class="line"><span class="javascript">      frame.contentWindow.postMessage(<span class="string">'I love you'</span>, <span class="string">'http://localhost:4000'</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(e.data);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- b.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 打印来自页面 A 的消息</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(e.data);</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 给页面 A 发送回执</span></span></span><br><span class="line"><span class="javascript">      e.source.postMessage(<span class="string">'I love you, too'</span>, e.origin);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="方法四、使用-window-name-实现跨域"><a href="#方法四、使用-window-name-实现跨域" class="headerlink" title="方法四、使用 window.name 实现跨域"></a>方法四、使用 window.name 实现跨域</h2><p>同样是页面之间的通信，需要借助 iframe 标签<br>案例说明：A 页面和 B 页面是同域的 <a href="http://localhost:3000，C" target="_blank" rel="noopener">http://localhost:3000，C</a> 页面在独立的域 <a href="http://localhost:4000。" target="_blank" rel="noopener">http://localhost:4000。</a><br>在 A 页面中将 iframe 的 src 指向 C 页面，在 C 页面中将属性值存入 window.name 中，<br>再把 iframe 的 src 换成同域的 B 页面，在当前的 iframe 的 window 对象中取出 name 的值，访问 <a href="http://localhost:3000/a.html。" target="_blank" rel="noopener">http://localhost:3000/a.html。</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- a.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://localhost:4000/c.html"</span> <span class="attr">id</span>=<span class="string">"frame"</span> <span class="attr">onload</span>=<span class="string">"load()"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 增加一个标识，第一次触发 load 时更改地址，更改后再次触发直接取值</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> isFirst = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> frame = <span class="built_in">document</span>.getElementById(<span class="string">'frame'</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span>(isFirst) &#123;</span></span><br><span class="line"><span class="javascript">        frame.src = <span class="string">'http://localhost:3000/b.html'</span>;</span></span><br><span class="line"><span class="javascript">        isFirst = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(frame.contentWindow.name);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- c.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.name = <span class="string">'I love you'</span>;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="方法五、使用-location-hash-实现跨域"><a href="#方法五、使用-location-hash-实现跨域" class="headerlink" title="方法五、使用 location.hash 实现跨域"></a>方法五、使用 location.hash 实现跨域</h2><p><font color="#dd0000">与 window.name 跨域的情况相同，是不同域的页面间的参数传递</font><br>案例说明：需要借助 iframe 标签，A 页面和 B 页面是同域的 <a href="http://localhost:3000，C" target="_blank" rel="noopener">http://localhost:3000，C</a> 页面是独立的域 <a href="http://localhost:4000。" target="_blank" rel="noopener">http://localhost:4000。</a><br>A 页面通过 iframe 引入 C 页面，并给 C 页面传一个 hash 值，C 页面收到 hash 值后创建 iframe 引入 B 页面，<br>把 hash 值传给 B 页面，B 页面将自己的 hash 值放在 A 页面的 hash 值中，访问 <a href="http://localhost:3000/a.html。" target="_blank" rel="noopener">http://localhost:3000/a.html。</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- a.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://localhost:4000/c.html#Iloveyou"</span> <span class="attr">id</span>=<span class="string">"frame"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 使用 hashchange 事件接收来自 B 页面设置给 A 页面的 hash 值</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(location.hash);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- c.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 打印 A 页面引入 C 页面设置的 hash 值</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(location.hash);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span></span><br><span class="line"><span class="javascript">    iframe.src = <span class="string">'http://localhost:3000/b.html#Iloveyoutoo'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.appendChild(iframe);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- b.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 将 C 页面引入 B 页面设置的 hash 值设置给 A页面</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.parent.parent.location.hash = location.hash;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="方法六、使用-document-domain-实现跨域"><a href="#方法六、使用-document-domain-实现跨域" class="headerlink" title="方法六、使用 document.domain 实现跨域"></a>方法六、使用 document.domain 实现跨域</h2><p><font color="#dd0000">使用场景：不是万能的跨域方式，大多使用于同一公司不同产品间获取数据，必须是一级域名和二级域名的关系，如 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 与 video.baidu.com 之间。</font><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- http://www.domainacross.com:3000/a.html。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是页面 A 的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://sucess.domainacross.com:3000/b.html"</span> <span class="attr">onload</span>=<span class="string">"load()"</span> <span class="attr">id</span>=<span class="string">"frame"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.domain = <span class="string">'domainacross.com'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(frame.contentWindow.message);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是 B 页面的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.domain = <span class="string">'domainacross.com'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> message = <span class="string">'Hello A'</span>;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="方法七、使用-WebSocket-实现跨域"><a href="#方法七、使用-WebSocket-实现跨域" class="headerlink" title="方法七、使用 WebSocket 实现跨域"></a>方法七、使用 WebSocket 实现跨域</h2><p>Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信。<br>WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主<br>动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。<br>WebSocket 与 HTTP 内部都是基于 TCP 协议，区别在于 HTTP 是单向的（单双工），WebSocket 是双向的（全双工），协议是 ws:// 和 wss:// 对应 http:// 和 https://，因为没有跨域限制，所以使用 file:// 协议也可以进行通信。</p><p>WebSocket 没有跨域限制，高级 API（不兼容），想要兼容低版本浏览器，可以使用 socket.io 的库，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>user input：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./socket.io.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> socket = io(<span class="string">'http://www.domain2.com:8080'</span>);</span></span><br><span class="line"><span class="javascript"><span class="comment">// 连接成功处理</span></span></span><br><span class="line"><span class="javascript">socket.on(<span class="string">'connect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 监听服务端消息</span></span></span><br><span class="line"><span class="javascript">  socket.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'data from server: ---&gt; '</span> + msg); </span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 监听服务端关闭</span></span></span><br><span class="line"><span class="javascript">  socket.on(<span class="string">'disconnect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'Server socket has closed.'</span>); </span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="undefined">&#125;);</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'input'</span>)[<span class="number">0</span>].onblur = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  socket.send(<span class="keyword">this</span>.value);</span></span><br><span class="line"><span class="undefined">&#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Nodejs socket后台：</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> socket = <span class="built_in">require</span>(<span class="string">'socket.io'</span>);</span><br><span class="line"><span class="comment">// 启http服务</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">      <span class="string">'Content-type'</span>: <span class="string">'text/html'</span></span><br><span class="line">  &#125;);</span><br><span class="line">  res.end();</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="string">'8080'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server is running at port 8080...'</span>);</span><br><span class="line"><span class="comment">// 监听socket连接</span></span><br><span class="line">socket.listen(server).on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">client</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 接收信息</span></span><br><span class="line">  client.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    client.send(<span class="string">'hello：'</span> + msg);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'data from client: ---&gt; '</span> + msg);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 断开处理</span></span><br><span class="line">  client.on(<span class="string">'disconnect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Client socket has closed.'</span>); </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="方法八、使用-nginx-实现跨域"><a href="#方法八、使用-nginx-实现跨域" class="headerlink" title="方法八、使用 nginx 实现跨域"></a>方法八、使用 nginx 实现跨域</h2><h2 id="方法九、使用-http-proxy-middleware-实现跨域"><a href="#方法九、使用-http-proxy-middleware-实现跨域" class="headerlink" title="方法九、使用 http-proxy-middleware 实现跨域"></a>方法九、使用 http-proxy-middleware 实现跨域</h2><p>NodeJS 中间件 http-proxy-middleware 实现跨域代理，原理大致与 nginx 相同，都是通过启一个代理服务器，实现数据的转发，<br>也可以通过设置 cookieDomainRewrite 参数修改响应头中 cookie 中的域名，实现当前域的 cookie 写入，方便接口登录认证。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;同源： “协议 + 域名 + 端口” 三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。&lt;br&gt;同源策略限制下 &lt;code&gt;cookie&lt;/code&gt;、&lt;code&gt;localStorage&lt;/code&gt;、&lt;code&gt;IndexedDB&lt;/code&gt;、&lt;code&gt;
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Http协议知识</title>
    <link href="http://yoursite.com/2018/10/12/%5BHttp%5D%20Http%E5%8D%8F%E8%AE%AE%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2018/10/12/[Http] Http协议知识/</id>
    <published>2018-10-12T07:44:41.000Z</published>
    <updated>2018-10-29T13:04:42.602Z</updated>
    
    <content type="html"><![CDATA[<h2 id="http协议的请求报文组成格式"><a href="#http协议的请求报文组成格式" class="headerlink" title="http协议的请求报文组成格式"></a>http协议的请求报文组成格式</h2><p>HTTP请求报文组成：请求行（＜request-line＞）、请求头部（＜headers＞）、空行（＜blank line＞）和请求数据（＜request-body＞）。</p><h4 id="1-请求行"><a href="#1-请求行" class="headerlink" title="1. 请求行"></a>1. 请求行</h4><p>请求行组成：请求方法、URL和HTTP协议版本字段组成，它们用空格分隔。<br>例如，GET /index.html HTTP/1.1。</p><font color="#dd0000">HTTP协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。</font><h4 id="2-请求头部"><a href="#2-请求头部" class="headerlink" title="2.请求头部"></a>2.请求头部</h4><p>请求头部通知服务器有关于客户端请求的信息：<br><code>User-Agent</code>：产生请求的浏览器类型。<br><code>Accept</code>：客户端可识别的内容类型列表。<br><code>Host</code>：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。</p><h4 id="3-请求数据"><a href="#3-请求数据" class="headerlink" title="3.请求数据"></a>3.请求数据</h4><p><font color="#dd0000">请求数据不在GET方法中使用，而是在POST方法中使用。</font><br>与请求数据相关的最常使用的请求头是Content-Type和Content-Length。</p><h2 id="http协议的响应报文组成格式"><a href="#http协议的响应报文组成格式" class="headerlink" title="http协议的响应报文组成格式"></a>http协议的响应报文组成格式</h2><p>HTTP响应也组成：状态行（＜status-line＞）、消息报头（＜headers＞）、响应正文（＜response-body＞）。</p><h4 id="1-状态行"><a href="#1-状态行" class="headerlink" title="1.状态行"></a>1.状态行</h4><p>状态行（status line）通过提供一个状态码来说明所请求的资源情况。</p><p>状态行格式：服务器HTTP协议的版本（HTTP-Version） 服务器发回的响应状态代码（Status-Code） 状态代码的文本描述（Reason-Phrase） CRLF<br>状态代码：</p><ul><li>1xx：指示信息–表示请求已接收，继续处理。</li><li>2xx：成功–表示请求已被成功接收、理解、接受。</li><li>3xx：重定向–要完成请求必须进行更进一步的操作。</li><li>4xx：客户端错误–请求有语法错误或请求无法实现。</li><li><p>5xx：服务器端错误–服务器未能实现合法的请求。</p></li><li><p>200 OK：客户端请求成功。</p></li><li>400 Bad Request：客户端请求有语法错误，不能被服务器所理解。</li><li>401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。</li><li>403 Forbidden：服务器收到请求，但是拒绝提供服务。</li><li>404 Not Found：请求资源不存在，举个例子：输入了错误的URL。</li><li>500 Internal Server  Error：服务器发生不可预期的错误。</li><li>503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。</li></ul><h2 id="状态码302与301的区别"><a href="#状态码302与301的区别" class="headerlink" title="状态码302与301的区别"></a>状态码302与301的区别</h2><p>302重定向表示临时性转移(Temporarily Moved )，当一个网页URL需要短期变化时使用。<br>301重定向/跳转一般，表示本网页永久性转移到另一个地址。<br>301是永久性转移(Permanently Moved), SEO常用的招式，会把旧页面的PR等信息转移到新页面<br>301重定向是永久的重定向，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。<br>302重定向是临时的重定向，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;http协议的请求报文组成格式&quot;&gt;&lt;a href=&quot;#http协议的请求报文组成格式&quot; class=&quot;headerlink&quot; title=&quot;http协议的请求报文组成格式&quot;&gt;&lt;/a&gt;http协议的请求报文组成格式&lt;/h2&gt;&lt;p&gt;HTTP请求报文组成：请求行（＜re
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Project Display</title>
    <link href="http://yoursite.com/2018/10/11/Project-Display/"/>
    <id>http://yoursite.com/2018/10/11/Project-Display/</id>
    <published>2018-10-11T05:10:11.000Z</published>
    <updated>2018-10-11T07:35:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="商城首页"><a href="#商城首页" class="headerlink" title="商城首页"></a>商城首页</h2><p><img src="http://pfuoi64aq.bkt.clouddn.com/%E9%A6%96%E9%A1%B5-%E9%A6%96%E9%A1%B5.png" width="70%" height="70%"></p><h2 id="红包雨活动"><a href="#红包雨活动" class="headerlink" title="红包雨活动"></a>红包雨活动</h2><h3 id="图1"><a href="#图1" class="headerlink" title="图1:"></a>图1:</h3><p><img src="http://pfuoi64aq.bkt.clouddn.com/WechatIMG505.jpeg" width="70%" height="70%"></p><h3 id="图2"><a href="#图2" class="headerlink" title="图2:"></a>图2:</h3><p><img src="http://pfuoi64aq.bkt.clouddn.com/WechatIMG506.jpeg" width="70%" height="70%"></p><h2 id="小程序-红包拼团"><a href="#小程序-红包拼团" class="headerlink" title="小程序 红包拼团"></a>小程序 红包拼团</h2><h3 id="图1-1"><a href="#图1-1" class="headerlink" title="图1:"></a>图1:</h3><p><img src="http://pfuoi64aq.bkt.clouddn.com/WechatIMG503.jpeg" width="40%" height="40%"></p><h3 id="图2-1"><a href="#图2-1" class="headerlink" title="图2:"></a>图2:</h3><p><img src="http://pfuoi64aq.bkt.clouddn.com/WechatIMG501.jpeg" width="40%" height="40%"></p><h3 id="图3"><a href="#图3" class="headerlink" title="图3:"></a>图3:</h3><p><img src="http://pfuoi64aq.bkt.clouddn.com/WechatIMG502.jpeg" width="40%" height="40%"></p><h3 id="图4"><a href="#图4" class="headerlink" title="图4:"></a>图4:</h3><p><img src="http://pfuoi64aq.bkt.clouddn.com/%E5%9B%BE%E7%89%87.png" alt="小程序 红包拼团"></p><h2 id="小程序-魅客分销"><a href="#小程序-魅客分销" class="headerlink" title="小程序 魅客分销"></a>小程序 魅客分销</h2><p><img src="http://pfuoi64aq.bkt.clouddn.com/IMG_2419.PNG" alt="小程序 魅客分销"></p><h2 id="前端异常监控-性能检测"><a href="#前端异常监控-性能检测" class="headerlink" title="前端异常监控 性能检测"></a>前端异常监控 性能检测</h2><h3 id="图1-2"><a href="#图1-2" class="headerlink" title="图1:"></a>图1:</h3><p><img src="http://pfuoi64aq.bkt.clouddn.com/WechatIMG499.jpeg" width="70%" height="70%"></p><h3 id="图2-2"><a href="#图2-2" class="headerlink" title="图2:"></a>图2:</h3><p><img src="http://pfuoi64aq.bkt.clouddn.com/WechatIMG500.jpeg" width="70%" height="70%"></p><h3 id="图3-1"><a href="#图3-1" class="headerlink" title="图3:"></a>图3:</h3><p><img src="http://pfuoi64aq.bkt.clouddn.com/WechatIMG498.jpeg" width="70%" height="70%"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;商城首页&quot;&gt;&lt;a href=&quot;#商城首页&quot; class=&quot;headerlink&quot; title=&quot;商城首页&quot;&gt;&lt;/a&gt;商城首页&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://pfuoi64aq.bkt.clouddn.com/%E9%A6%96%E9%A1%B5-
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Ajax 原理</title>
    <link href="http://yoursite.com/2018/09/30/%5BJS%5D%20Ajax%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/09/30/[JS] Ajax原理/</id>
    <published>2018-09-30T09:20:31.000Z</published>
    <updated>2018-10-18T14:38:24.563Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://jartto.wang/2015/09/01/chattered-about-ajax/" target="_blank" rel="noopener">http://jartto.wang/2015/09/01/chattered-about-ajax/</a></p><p><a href="http://jartto.wang/2015/10/01/advantage-and-disadvantages-of-Ajax/" target="_blank" rel="noopener">http://jartto.wang/2015/10/01/advantage-and-disadvantages-of-Ajax/</a></p><p>Ajax函数的封装<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url, fnSucc, fnFailed</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> oAjax;</span><br><span class="line">  <span class="comment">// 1、建立Ajax对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHTTPRequest) &#123;</span><br><span class="line">    oAjax = <span class="keyword">new</span> XMLHTTPRequest();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    oAjax = <span class="keyword">new</span> ActiveXObjext(<span class="string">'Micosoft.XMLHTTP'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2、连接服务器（打开和连接服务器）</span></span><br><span class="line">  oAjax.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// 3、发送</span></span><br><span class="line">  oAjax.send();</span><br><span class="line">  <span class="comment">// 4、接收</span></span><br><span class="line">  oAjax.onreadyStateChange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (oAjax.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (oAjax.status === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="comment">// fnSucc</span></span><br><span class="line">        fnSucc(oAjax.requesText);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fnSucc(oAjax.status);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://jartto.wang/2015/09/01/chattered-about-ajax/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://jartto.wang/2015/09/01/chattered-abou
      
    
    </summary>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
</feed>
