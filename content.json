{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"rubyliuqq","url":"http://yoursite.com"},"pages":[{"title":"书单","date":"2018-10-15T15:07:38.673Z","updated":"2018-10-08T02:08:44.000Z","comments":false,"path":"books/index.html","permalink":"http://yoursite.com/books/index.html","excerpt":"","text":"douban 豆瓣书单douban: user: 琴琴0126 # 豆瓣用户名 start: 0 # 从哪一条记录开始 count: 100 # 获取豆瓣书单数据条数"},{"title":"Repositories","date":"2018-10-15T15:07:38.656Z","updated":"2018-10-08T02:02:09.000Z","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":"Githubgithub: username: rubyliuqq # github username"}],"posts":[{"title":"webpack 到应用","slug":"[构建] webpack到应用","date":"2018-10-17T16:39:31.000Z","updated":"2018-10-18T14:38:28.657Z","comments":true,"path":"2018/10/18/[构建] webpack到应用/","link":"","permalink":"http://yoursite.com/2018/10/18/[构建] webpack到应用/","excerpt":"","text":"ES6项目TypeScript项目Flow 检查器 ES6项目可以使用.bablerc对ES6、ES7进行配置123456789101112131415161718module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.js$/, use: ['babel-loader'], &#125;, ] &#125;, // 输出 source-map 方便直接调试 ES6 源码 devtool: 'source-map'&#125;;// 安装依赖// Webpack 接入 Babel 必须依赖的模块npm i -D babel-core babel-loader // 根据你的需求选择不同的 Plugins 或 Presetsnpm i -D babel-preset-env TypeScript项目Ts 是 Js 的一个超集，主要提供了类型检查系统和对 ES6 语法的支持，但不支持新的 API。方法一：建立配置编译选项的tsconfig.json文件方法二：集成Webpack需要解决以下2个问题：1、通过 Loader 把 Ts 转换成 Js。 推荐 awesome-typescript-loader。 安装：npm i -D typescript awesome-typescript-loader2、Webpack 在寻找模块对应的文件时需要尝试 ts 后缀，解决办法：修改默认的 resolve.extensions 配置项12345678910111213141516171819202122232425262728293031323334// tsconfig.json&#123; \"compilerOptions\": &#123; \"module\": \"commonjs\", // 编译出的代码采用的模块规范 \"target\": \"es5\", // 编译出的代码采用 ES 的哪个版本 \"sourceMap\": true, // 输出 Source Map 方便调试 \"importHelpers\": true // 避免代码冗余 &#125;, \"exclude\": [ // 不编译这些目录里的文件 \"node_modules\" ]&#125;// 集成 Webpackmodule.exports = &#123; // 执行入口文件 entry: './main', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, './dist'), &#125;, resolve: &#123; extensions: ['.ts', '.js'] // 先尝试 ts 后缀的 TypeScript 源码文件 &#125;, module: &#123; rules: [ &#123; test: /\\.ts$/, loader: 'awesome-typescript-loader' &#125; ] &#125;, devtool: 'source-map', // 输出 Source Map 方便在浏览器里调试 TypeScript 代码&#125;; Flow检查器SCSSPostCSS","categories":[{"name":"构建","slug":"构建","permalink":"http://yoursite.com/categories/构建/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"ES6基础知识 — 字符串的扩展","slug":"[ES6]ES6基础知识—字符串的扩展","date":"2018-10-17T12:28:31.000Z","updated":"2018-10-17T15:33:17.791Z","comments":true,"path":"2018/10/17/[ES6]ES6基础知识—字符串的扩展/","link":"","permalink":"http://yoursite.com/2018/10/17/[ES6]ES6基础知识—字符串的扩展/","excerpt":"","text":"1、字符的Unicode表示法2、codePointAt3、String.fromCodePoint4、字符串的遍历器接口for…of…5、normalize6、includes(), startsWith(), endsWith()7、repeat8、padStart，padEnd9、matchAll10、模板字符串11、String.raw 1、字符的Unicode表示法JS允许采用\\uxxxx形式表示一个字符，其中xxxx表示字符的Unicode码点， 只限于码点在\\u0000~\\uFFFFJS 共有 6 种方法可以表示一个字符:12345'\\z' === 'z' // true'\\172' === 'z' // true'\\x7A' === 'z' // true'\\u007A' === 'z' // true'\\u&#123;7A&#125;' === 'z' // true ES6的改进 2、codePointAt能够正确说明字符的字节数，返回字符码点的十进制数 3、String.fromCodePointString.fromCharCode从码点返回对应字符，但不能识别 32 位的 UTF-16 字符String.fromCodePoint方法弥补不足，有多个参数，则它们会被合并成一个字符串返回 fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。 4、字符串的遍历器接口for…of…for…of…：字符串可被循环遍历，可以识别大于0xFFFF的码点 5、normalize用来将字符的不同表示方法统一为同样的形式，称为 Unicode 正规化（该方法可传参，具体需要再查） 6、includes, startsWith, endsWithindexOf一个字符串是否包含在另一个字符串中includes(str, n)是否找到了参数字符串，n表示开始搜索的位置：startsWith(str, n)参数字符串是否在原字符串的头部，n表示开始搜索的位置：endsWith(str, n)参数字符串是否在原字符串的尾部，n表示开始搜索的位置： 7、repeat将原字符串重复n次，参数若是小数，会被取整；参数是负数或者Infinity，会报错；参数NaN等同于 0。 8、padStart，padEndpadStart(n, str)：用于字符串在头部补全，n指定字符串的最小长度，arr用来补全的字符串。padEnd(n, str)：字符串在尾部补全，n指定字符串的最小长度，arr用来补全的字符串。如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。如果省略第二个参数，默认使用空格补全长度。 9、matchAll返回一个正则表达式在当前字符串的所有匹配 10、模板字符串${}和引号的使用 11、String.raw模板字符串的处理函数返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串String.rawHi\\n${2+3}!; // 返回 “Hi\\n5!”String.rawHi\\u000A!; // 返回 “Hi\\u000A!” 123456789101112131415161718192021222324252627282930313233343536373839404142// 1、codePointAtvar str = \"𠮷\";str.length; // length为2，无法正确返回，其为4字节的字符str.charAt(0); //'�' 会导致乱码str.charAt(1); //'�' 会导致乱码str.codePointAt(); // 结果:134071// 2、fromCodePointString.fromCodePoint(0x20BB7)// \"𠮷\"String.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\\uD83D\\uDE80y'// true// 3、字符串的遍历器接口for...of...for (let codePoint of 'foo') &#123; console.log(codePoint); // \"f\" // \"o\" // \"o\"&#125;let text = String.fromCodePoint(0x20BB7);for (let i of text) &#123; console.log(i); // \"𠮷\"&#125;// 4、includes(), startsWith(), endsWith()let s = 'Hello world!';s.startsWith('world', 6) // trues.endsWith('Hello', 5) // trues.includes('Hello', 6) // false// 5、repeat'hello'.repeat(2) // \"hellohello\"'na'.repeat(2.9) // \"nana\"'na'.repeat('na') // \"\"'na'.repeat('3') // \"nanana\"'na'.repeat(-0.9) // \"\"'na'.repeat(NaN) // \"\"'xxx'.padStart(2, 'ab') // 'xxx''xxx'.padEnd(2, 'ab') // 'xxx' 'abc'.padStart(10, '0123456789') // '0123456abc''x'.padStart(4) // ' x''x'.padEnd(4) // 'x '","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6基础知识 — let和const命令","slug":"[ES6]ES6基础知识—let和const命令","date":"2018-10-17T12:23:12.000Z","updated":"2018-10-17T13:29:59.865Z","comments":true,"path":"2018/10/17/[ES6]ES6基础知识—let和const命令/","link":"","permalink":"http://yoursite.com/2018/10/17/[ES6]ES6基础知识—let和const命令/","excerpt":"","text":"1、let和const的性质2、块级作用域3、顶层对象的属性4、global 对象 1、let和const的性质1、let、const声明的变量只在声明所在的块级作用域内有效；const 一旦声明变量，就必须立即初始化，不能留到以后赋值。2、不存在变量提升；3、暂时性死区: 在代码块内，只能在声明的位置后面使用；4、不允许在相同作用域内，重复声明同一个变量； 对于简单类型的数据（数值、字符串、布尔值），const等同于常量。对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。如果将对象冻结，可以使用Object.freeze方法。 1234567891011121314151617181920212223242526272829303132333435// 1、变量声明提升// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2;// 2、暂时性死区案例if (true) &#123; // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125;// 3、对象冻结const foo = Object.freeze(&#123;&#125;);// 常规模式时，下面一行不起作用；严格模式时，该行会报错foo.prop = 123;// 4、除了将对象本身冻结，对象的属性也应该冻结。var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach( (key, i) =&gt; &#123; if ( typeof obj[key] === 'object' ) &#123; constantize( obj[key] ); &#125; &#125;);&#125;; 2、块级作用域提出原因：内层变量可能会覆盖外层变量；用来计数的循环变量泄露为全局变量……实现作用：是在块内使用，不影响外面，外面的变量，内部也能定义。 ES6 有 6 种声明变量的方法：var、function、let、const、import、class 3、顶层对象的属性1234window.a = 1;a // 返回 1a = 2;window.a // 返回 2 上述代码的弊端：1、不能在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；2、其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；3、顶层对象的属性是到处可以读写的，这非常不利于模块化编程。4、window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 var命令和function命令声明的全局变量，依旧是顶层对象的属性； let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。1234567var a = 1;// 如果在 Node 的 REPL 环境，可以写成 global.a// 或者采用通用方法，写成 this.awindow.a // 返回 1let b = 1;window.b // 返回 undefined 4、global 对象目的：为了在不同的环境中都能获取到顶层对象。ES5顶层对象的获取：1、浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。2、浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。3、Node 里面，顶层对象是global，但其他环境都不支持。 同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。1、全局环境中，this会返回顶层对象。但Node 模块和 ES6 模块中，this返回的是当前模块。2、函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。3、不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么eval、new Function这些方法都可能无法使用。 提出了垫片库system.global.123456// CommonJS 的写法var global = require('system.global')();// ES6 模块的写法import getGlobal from 'system.global';const global = getGlobal();","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"移动浏览器的四大内核","slug":"[移动端]移动浏览器的四大内核","date":"2018-10-15T06:20:45.000Z","updated":"2018-10-15T06:21:22.000Z","comments":true,"path":"2018/10/15/[移动端]移动浏览器的四大内核/","link":"","permalink":"http://yoursite.com/2018/10/15/[移动端]移动浏览器的四大内核/","excerpt":"","text":"四大浏览器内核优缺点 Trident:因为在早期IE占有大量的市场份额，所以以前有很多网页是根据这个Trident的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好，同时存在许多安全Bug。 Gecko:优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，缺点是消耗很多的资源，比如内存。 Webkit:优点就是Webkit拥有清晰的源码结构、极快的渲染速度，缺点是对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。 Presto：Presto内核被称为公认的浏览网页速度最快的内核，同时也是处理JS脚本最兼容的内核，能在Windows、Mac及Linux操作系统下完美运行。","categories":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/categories/移动端/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/移动端/"}]},{"title":"跨域的实现方法","slug":"[JS]跨域的实现方法","date":"2018-10-15T03:09:12.000Z","updated":"2018-10-15T05:15:45.000Z","comments":true,"path":"2018/10/15/[JS]跨域的实现方法/","link":"","permalink":"http://yoursite.com/2018/10/15/[JS]跨域的实现方法/","excerpt":"","text":"同源： “协议 + 域名 + 端口” 三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。同源策略限制下 cookie、localStorage、dom、ajax、IndexDB 都是不支持跨域的。 方法一、使用 jsonp 跨域12345678910111213141516171819202122232425// 封装 jsonp 跨域请求的方法function jsonp(&#123; url, params, cb &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; // 创建一个 script 标签帮助我们发送请求 let script = document.createElement(\"script\"); let arr = []; params = &#123; ...params, cb &#125;; // 循环构建键值对形式的参数 for (let key in params) &#123; arr.push(`$&#123;key&#125;=$&#123;params[key]&#125;`); &#125; // 创建全局函数 window[cb] = function(data) &#123; resolve(data); // 在跨域拿到数据以后将 script 标签销毁 document.body.removeChild(script); &#125;; // 拼接发送请求的参数并赋值到 src 属性 script.src = `$&#123;url&#125;?$&#123;arr.join(\"&amp;\")&#125;`; document.body.appendChild(script); &#125;);&#125; 缺点：只能发送 get 请求 不支持 post、put、delete；不安全，容易引发 xss 攻击。## 方法二、使用 CORS 跨域使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。 使用场景：多用于开发时，前端与后台在不同的 ip 地址下进行数据访问。案例说明：通过访问 http://localhost:3000/index.html（服务器1） 获取 index.html 文件并执行其中的 Ajax 请求 http://localhost:4000/getDate（服务器2） 接口去获取数据。123456789101112131415161718192021222324let xhr = new XMLHttpRequest();// 正常 cookie 是不允许跨域的document.cookie = 'name=hello';// cookie 想要实现跨域必须携带凭证xhr.withCredentials = true;// xhr.open('GET', 'http://localhost:4000/getDate', true);xhr.open('PUT', 'http://localhost:4000/getDate', true);// 设置名为 name 的自定义请求头xhr.setRequestHeader('name', 'hello');xhr.onreadystatechange = function () &#123; if(xhr.readyState === 4) &#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304) &#123; // 打印返回的数据 console.log(xhr.response); // 打印后台设置的自定义头信息 console.log(xhr.getResponseHeader('name')); &#125; &#125;&#125;xhr.send(); 1234567891011121314151617181920212223242526272829303132333435363738394041// 服务器2const express = require(\"express\");let app = express();// 允许访问域的白名单let whiteList = [\"http://localhost:3000\"];app.use(function(req, res, next) &#123; let origin = req.header.origin; if (whiteList.includes(origin)) &#123; // 设置那个源可以访问我，参数为 * 时，允许任何人访问，但是不可以和 cookie 凭证的响应头共同使用 res.setHeader(\"Access-Control-Allow-Origin\", origin); // 想要获取 ajax 的头信息，需设置响应头 res.setHeader(\"Access-Control-Allow-Headers\", \"name\"); // 处理复杂请求的头 res.setHeader(\"Access-Control-Allow-Methods\", \"PUT\"); // 允许发送 cookie 凭证的响应头 res.setHeader(\"Access-Control-Allow-Credentials\", true); // 允许前端获取哪个头信息 res.setHeader(\"Access-Control-Expose-Headers\", \"name\"); // 处理 OPTIONS 预检的存活时间，单位 s res.setHeader(\"Access-Control-Max-Age\", 5); // 发送 PUT 请求会做一个试探性的请求 OPTIONS，其实是请求了两次，当接收的请求为 OPTIONS 时不做任何处理 if (req.method === \"OPTIONS\") &#123; res.end(); &#125; &#125; next();&#125;);app.put(\"/getDate\", function(req, res) &#123; // res.setHeader('name', 'nihao'); // 设置自定义响应头信息 res.end(\"I love you\");&#125;);app.get(\"/getDate\", function(req, res) &#123; res.end(\"I love you\");&#125;);app.use(express.static(__dirname));app.listen(4000); 方法三、使用 postMessage 实现跨域postMessage 是 H5 的新 API，跨文档消息传送（cross-document messaging），有时简称为 XMD，指的是在来自不同域的页面间传递消息。 使用场景：不是使用 Ajax 的数据通信，更多是在两个页面之间的通信，在 A 页面中引入 B 页面，使用iframe 标签, 在 A、B 两个页面之间通信。12345678910111213&lt;!-- a.html --&gt;&lt;body&gt; &lt;iframe src=\"http://localhost:4000/b.html\" id=\"frame\" onload=\"load()\"&gt;&lt;/iframe&gt; &lt;script&gt; function load() &#123; let frame = document.getElementById('frame'); frame.contentWindow.postMessage('I love you', 'http://localhost:4000'); window.onmessage = function (e) &#123; console.log(e.data); &#125; &#125; &lt;/script&gt;&lt;/body&gt; 1234567891011&lt;!-- b.html --&gt;&lt;body&gt; &lt;script&gt; window.onmessage = function (e) &#123; // 打印来自页面 A 的消息 console.log(e.data); // 给页面 A 发送回执 e.source.postMessage('I love you, too', e.origin); &#125; &lt;/script&gt;&lt;/body&gt; 方法四、使用 window.name 实现跨域同样是页面之间的通信，需要借助 iframe 标签案例说明：A 页面和 B 页面是同域的 http://localhost:3000，C 页面在独立的域 http://localhost:4000。在 A 页面中将 iframe 的 src 指向 C 页面，在 C 页面中将属性值存入 window.name 中，再把 iframe 的 src 换成同域的 B 页面，在当前的 iframe 的 window 对象中取出 name 的值，访问 http://localhost:3000/a.html。1234567891011121314151617&lt;!-- a.html --&gt;&lt;body&gt; &lt;iframe src=\"http://localhost:4000/c.html\" id=\"frame\" onload=\"load()\"&gt;&lt;/iframe&gt; &lt;script&gt; // 增加一个标识，第一次触发 load 时更改地址，更改后再次触发直接取值 let isFirst = true; function load() &#123; let frame = document.getElementById('frame'); if(isFirst) &#123; frame.src = 'http://localhost:3000/b.html'; isFirst = false; &#125; else &#123; console.log(frame.contentWindow.name); &#125; &#125; &lt;/script&gt;&lt;/body&gt; 123456&lt;!-- c.html --&gt;&lt;body&gt; &lt;script&gt; window.name = 'I love you'; &lt;/script&gt;&lt;/body&gt; 方法五、使用 location.hash 实现跨域与 window.name 跨域的情况相同，是不同域的页面间的参数传递案例说明：需要借助 iframe 标签，A 页面和 B 页面是同域的 http://localhost:3000，C 页面是独立的域 http://localhost:4000。A 页面通过 iframe 引入 C 页面，并给 C 页面传一个 hash 值，C 页面收到 hash 值后创建 iframe 引入 B 页面，把 hash 值传给 B 页面，B 页面将自己的 hash 值放在 A 页面的 hash 值中，访问 http://localhost:3000/a.html。12345678910&lt;!-- a.html --&gt;&lt;body&gt; &lt;iframe src=\"http://localhost:4000/c.html#Iloveyou\" id=\"frame\"&gt;&lt;/iframe&gt; &lt;script&gt; // 使用 hashchange 事件接收来自 B 页面设置给 A 页面的 hash 值 window.onhashchange = function () &#123; console.log(location.hash); &#125; &lt;/script&gt;&lt;/body&gt; 12345678910&lt;!-- c.html --&gt;&lt;body&gt; &lt;script&gt; // 打印 A 页面引入 C 页面设置的 hash 值 console.log(location.hash); let iframe = document.createElement('iframe'); iframe.src = 'http://localhost:3000/b.html#Iloveyoutoo'; document.body.appendChild(iframe); &lt;/script&gt;&lt;/body&gt; 1234567&lt;!-- b.html --&gt;&lt;body&gt; &lt;script&gt; // 将 C 页面引入 B 页面设置的 hash 值设置给 A页面 window.parent.parent.location.hash = location.hash; &lt;/script&gt;&lt;/body&gt; 方法六、使用 document.domain 实现跨域使用场景：不是万能的跨域方式，大多使用于同一公司不同产品间获取数据，必须是一级域名和二级域名的关系，如 www.baidu.com 与 video.baidu.com 之间。1234567891011&lt;!-- http://www.domainacross.com:3000/a.html。 --&gt;&lt;body&gt; &lt;p&gt;我是页面 A 的内容&lt;/p&gt; &lt;iframe src=\"http://sucess.domainacross.com:3000/b.html\" onload=\"load()\" id=\"frame\"&gt;&lt;/iframe&gt; &lt;script&gt; document.domain = 'domainacross.com'; function load() &#123; console.log(frame.contentWindow.message); &#125; &lt;/script&gt;&lt;/body&gt; 1234567&lt;body&gt; &lt;p&gt;我是 B 页面的内容&lt;/p&gt; &lt;script&gt; document.domain = 'domainacross.com'; var message = 'Hello A'; &lt;/script&gt;&lt;/body&gt; 方法七、使用 WebSocket 实现跨域WebSocket 没有跨域限制，高级 API（不兼容），想要兼容低版本浏览器，可以使用 socket.io 的库，WebSocket 与 HTTP 内部都是基于 TCP 协议，区别在于 HTTP 是单向的（单双工），WebSocket 是双向的（全双工），协议是 ws:// 和 wss:// 对应 http:// 和 https://，因为没有跨域限制，所以使用 file:// 协议也可以进行通信。123456789101112131415&lt;body&gt; &lt;script&gt; // 创建 webSocket let socket = new WebSocket('ws://localhost:3000'); // 连接上触发 socket.onopen = function () &#123; socket.send('I love you'); &#125; // 收到消息触发 socket.onmessage = function (e) &#123; // 打印收到的数据 console.log(e.data); // I love you, too &#125; &lt;/script&gt;&lt;/body&gt; 12345678910111213141516171819// 服务器const express = require(\"express\");let app = express();// 引入 webSocketconst WebSocket = require(\"ws\");// 创建连接，端口号与前端相对应let wss = new WebSocket.Server(&#123; port: 3000 &#125;);// 监听连接wss.on(\"connection\", function(ws) &#123; // 监听消息 ws.on(\"message\", function(data) &#123; // 打印消息 console.log(data); // I love you // 发送消息 ws.send(\"I love you, too\"); &#125;);&#125;); 方法八、使用 nginx 实现跨域方法九、使用 http-proxy-middleware 实现跨域NodeJS 中间件 http-proxy-middleware 实现跨域代理，原理大致与 nginx 相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置 cookieDomainRewrite 参数修改响应头中 cookie 中的域名，实现当前域的 cookie 写入，方便接口登录认证。","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"Http协议知识","slug":"[Http]Http协议知识","date":"2018-10-12T07:44:41.000Z","updated":"2018-10-12T08:00:44.000Z","comments":true,"path":"2018/10/12/[Http]Http协议知识/","link":"","permalink":"http://yoursite.com/2018/10/12/[Http]Http协议知识/","excerpt":"","text":"http协议的请求报文组成格式HTTP请求报文组成：请求行（＜request-line＞）、请求头部（＜headers＞）、空行（＜blank line＞）和请求数据（＜request-body＞）。 1. 请求行请求行组成：请求方法、URL和HTTP协议版本字段组成，它们用空格分隔。例如，GET /index.html HTTP/1.1。 HTTP协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。 2.请求头部请求头部通知服务器有关于客户端请求的信息：User-Agent：产生请求的浏览器类型。Accept：客户端可识别的内容类型列表。Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。 3.请求数据请求数据不在GET方法中使用，而是在POST方法中使用。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。 http协议的响应报文组成格式HTTP响应也组成：状态行（＜status-line＞）、消息报头（＜headers＞）、响应正文（＜response-body＞）。 1.状态行状态行（status line）通过提供一个状态码来说明所请求的资源情况。 状态行格式：服务器HTTP协议的版本（HTTP-Version） 服务器发回的响应状态代码（Status-Code） 状态代码的文本描述（Reason-Phrase） CRLF状态代码： 1xx：指示信息–表示请求已接收，继续处理。 2xx：成功–表示请求已被成功接收、理解、接受。 3xx：重定向–要完成请求必须进行更进一步的操作。 4xx：客户端错误–请求有语法错误或请求无法实现。 5xx：服务器端错误–服务器未能实现合法的请求。 200 OK：客户端请求成功。 400 Bad Request：客户端请求有语法错误，不能被服务器所理解。 401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。 403 Forbidden：服务器收到请求，但是拒绝提供服务。 404 Not Found：请求资源不存在，举个例子：输入了错误的URL。 500 Internal Server Error：服务器发生不可预期的错误。 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。 状态码302与301的区别302重定向表示临时性转移(Temporarily Moved )，当一个网页URL需要短期变化时使用。301重定向/跳转一般，表示本网页永久性转移到另一个地址。301是永久性转移(Permanently Moved), SEO常用的招式，会把旧页面的PR等信息转移到新页面301重定向是永久的重定向，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。302重定向是临时的重定向，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"}]},{"title":"Project Display","slug":"Project-Display","date":"2018-10-11T05:10:11.000Z","updated":"2018-10-11T07:35:30.000Z","comments":true,"path":"2018/10/11/Project-Display/","link":"","permalink":"http://yoursite.com/2018/10/11/Project-Display/","excerpt":"","text":"商城首页 红包雨活动图1: 图2: 小程序 红包拼团图1: 图2: 图3: 图4: 小程序 魅客分销 前端异常监控 性能检测图1: 图2: 图3:","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[]},{"title":"关于","slug":"about/index","date":"2018-10-08T02:22:49.000Z","updated":"2018-10-08T02:22:49.000Z","comments":false,"path":"2018/10/08/about/index/","link":"","permalink":"http://yoursite.com/2018/10/08/about/index/","excerpt":"","text":"个人详细介绍","categories":[],"tags":[]},{"title":"Ajax 原理","slug":"[JS] Ajax原理","date":"2018-09-30T09:20:31.000Z","updated":"2018-10-18T14:38:24.563Z","comments":true,"path":"2018/09/30/[JS] Ajax原理/","link":"","permalink":"http://yoursite.com/2018/09/30/[JS] Ajax原理/","excerpt":"","text":"http://jartto.wang/2015/09/01/chattered-about-ajax/ http://jartto.wang/2015/10/01/advantage-and-disadvantages-of-Ajax/ Ajax函数的封装123456789101112131415161718192021222324function ajax(url, fnSucc, fnFailed) &#123; const oAjax; // 1、建立Ajax对象 if (window.XMLHTTPRequest) &#123; oAjax = new XMLHTTPRequest(); &#125; else &#123; oAjax = new ActiveXObjext('Micosoft.XMLHTTP'); &#125; // 2、连接服务器（打开和连接服务器） oAjax.open('GET', url, true); // 3、发送 oAjax.send(); // 4、接收 oAjax.onreadyStateChange = function() &#123; if (oAjax.readyState === 4) &#123; if (oAjax.status === 200) &#123; // fnSucc fnSucc(oAjax.requesText); &#125; else &#123; fnSucc(oAjax.status); &#125; &#125; &#125;&#125;","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"Html5知识积累","slug":"[H5] Html5知识积累","date":"2018-09-30T06:59:31.000Z","updated":"2018-10-15T03:22:44.000Z","comments":true,"path":"2018/09/30/[H5] Html5知识积累/","link":"","permalink":"http://yoursite.com/2018/09/30/[H5] Html5知识积累/","excerpt":"","text":"sessionStorage 和 localStorageWeb Storage包括了两种存储方式：sessionStorage和localStorage。sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁，生命周期为当前窗口或标签页，一旦窗口或标签页被永久关闭了。 因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。 页面及标签页仅指顶级窗口，如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的。localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 web storage和cookie的区别：Web Storage是为了更大容量存储而设计。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。 Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要开发者自己封装setCookie,getCookie。 Cookie优点：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。 html5 web storage的浏览器支持情况:浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持。通过简单的代码封装可以统一到所有的浏览器都支持web storage。12345678910if(window.localStorage)&#123; // 浏览支持localStorage&#125;else&#123; // 浏览暂不支持localStorage&#125;//或者 if(typeof window.localStorage == 'undefined')&#123; // 浏览暂不支持localStorage&#125; setItem存储value 用途，.setItem(key, value)getItem获取value 用途，.getItem(key)removeItem删除key 用途，.removeItem(key)clear清除所有的key/value 用途， .clear()localStorage和sessionStorage的key和length属性实现遍历: sessionStorage和localStorage提供的key()和length可以方便的实现存储的数据遍历. 123456789101112131415161718sessionStorage.setItem(\"key\", \"value\"); localStorage.setItem(\"site\", \"js8.in\");var value = sessionStorage.getItem(\"key\"); var site = localStorage.getItem(\"site\");sessionStorage.removeItem(\"key\"); localStorage.removeItem(\"site\");sessionStorage.clear(); localStorage.clear();var storage = window.localStorage; for (var i=0, len = storage.length; i &lt; len; i++)&#123; var key = storage.key(i); var value = storage.getItem(key); console.log(key + \"=\" + value); &#125; web storage 的离线存储H5 的 Web storage API 采用了离线缓存，会生成一个清单文件（manifest file)，这个清单文件实质就是一系列的URL列表文件，这些URL分别指向页面当中的html,css,javascript,图片等相关内容。当使用离线应用时，应用会引入这一清单文件，浏览器会读取这一文件，下载相应的文件，并将其缓存到本地。使得这些web应用能够脱离网络使用，而用户在离线时的更改也同样会映射到清单文件中，并在重新连线之后将更改返回应用，工作方式与我们现在所使用的网盘有着异曲同工之处。首先，需要在页面头加入manifest属性：1234&lt;!DOCTYPE HTML&gt;&lt;html manifest = \"cache.manifest\"&gt;...&lt;/html&gt; 然后cache.manifest文件的书写方式为：123456789CACHE MANIFEST#v0.11CACHE:js/app.jscss/style.cssNETWORK:resourse/logo.pngFALLBACK:/ /offline.html 离线存储的manifest一般由三个部分组成: CACHE:表示需要离线存储的资源列表，由于包含manifest文件的页面将被自动离线存储，所以不需要把页面自身也列出来。 NETWORK:表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在CACHE和NETWORK中有一个相同的资源，那么这个资源还是会被离线存储，也就是说CACHE的优先级更高。 FALLBACK:表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问offline.html。 http://jartto.wang/2016/07/25/make-an-inventory-of-html5-api/","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"H5","slug":"H5","permalink":"http://yoursite.com/tags/H5/"}]},{"title":"正则表达式","slug":"[JS] 正则表达式","date":"2018-09-29T08:20:42.000Z","updated":"2018-10-08T02:21:34.000Z","comments":true,"path":"2018/09/29/[JS] 正则表达式/","link":"","permalink":"http://yoursite.com/2018/09/29/[JS] 正则表达式/","excerpt":"","text":"正则表达式是匹配模式，要么匹配字符，要么匹配位置。 正则表达式字符匹配攻略 两种模糊匹配：横向模糊和纵向模糊横向模糊指的是，一个正则可匹配的字符串的长度不是固定的。纵向模糊指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符。 字符组[123456abcdefGHIJKLM] 可以写成 [1-6a-fG-M]可以写成如下的方式：[-az]或[az-]或[a\\-z], 即要么放在开头，要么放在结尾，要么转义 排除字符组：例如[^abc]，表示是一个除”a”、”b”、”c”之外的任意一个字符。字符组的第一位放^（脱字符），表示求反。 \\d就是[0-9]。表示是一位数字。记忆方式：其英文是digit（数字） \\D就是[^0-9]。表示除数字外的任意字符。\\w就是[0-9a-zA-Z_]。表示数字、大小写字母和下划线。 \\W是[^0-9a-zA-Z_]。非单词字符。记忆方式：w是word的简写，也称单词字符。 \\s是[ \\t\\v\\n\\r\\f]。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。记忆方式：s是space character的首字母。 \\S是[^ \\t\\v\\n\\r\\f]。 非空白符。 .就是[^\\n\\r\\u2028\\u2029]。通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外。记忆方式：想想省略号…中的每个点，都可以理解成占位符，表示任何类似的东西。 量词： {m,} 表示至少出现m次。 {m} 等价于{m,m}，表示出现m次。 ? 等价于{0,1}，表示出现或者不出现。记忆方式：问号的意思表示，有吗？ + 等价于{1,}，表示出现至少一次。记忆方式：加号是追加的意思，得先有一个，然后才考虑追加。 * 等价于{0,}，表示出现任意次，有可能不出现。记忆方式：看看天上的星星，可能一颗没有，可能零散有几颗，可能数也数不过来。 贪婪匹配: 尽可能多的匹配惰性匹配: 尽可能少的匹配 多选分支(p1|p2|p3)，其中p1、p2和p3是子模式，用|（管道符）分隔，表示其中任何之一。 案例 匹配时间（24小时制）：/^(0?[0-9]|1[0-9]|[2][0-3]):(0?[0-9]|[1-5][0-9])$/ 匹配日期（yyyy-mm-dd格式）： /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/ window操作系统文件路径：/^[a-zA-Z]:\\\\([^\\\\:*&lt;&gt;|&quot;?\\r\\n/]+\\\\)*([^\\\\:*&lt;&gt;|&quot;?\\r\\n/]+)?$/eg：盘符:\\文件夹\\文件夹\\文件夹\\F:\\study\\javascript\\regex\\regular expression.pdfF:\\study\\javascript\\regex\\F:\\study\\javascriptF:\\ 文件名或者文件夹名，不能包含一些特殊字符，排除字符组[^\\\\:*&lt;&gt;|&quot;?\\r\\n/]来表示合法字符路径的最后一部分可以是“文件夹”，没有\\，因此需要添加([^\\\\:*&lt;&gt;|&quot;?\\r\\n/]+)? 正则表达式位置匹配攻略 ^（脱字符）匹配开头，在多行匹配中匹配行开头。 $（美元符号）匹配结尾，在多行匹配中匹配行结尾。 \\b 是单词边界，具体就是\\w和\\W之间的位置，也包括\\w和^之间的位置，也包括\\w和$之间的位置。\\w是字符组[0-9a-zA-Z_]的简写形式， \\B 是\\b的反面的意思，非单词边界 (?=p) 其中p是一个子模式，即p前面的位置。eg：(?=l)，表示’l’字符前面的位置。（positive lookahead） (?!p) 是(?=p)的反面意思。（negative lookahead） 案例 不匹配任何东西的正则: /.^/ 数字的千位分隔符表示法: “12,345,678” 正则为：/(?!^)(?=(\\d{3})+$)/g“12345678 123456789” 替换成”12,345,678 123,456,789” 正则为: /\\B(?=(\\d{3})+\\b)/g，其中 (?!\\b) 为 \\B 必须包含数字: (?=.*[0-9]) 同时包含数字和小写字母: (?=.*[0-9])(?=.*[a-z]) 密码长度6-12位，由数字、小写字符和大写字母组成，但必须至少包括2种字符。/((?=.*[0-9])(?=.*[a-z])|(?=.*[0-9])(?=.*[A-Z])|(?=.*[a-z])(?=.*[A-Z]))^[0-9A-Za-z]{6,12}$/ 正则表达式括号的作用 “2017-06-12”.replace(/(\\d{4})-(\\d{2})-(\\d{2})/, “$2/$3/$1”); // “06/12/2017” 匹配”2016-06-12”、”2016/06/12”、”2016.06.12” 正则为: /\\d{4}(-|\\/|\\.)\\d{2}\\1\\d{2}/注意里面的\\1，表示的引用之前的那个分组(-|\\/|\\.)。不管它匹配到什么（比如-），\\1都匹配那个同样的具体某个字符。 括号嵌套 \\10表示第10个分组 123var regex = /(1)(2)(3)(4)(5)(6)(7)(8)(9)(#) \\10+/;var string = \"123456789# ######\"console.log( regex.test(string) ); // =&gt; true 引用不存在的分组因为反向引用，是引用前面的分组，但我们在正则里引用了不存在的分组时，此时正则不会报错，只是匹配反向引用的字符本身。 [x] 字符串trim方法模拟 1234function trim(str) &#123; return str.replace(/^\\s+|\\s+$/g, '');&#125;console.log( trim(\" foobar \") ); // =&gt; \"foobar\" [x] 将每个单词的首字母转换为大写 123456function titleize(str) &#123; return str.toLowerCase().replace(/(?:^|\\s)\\w/g, function(c) &#123; return c.toUpperCase(); &#125;);&#125;console.log( titleize('my name is epeli') ); // =&gt; \"My Name Is Epeli\" [x] 驼峰化 123456function camelize(str) &#123; return str.replace(/[-_\\s]+(.)?/g, function(match, c) &#123; return c ? c.toUpperCase() : ''; &#125;);&#125;console.log( camelize('-moz-transform') ); // =&gt; \"MozTransform\" [x] 匹配成对标签 /&lt;([^&gt;]+)&gt;[\\d\\D]*&lt;\\/\\1&gt;/开标签: &lt;[^&gt;]+&gt;, 闭标签: &lt;\\/[^&gt;]+&gt;[\\d\\D]的意思是，这个字符是数字或者不是数字，因此，也就是匹配任意字符的意思。 正则表达式回溯法原理正则表达式的拆分正则表达式的构建正则表达式编程正则表达式的一些规则RegExp对象的方法： test：在字符串中测试模式匹配,返回 true 或 false exec：在字符串中执行匹配搜索,返回结果数组 match(pattern)：返回 pattern 中的子串或 null replace(pattern, replacement)：用 replacement 替换 pattern search(pattern)：返回字符串中 pattern 开始位置 split(pattern)：返回字符串按指定 pattern 拆分的数组","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"webpack 优化项目策略","slug":"[构建] webpack优化项目","date":"2018-09-29T02:20:51.000Z","updated":"2018-10-17T16:39:58.131Z","comments":true,"path":"2018/09/29/[构建] webpack优化项目/","link":"","permalink":"http://yoursite.com/2018/09/29/[构建] webpack优化项目/","excerpt":"","text":"DllReferencePlugin: 将打包好的dll文件传入构建的代码里面AddAssetHtmlPlugin: 在生成的html文件中加入dll文件的script引用imagemin-webpack-plugin: 压缩图片；webpack-spritesmith: 插件制作雪碧图 png: file-loader 可以把 JS 和 CSS 中导入图片的语句替换成正确的地址，并同时把文件输出到对应的位置。url-loader 经 base64 编码后注入到 JS 或者 CSS 中去。svg: raw-loader 可以把文本文件的内容读取出来，注入到 JS 或 CSS 中去。 动态链接库DLL加速的原因：包含大量复用模块的动态链接库只需要编译一次，在之后的构建过程中被动态链接库包含的模块将不会在重新编译，而是直接使用动态链接库中的代码。动态链接库中大多数包含的是常用的第三方模块，例如 react、react-dom，只要不升级这些模块的版本，动态链接库就不用重新编译。","categories":[{"name":"构建","slug":"构建","permalink":"http://yoursite.com/categories/构建/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"前端工程化","slug":"前端工程化","date":"2018-09-28T06:29:31.000Z","updated":"2018-10-08T02:21:03.000Z","comments":true,"path":"2018/09/28/前端工程化/","link":"","permalink":"http://yoursite.com/2018/09/28/前端工程化/","excerpt":"","text":"前端工程化：开发需求、共享需求、性能需求、部署需求。为了简化前端工程化的配置，出现了很多优秀的工具比如：1、前端工作流工具：Gulp，Grunt，Broccoli2、前端 JS 模块编译工具：Babel，Browserify，Webpack3、前端开发系列工具： livereload，数据 mock，代码监控，代码检查 开发需求在开始一个前端项目时，通常需要进行技术选型，定义代码规范以及配合后端和业务进行项目的目录规划 代码规范：jslint、SASSLint、ESLint/TSLint…. JS 预处理：（编译过程） 编程语言：Coffeescript、Livescript、Typescript、React Jsx、Dart、Elm…. ES6 CommonJS Typescript 中提供静态语法的一些强类型特性。Coffeescript, Livescript 提供现代化语言的语法糖特性，专门针对 xml 优化的 JSX。 CSS 预处理：less、sass…预处理工具：Autoprefixer、Compass 文件处理： src 放置源码，dist 放置编译后的代码 开发效率：webpack的Hot Module Replacement， livereload 自动刷新浏览器 数据 mock：可构建mock平台 域名代理 共享需求设计前端项目架构时，一定要考虑业务的组件化和可共享性： Base 基础代码共享 通用工具方法共享 基础交互组件共享 业务组件共享 性能需求优化源码的体积是提升首屏加载时间的关键： Javascript, Css 代码压缩 Javascript, Css 代码合并 图片压缩 Css 图片精灵或雪碧图（css sprit） 可以在前端工程的 build 过程中实现。 部署需求 多人分支协作流程：用 git flow 来管理代码分支 代码自动发布：git hookgit hook实现代码自动部署 前端工作流工具 Grunt: 基于配置的工作流模式，定义一个配置文件，声明工作流各个环节的相关配置，调用 grunt 就能完成打包编译. Broccoli: 以 tree 的基础结构，提供极其高效稳定的工作流。 Gulp: 基于内存的流的方式，提供高效的性能，极简的 API，定义不同的 task，然后将 task 串联起来。 前端 Javascript 编译工具 Babel Browserify: 是最先出现的 CommonJs 编译工具，使得我们可以像写 Node 模块一样写前端代码，Browserify 可以 build 使用 npm 中的所有模块。 Webpack: 是支持 CommonJs 和 AMD 的模块编译工具，逐渐替代 Browserify, 基于 AMD 的好处就是代码可以异步话，这是 Browserify 无法做到的。","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"}]},{"title":"parceljs & webpack","slug":"[构建] parceljs & webpack","date":"2018-09-28T06:29:31.000Z","updated":"2018-10-08T02:21:31.000Z","comments":true,"path":"2018/09/28/[构建] parceljs & webpack/","link":"","permalink":"http://yoursite.com/2018/09/28/[构建] parceljs & webpack/","excerpt":"","text":"","categories":[{"name":"构建","slug":"构建","permalink":"http://yoursite.com/categories/构建/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack 进阶","slug":"[构建] webpack进阶","date":"2018-09-28T06:09:21.000Z","updated":"2018-10-17T16:45:50.885Z","comments":true,"path":"2018/09/28/[构建] webpack进阶/","link":"","permalink":"http://yoursite.com/2018/09/28/[构建] webpack进阶/","excerpt":"","text":"在使用 webpack 构建的典型应用程序或站点中，有三种主要的代码类型：1、团队编写的源码。2、源码会依赖的任何第三方的 library 或 “vendor” 代码。3、webpack 的 runtime 和 manifest，管理所有模块的交互。runtime 包含：在模块交互时，连接模块所需的加载和解析逻辑。包括浏览器中的已加载模块的连接，以及懒加载模块的执行逻辑。通过使用 manifest 中的数据，runtime 将能够查询模块标识符，检索出背后对应的模块。import 或 require 语句现在都已经转换为 webpack_require 方法，此方法指向模块标识符(module identifier) 配置分离在大型项目中，webpack.config.js 会变得越来越臃肿，因此可以利用 webpack-merge 插件。将配置定义在一个目录下面的不同文件中，然后通过 webpack-merge 来合并成最终的配置。 code splitting 异步加载","categories":[{"name":"构建","slug":"构建","permalink":"http://yoursite.com/categories/构建/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack 入门","slug":"[构建] webpack入门","date":"2018-09-28T03:42:48.000Z","updated":"2018-10-17T17:09:38.655Z","comments":true,"path":"2018/09/28/[构建] webpack入门/","link":"","permalink":"http://yoursite.com/2018/09/28/[构建] webpack入门/","excerpt":"","text":"论述CommonJS 是一种使用广泛的 JavaScript 模块化规范，核心思想是通过 require 方法来同步地加载依赖的其他模块，通过 module.exports 导出需要暴露的接口。CommonJS 的优点在于： 代码可复用于 Node.js 环境下并运行，例如做同构应用； 通过 NPM 发布的很多第三方模块都采用了 CommonJS 规范。 CommonJS 的缺点在于这样的代码无法直接运行在浏览器环境下，必须通过工具转换成标准的 ES5。 AMD 也是一种 JavaScript 模块化规范，与 CommonJS 最大的不同在于它采用异步的方式去加载依赖的模块。 AMD 规范主要是为了解决针对浏览器环境的模块化问题，最具代表性的实现是 requirejs。AMD 的优点在于： 可在不转换代码的情况下直接在浏览器中运行； 可异步加载依赖； 可并行加载多个依赖； 代码可运行在浏览器环境和 Node.js 环境下。 AMD 的缺点在于JavaScript 运行环境没有原生支持 AMD，需要先导入实现了 AMD 的库后才能正常使用。 TypeScript 的缺点在于语法相对于 JavaScript 更加啰嗦，并且无法直接运行在浏览器或 Node.js 环境下。Flow 也是 JavaScript 的一个超集，它的主要特点是为 JavaScript 提供静态类型检查，和 TypeScript 相似但更灵活，可以让你只在需要的地方加上类型检查。 构建工具构建就是做这件事情，把源代码转换成发布到线上的可执行 JavaScrip、CSS、HTML 代码，包括如下内容。 代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等。 文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。 代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。 模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。 自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。 代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。 自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。 webpack配置webpack官方提供的配置方法是通过module.exports返回一个json，但是这种场景不灵活，不能适配多种场景。最佳方式：1、两份配置文件webpack.config.production.js/webpack.config.development.js，然后不同场景下，使用不同的配置文件。2、通过module.exports返回函数，该函数能接受参数。 1234567891011121314151617181920212223module.exports = function(env) &#123; return &#123; context: config.context, entry: config.src, output: &#123; path: path.join(config.jsDest, project), filename: '[name].js', chunkFilename: '[name].[chunkhash:8].js', publicPath: '/assets/' + project + '/' &#125;, devtool: \"eval\", watch: false, profile: true, cache: true, module: &#123; loaders: getLoaders(env) &#125;, resolve: &#123; alias: getAlias(env) &#125;, plugins: getPlugins(env) &#125;;&#125; context：上下文。entry：入口文件，是所有依赖关系的入口，webpack从这个入口开始静态解析，分析模块之间的依赖关系。output：打包输出的配置。devtools：SourceMap选项，便于开发模式下调试。watch：监听模式，增量更新，开发必备！profile：优化。cache：webpack构建的过程中会生成很多临时的文件，打开cache可以让这些临时的文件缓存起来，从而更快的构建。module.loaders：loaders用来对文件做预处理。这样webpack就可以打包任何静态文件。resolve.alias：模块别名，这样可以更方便的引用模块。plugins：webpack的一些内置功能均是以插件的形式提供。 webpack 使用1、命令行调用webpack可以在终端中使用： {extry file}填写入口文件的路径 {destination for bundled file}处填写打包文件的存放路径 填写路径的时候不用添加{}webpack {entry file} {destination for bundled file} （全局模式）node_modules/.bin/webpack app/main.js public/bundle.js （非全局安装的情况） 2、入口与输出模板123456789&#123; entry: [String | Array | Object], // 入口模块 output: &#123; path: String, // 输出路径 filename: String // 输出名称或名称 pattern publicPath: String // 指定静态资源的位置 ... // 其他配置 &#125;&#125; 多个入口文件：eg: entry: [&#39;./src/index.js&#39;, &#39;./vendor/bootstrap.min.js&#39;] 一个入口，多个文件最终 bootstrap 会被追加到打包好的 index.js 中，数组中的最后一个会被 export。 多个打包目标 12345678910&#123; entry: &#123; index: './src/index.js', a: './src/a.js' &#125;, output: &#123; path: './dist/', filename: '[name].js' &#125;&#125; 3、生成Source Maps（使调试更容易）—— devtoolwebpack就可以在打包时为我们生成的source maps，提供了一种对应编译文件和源文件的方法，使得编译后的代码可读性更高，也更容易调试。在webpack的配置文件中配置source maps，需要配置devtool，有四种不同的配置选项： source-map：在一个单独的文件中产生一个完整且功能完全的文件，但它会减慢打包速度 cheap-module-source-map：在一个单独的文件中生成一个不带列映射的map，不带列映射提高了打包速度，但不能对应到具体的列（符号），会对调试造成不便； eval-source-map：使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。其可以在不影响构建速度的前提下生成完整的sourcemap，但对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定不要启用这个选项； cheap-module-eval-source-map：在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点。（cheap-module-eval-source-map方法构建速度更快，但是不利于调试，推荐在大型项目考虑时间成本时使用。） 12345678module.exports = &#123; entry: __dirname + '/app/index.js', output: &#123; path: __dirname + '/public', filename: 'bundle-[hash:7].js' &#125;, devtool: 'eval-source-map'&#125; 4、使用webpack构建本地服务器（webpack-dev-server）—— devServer背景：浏览器监听代码的修改，并自动刷新显示修改后的结果Webpack提供一个可选的本地开发服务器，该本地服务器基于node.js构建先安装：npm install –save-dev webpack-dev-server再配置: devserver contentBase：默认webpack-dev-server会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录 port：设置默认监听端口，默认“8080”； inline：设置为true，当源文件改变时会自动刷新页面； historyApiFallback：若设置true，所有的跳转将指向index.html，在单页应用时有用，它依赖于HTML5 history API 12345678910111213module.exports = &#123; entry: __dirname + '/app/index.js', output: &#123; path: __dirname + '/public', filename: 'bundle-[hash:7].js' &#125;, devtool: 'eval-source-map', devServer: &#123; contentBase: './public', // 本地服务器所加载的页面所在的目录 historyApiFallback: true, // 不跳转 inline: true // 实时刷新 &#125;&#125; 5、loader使用不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理在 webpack 中，通过 loader 可以实现 JSX 、Es6、CoffeeScript 等的转换. 分析转换scss为css 把下一代的JS文件（ES6，ES7)转换为现代浏览器兼容的JS文件 把React的中用到的JSX文件转换为JS文件 ……Loader需要单独安装，并在config.js 中的 modules关键字中进行配置Loader 的配置说明： test：一个用以匹配loaders所处理文件的拓展名的正则表达式（必须） loader：loader的名称（必须） include/exclude:手动添加必须处理的文件/文件夹或屏蔽不需要处理的文件/文件夹（可选） query：为loaders提供额外的设置选项（可选） loader 除了做文件转换以外，还可以创建额外的文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950module: &#123; rules: [ // template loaders &#123; test: /\\.(tpl|html)$/, use: 'html-loader', &#125;, &#123; test: /\\.art$/, use: 'art-template-loader', &#125;, &#123; test: /\\.(hbs|handlebars)$/, use: 'handlebars-loader', &#125;, // picture loader &#123; test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, use: &#123; loader: 'url-loader', query: &#123; limit: 8192, name: 'img/[name].[ext]', &#125;, &#125;, &#125;, // font loader &#123; test: /(\\.(woff2?|eot|ttf|otf)|font.*\\.svg)(\\?.*)?$/, use: &#123; loader: 'url-loader', query: &#123; limit: 8192, name: 'fonts/[name].[ext]', &#125;, &#125;, &#125;, // media file loader &#123; test: /\\.(mp4|3gp|avi|mkv|wmv|mpg|vob|flv|swf|mov|rmvb|mp3|wma|wav|aac|ogg|flac|ape|m4a)$/, use: &#123; loader: 'url-loader', query: &#123; limit: 8192, name: 'media/[name].[ext]', &#125;, &#125;, &#125;, ],&#125; 6、Babel作用：是一个编译 JS 的平台： 使用下一代的 JS 代码（ES6，ES7…），即使这些标准目前并未被当前的浏览器完全的支持； 使用基于 JS 进行了拓展的语言，比如React的JSX；安装：npm install --save-dev babel-core babel-loader babel-preset-es2015 babel-preset-reactBabel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，webpack可以把其不同的包整合在一起使用，对于每一个需要的功能或拓展，你都需要安装单独的包（用得最多的是解析ES6的babel-preset-es2015包和解析JSX的babel-preset-react包）。 7、Babel的配置Babel 可以完全在webpack.config.js中进行配置，但复杂度增加时会单独有.babelrc的配置文件webpack会自动调用.babelrc里的babel配置选项 123456789101112131415161718192021222324252627module.exports = &#123; entry: __dirname + '/app/index.js', output: &#123; path: __dirname + '/public', filename: 'bundle-[hash:7].js' &#125;, devtool: 'eval-source-map', devServer: &#123; contentBase: './public', // 本地服务器所加载的页面所在的目录 historyApiFallback: true, // 不跳转 inline: true // 实时刷新 &#125;, module: &#123; rules: [&#123; test: /(\\.jsx|\\.js)/, use: &#123; loader: 'babel-loader', &#125;, exclude: /node-module/ &#125;] &#125;&#125;// .babelrc&#123; persets: ['es2015', 'react', 'stage-0']&#125; 8、CSS moduleCSS modules 的技术：把JS的模块化思想带入CSS中来，通过CSS模块，所有的类名，动画名默认都只作用于当前模块。Webpack从一开始就对CSS模块化提供了支持，在CSS loader中进行配置后。首先把”modules“传递到所需要的地方然后就可以直接把CSS的类名传递到组件的代码中好处：这样做只对当前组件有效，不必担心在不同的模块中使用相同的类名造成冲突。 9、CSS预处理器 / PostCSS / autoprefixerSass 和 Less 之类的预处理器是对原生CSS的拓展，它们允许使用类似于variables, nesting, mixins, inheritance等不存在于CSS中的特性来写CSS。在webpack里使用loader进行配置：less-loader、sass-loader、style-loader PostCSS 是一个允许使用 JS 插件转换样式的工具。 这些插件可以检查（lint）你的 CSS，支持 CSS Variables 和 Mixins，CSS 自动加前缀、使用下一代 CSS 语法等. 123456789101112131415161718192021222324252627282930313233module.exports = &#123; entry: __dirname + '/app/index.js', output: &#123; path: __dirname + '/public', filename: 'bundle-[hash:7].js' &#125;, devtool: 'eval-source-map', devServer: &#123; contentBase: './public', // 本地服务器所加载的页面所在的目录 historyApiFallback: true, // 不跳转 inline: true // 实时刷新 &#125;, module: &#123; rules: [&#123; test: /(\\.jsx|\\.js)/, use: &#123; loader: 'babel-loader', &#125;, exclude: /node-module/ &#125;, &#123; test: /\\.css$/, use: ['style-loader', 'css-loader', 'postcss-loader'] &#125;] &#125;&#125;// postcss.config.jsmodule.exports = &#123; plugins: [ // 需要使用的插件列表 require('postcss-cssnext') // 使用下一代 CSS 语法编写代码 ]&#125; 10、插件（Plugins）— banner-plugins / HtmlWebpackPlugin / Hot Module Replacement插件（Plugins）是用来拓展Webpack功能，会在整个构建过程中生效，执行相关的任务。loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。 1.banner-plugins: 添加版权声明2.HtmlWebpackPlugin（动态生成入口 html）依据一个简单的index.html模板，生成一个自动引用你打包后的JS文件的新index.html 3.Hot Module Replacement: 允许修改组件代码后，自动刷新实时预览修改后的效果。Hot Module Replacement（HMR）允许修改组件代码后，自动刷新实时预览修改后的效果。配置：1、在webpack配置文件中添加HMR插件；2、在Webpack Dev Server中添加“hot”参数；不过配置完后，JS模块其实还是不能自动热加载的，还需要在JS模块中执行一个Webpack提供的API才能实现热加载。虽然这个API不难使用，但是如果是React模块，使用Babel可以更方便的实现功能热加载。思路： HMR是一个webpack插件，它能在浏览器中实时观察模块修改后的效果，但如果想让它工作，需要对模块进行额外的配置； Babel 有一个叫做react-transform-hrm 的插件，可以在不对React模块进行额外的配置的前提下让HMR正常工作； 11、优化插件 OccurenceOrderPlugin:为组件分配ID，通过这个插件webpack可以分析和优先考虑使用最多的模块，并为它们分配最小的ID（内置插件） UglifyJsPlugin：压缩JS代码；（内置插件） ExtractTextPlugin：分离CSS和JS文件安装ExtractTextPlugin：npm install --save-dev extract-text-webpack-plugin 1234567891011121314151617181920212223242526272829303132333435363738394041424344module.exports = &#123; entry: __dirname + '/app/index.js', output: &#123; path: __dirname + '/public', filename: 'bundle-[hash:7].js' &#125;, devtool: 'eval-source-map', devServer: &#123;&#125;, module: &#123;&#125;, plugins: [ new webpack.BannerPlugins('版权所有，翻版必究'), new HtmlWebpackPlugin(&#123; template: __dirname + '/app/index.tmpl.html', &#125;), new webpack.HotModuleReplacementPlugin(), // 热加载插件 new webpack.optimize.OccurenceOrderPlugin, new webpack.optimize.UglifyJsPlugin, new ExtractTextPlugin('style.css') ]&#125;// .babelrc&#123; 'persets': ['react', 'es2015', 'stage-0'] 'env': &#123; 'devlopment': &#123; 'plugins': [['react-transform', &#123; transform: [&#123; transform:: 'react-transform-hmr', imports: ['react'], locals: ['module'] &#125;] &#125;]] &#125; &#125;&#125;// package.json 'script': &#123; \"test\"': \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"start\": \"webpack\", \"server\": \"webpack-dev-server --open\", \"build\": \"NODE_ENV=production webpack --config ./webpack.config.js --progress\"&#125; HtmlWebpackPlugin 参数说明：123456789101112131415161718new HtmlWebpackPlugin(&#123; template: __dirname + '/app/index.tmpl.html', title: 'Test', filename: 'index.html', inject: 'body', favicon: './images/favico.ico', minify: true, hash: true, cache: false, showErrors: false, xhtml: false, chunks: &#123; head: &#123; entry: 'assets/head_bundle.js', css: ['main.css'] &#125; &#125;&#125;), title: 设置title的名字 filename: 设置这个html的文件名 template:要使用的模块的路径 inject: 把模板注入到哪个标签后， ‘body’, favicon: 给html添加一个favicon， ‘./images/favico.ico’, minify:是否压缩 {…} | false （最新api变动，原来是ture|false) hash:是否hash化 true，false , cache:是否缓存, showErrors:是否显示错误, xhtml:是否自动毕业标签 默认false 12、缓存缓存无处不在，使用缓存的最好方法是保证你的文件名和文件内容是匹配的（内容改变，名称相应改变）解决办法：带hash值 配置说明：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177const path = require('path');module.exports = &#123; // entry 表示 入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。 // 类型可以是 string | object | array entry: './app/entry', // 只有1个入口，入口只有1个文件 entry: ['./app/entry1', './app/entry2'], // 只有1个入口，入口有2个文件 entry: &#123; // 有2个入口 a: './app/entry-a', b: ['./app/entry-b1', './app/entry-b2'] &#125;, // 如何输出结果：在 Webpack 经过一系列处理后，如何输出最终想要的代码。 output: &#123; // 输出文件存放的目录，必须是 string 类型的绝对路径。 path: path.resolve(__dirname, 'dist'), // 输出文件的名称 filename: 'bundle.js', // 完整的名称 filename: '[name].js', // 当配置了多个 entry 时，通过名称模版为不同的 entry 生成不同的文件名称 filename: '[chunkhash].js', // 根据文件内容 hash 值生成文件名称，用于浏览器长时间缓存文件 // 发布到线上的所有资源的 URL 前缀，string 类型 publicPath: '/assets/', // 放到指定目录下 publicPath: '', // 放到根目录下 publicPath: 'https://cdn.example.com/', // 放到 CDN 上去 // 导出库的名称，string 类型 // 不填它时，默认输出格式是匿名的立即执行函数 library: 'MyLibrary', // 导出库的类型，枚举类型，默认是 var // 可以是 umd | umd2 | commonjs2 | commonjs | amd | this | var | assign | window | global | jsonp ， libraryTarget: 'umd', // 是否包含有用的文件路径信息到生成的代码里去，boolean 类型 pathinfo: true, // 附加 Chunk 的文件名称 chunkFilename: '[id].js', chunkFilename: '[chunkhash].js', // JSONP 异步加载资源时的回调函数名称，需要和服务端搭配使用 jsonpFunction: 'myWebpackJsonp', // 生成的 Source Map 文件名称 sourceMapFilename: '[file].map', // 浏览器开发者工具里显示的源码模块名称 devtoolModuleFilenameTemplate: 'webpack:///[resource-path]', // 异步加载跨域的资源时使用的方式 crossOriginLoading: 'use-credentials', crossOriginLoading: 'anonymous', crossOriginLoading: false, &#125;, // 配置模块相关 module: &#123; rules: [ // 配置 Loader &#123; test: /\\.jsx?$/, // 正则匹配命中要使用 Loader 的文件 include: [ // 只会命中这里面的文件 path.resolve(__dirname, 'app') ], exclude: [ // 忽略这里面的文件 path.resolve(__dirname, 'app/demo-files') ], use: [ // 使用那些 Loader，有先后次序，从后往前执行 'style-loader', // 直接使用 Loader 的名称 &#123; loader: 'css-loader', options: &#123; // 给 html-loader 传一些参数 &#125; &#125; ] &#125;, ], noParse: [ // 不用解析和处理的模块 /special-library\\.js$/ // 用正则匹配 ], &#125;, // 配置插件 plugins: [], // 配置寻找模块的规则 resolve: &#123; modules: [ // 寻找模块的根目录，array 类型，默认以 node_modules 为根目录 'node_modules', path.resolve(__dirname, 'app') ], extensions: ['.js', '.json', '.jsx', '.css'], // 模块的后缀名 alias: &#123; // 模块别名配置，用于映射模块 // 把 'module' 映射 'new-module'，同样的 'module/path/file' 也会被映射成 'new-module/path/file' 'module': 'new-module', // 使用结尾符号 $ 后，把 'only-module' 映射成 'new-module'， // 但是不像上面的，'module/path/file' 不会被映射成 'new-module/path/file' 'only-module$': 'new-module', &#125;, alias: [ // alias 还支持使用数组来更详细的配置 &#123; name: 'module', // 老的模块 alias: 'new-module', // 新的模块 // 是否是只映射模块，如果是 true 只有 'module' 会被映射，如果是 false 'module/inner/path' 也会被映射 onlyModule: true, &#125; ], symlinks: true, // 是否跟随文件软链接去搜寻模块的路径 descriptionFiles: ['package.json'], // 模块的描述文件 mainFields: ['main'], // 模块的描述文件里的描述入口的文件的字段名称 enforceExtension: false, // 是否强制导入语句必须要写明文件后缀 &#125;, // 输出文件性能检查配置 performance: &#123; hints: 'warning', // 有性能问题时输出警告 hints: 'error', // 有性能问题时输出错误 hints: false, // 关闭性能检查 maxAssetSize: 200000, // 最大文件大小 (单位 bytes) maxEntrypointSize: 400000, // 最大入口文件大小 (单位 bytes) assetFilter: function(assetFilename) &#123; // 过滤要检查的文件 return assetFilename.endsWith('.css') || assetFilename.endsWith('.js'); &#125; &#125;, devtool: 'source-map', // 配置 source-map 类型 context: __dirname, // Webpack 使用的根目录，string 类型必须是绝对路径 // 配置输出代码的运行环境 target: 'web', // 浏览器，默认 target: 'webworker', // WebWorker target: 'node', // Node.js，使用 `require` 语句加载 Chunk 代码 target: 'async-node', // Node.js，异步加载 Chunk 代码 target: 'node-webkit', // nw.js target: 'electron-main', // electron, 主线程 target: 'electron-renderer', // electron, 渲染线程 externals: &#123; // 使用来自 JavaScript 运行环境提供的全局变量 jquery: 'jQuery' &#125;, stats: &#123; // 控制台输出日志控制 assets: true, colors: true, errors: true, errorDetails: true, hash: true, &#125;, devServer: &#123; // DevServer 相关的配置 proxy: &#123; // 代理到后端服务接口 '/api': 'http://localhost:3000' &#125;, contentBase: path.join(__dirname, 'public'), // 配置 DevServer HTTP 服务器的文件根目录 compress: true, // 是否开启 gzip 压缩 historyApiFallback: true, // 是否开发 HTML5 History API 网页 hot: true, // 是否开启模块热替换功能 https: false, // 是否开启 HTTPS 模式 &#125;, profile: true, // 是否捕捉 Webpack 构建的性能信息，用于分析什么原因导致构建性能不佳 cache: false, // 是否启用缓存提升构建速度 watch: true, // 是否开始 watchOptions: &#123; // 监听模式选项 // 不监听的文件或文件夹，支持正则匹配。默认为空 ignored: /node_modules/, // 监听到变化发生后会等300ms再去执行动作，防止文件更新太快导致重新编译频率太高 // 默认为300ms aggregateTimeout: 300, // 判断文件是否发生变化是不停的去询问系统指定文件有没有变化，默认每秒问 1000 次 poll: 1000 &#125;,&#125;","categories":[{"name":"构建","slug":"构建","permalink":"http://yoursite.com/categories/构建/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"Object 创建/修改/获取属性的方法","slug":"[JS] 创建、修改、获取属性的方法","date":"2018-09-26T10:08:12.000Z","updated":"2018-10-08T02:21:39.000Z","comments":true,"path":"2018/09/26/[JS] 创建、修改、获取属性的方法/","link":"","permalink":"http://yoursite.com/2018/09/26/[JS] 创建、修改、获取属性的方法/","excerpt":"","text":"Object.defineProperty(obj, prop, descriptor)会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。若不指定configurable, writable, enumerable ，则这些属性默认值为false；若不指定value, get, set，则这些属性默认值为undefined。 obj: 需要被操作的目标对象 prop: 目标对象需要定义或修改的属性的名称 descriptor: 将被定义或修改的属性的描述符 12345678var obj = new Object();Object.defineProperty(obj, 'name', &#123; configurable: false, writable: true, enumerable: true, value: '张三'&#125;)console.log(obj.name) //张三 Object.defineProperties(obj, props)直接在一个对象上定义一个或多个新的属性或修改现有属性，并返回该对象。 props: 该对象的一个或多个键值对定义了将要为对象添加或修改的属性的具体配置。 1234567891011121314var obj = new Object();Object.defineProperties(obj, &#123; name: &#123; value: '张三', configurable: false, writable: true, enumerable: true &#125;, age: &#123; value: 18, configurable: true &#125;&#125;);console.log(obj.name, obj.age) // 张三, 18 在不支持 Object.defineProperties() 方法的浏览器中不能修改[[configurable]]和[[enumerable]]。 Object.getOwnPropertyDescriptor(obj, prop)返回指定对象上一个自有属性对应的属性描述符。 prop: 目标对象内属性名称。 123456789101112var person = &#123; name: '张三', age: 18&#125;;var desc = Object.getOwnPropertyDescriptor(person, 'name'); console.log(desc);// &#123;// configurable: true,// enumerable: true,// writable: true,// value: \"张三\"// &#125; Object.getOwnPropertyDescriptors(obj, prop)所指定对象的所有自身属性的描述符，如果没有任何自身属性，则返回空对象。返回值是一个对象，若是访问器属性，该对象有Configurable、Enumberable、Get和set；若是数据属性，该对象有Configurable、Enumberable、Writable和Value； 123456789101112131415161718192021222324252627282930var book = &#123;&#125;;Object.defineProperties(book, &#123; _year: &#123; value: 2004 &#125;, edition: &#123; value: 1 &#125;, year: &#123; get: function() &#123; return this._year; &#125;, set: function(newValue) &#123; if(newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125; &#125;&#125;);var descriptor = Object.getOwnPropertyDescriptors(book, '_year');descriptor.value; // 2004descriptor.configurable; // falsetypeof descriptor.get; // undefinedvar desc = Object.getOwnPropertyDescriptors(book, 'year');descriptor.value; // undefineddescriptor.enumberable; // falsetypeof descriptor.get; // function 补充说明在调用 Object.defineProperty() 方法时，如果不指定，configrubale、enumerable和writable 默认都为false。 configrubale设置configrubale属性为false，则不可使用delete操作符(在严格模式下抛出错误), 修改所有内部属性值会抛出错误。 enumerablewritableget 和 set","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JS高级程序设计","slug":"[JS] JS高级程序设计","date":"2018-09-26T06:48:21.000Z","updated":"2018-10-08T02:21:43.000Z","comments":true,"path":"2018/09/26/[JS] JS高级程序设计/","link":"","permalink":"http://yoursite.com/2018/09/26/[JS] JS高级程序设计/","excerpt":"","text":"目录：chap5、引用类型chap6、面向对象 chap5、引用类型引用类型是一种数据结构，用于将数据和功能组织在一起。 Object类型可以使用.点和[]进行访问对象属性，没有任何去边，但方括号的主要优点：可以通过变量来访问属性。若属性名中包含关键字或保留字或导致语法错误的字符，可以使用方括号表示法。除非必须使用变量来访问属性，否则建议使用点表示法 Array类型Array构造函数时可以省略new操作符，const color = new Array(3); const color = Array(3);数组的length并不是只读的，可以被设置。 123456const color = ['red', 'green', 'blue'];color.length = 2;console.log(color[2]); // undefined，会被删除color.length = 4;console.log(color[3]); // undefined，会被添加 Array类型方法 转换方法：所有对象都具有toLocaleString()、toString()和valueod()方法。valueOf()函数用于返回指定对象的原始值；toString()函数用于返回指定对象的字符串； 对象 valueOf() 返回值 toString() 返回值 Number 数字值(number) 数字值(string) String 字符串值 字符串值 Boolean 布尔值 字符串值 Object 对象本身 字符串值 Function 函数本身 字符串值 Date 以毫秒数存储的时间值(number) 标准时间输出(string) 若数组中的某一项的值是null或undefined，在join()、toLocaleString()、toString()、valueof()方法返回的结果中以空字符串表示。 队列方法(数组：先进后出)：shift(): 取出（删除）数组的第一项，最开始的头部unshift()：添加一项至数组的第一项头部push()：添加一项至数组的第一项尾部pop()：取出（删除）数组的最后一项目，尾部 操作方法：concat()：无参数时，复制当前数组并返回；参数为一个或多个数组，将数组汇总的每一项都添加到结果数组中。slice()：返回项的起始和结束位置。该函数不影响原是数组。若slice的参数为负数，则用长度去减，若结束位置小于起始位置，则返回空数组。eg：slice(-2, -1)的长度为5的数组调用后为 slice(3,4);splice()：向数组的中部插入项，实现删除、插入和替换。 删除：splice(起始位置，项数); 插入：splice(起始位置，0，要插入的项，要插入的项，要插入的项，…); 替换：splice(起始位置，项数，要插入的项，要插入的项，要插入的项，…);删除后再添加 位置方法：indexOf(查找项，查找起点位置的索引)从数组的开头开始（位置0）向后查找。lastIndexOf(查找项，查找起点位置的索引)从数组的末尾开始向前查找。 迭代方法：every()：数组中的每一项都必须满足条件，才返回truefilter()：过滤forEach()：遍历循环map()：遍历循环some()：数组中的只要有满足条件的，就返回true1234567891011121314151617181920const numbers = [1,2,3,4,5,4,3,2,1];const everyResult = numbers.every((item, index, array) =&gt; &#123; return (item &gt; 2);&#125;);// everyResult 结果为： falseconst someResult = numbers.every((item, index, array) =&gt; &#123; return (item &gt; 2);&#125;);// someResult 结果为： trueconst filterResult = numbers.every((item, index, array) =&gt; &#123; return (item &gt; 2);&#125;);// filterResult 结果为： [3,4,5,4,3]const mapResult = numbers.every((item, index, array) =&gt; &#123; return (item &gt; 2);&#125;);// mapResult 结果为： [2,4,6,8,10,8,6,4,2] 缩小方法：reduce(函数，缩小基础的初始值)和reduceRight(函数，缩小基础的初始值)都会迭代数组的所有项，reduceRight是从最后一项开始。123const val = [1,2,3,4,5];// 前一个值、当前值、项的索引和数组对象val.reduce((prev, cur, index, array) =&gt; &#123;&#125;); Function类型arguments（保存函数参数）为类数组对象，包含着传入函数中的所有参数。callee 为一个指针，指向拥有这个arguments对象的函数。this 函数据以执行的环境对象。 12345// 阶乘函数的递归算法function factorial(num) &#123; return num &lt;= 1 ? 1 : num * arguments.callee(num-1);&#125;// 利用callee 松散耦合 apply和 call 都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。能够扩充函数赖以运行的作用域apply(运行函数的作用域，参数数组Array / arguments))call(运行函数的作用域，参数1，参数2，....)123456789101112131415161718192021222324252627282930function sum(num1, num2) &#123; return num1 + num2;&#125;function applySum(num1, num2) &#123; return sum.apply(this, arguments);&#125;// 因为在非严格的全局调用，this指向window，严格模式下，this为undefined。// 除非明确把函数添加到某个对象或者调用者console.log(applySum(10,10)); // 20function callSum(num1, num2) &#123; return sum.call(this, ...arguments);&#125;console.log(callSum(10,10)); // 20window.color = 'red';const o = &#123; color: 'blue' &#125;;function sayColor() &#123; console.log(this.color);&#125;sayColor(); // redsayColor.call(this); // redsayColor.call(window); // redsayColor.call(o); // blue 此时this指向对象o// this值会被绑定到传给bind() 函数的值const objSaycolor = sayColor.bind(o);objSaycolor(); // blue 基本包装类型toFixed() 返回字符串类型；toExponential() 指数表示法表示的数值的字符串形式；charAt(0开始的字符位置)：该位置对应的字符；charCodeAt(0开始的字符位置)：该位置对应的字符编码；concat()：将一或多个字符串拼接起来，返回新的；slice()、substr()和substring()：裁剪字符串； 12345678// 负数时，存在差异const stringVal = 'hello world';console.log(stringVal.slice(-3)); // 'rld'console.log(stringVal.substring(-3)); // 'hello world'console.log(stringVal.substr(-3)); // 'rld'console.log(stringVal.slice(3, -4)); // 'lo w'console.log(stringVal.substring(3, -4)); // 'hel'console.log(stringVal.substr(3, -4)); // '' trim() 创建一个字符串副本，删除前置及后缀的所有空格。match()：模式匹配方法，类似于RegExp和 exec()12345678const text = 'cat, bat, sat, fat';const pattern = /.at/;const result = text.match(pattern); // [\"cat\", index: 0, input: \"cat, bat, sat, fat\", groups: undefined]const result = pattern.exec(text) // [\"cat\", index: 0, input: \"cat, bat, sat, fat\", groups: undefined]const result = text.search(/at/); // 1const result = text.replace('at', 'ond'); // \"cond, bat, sat, fat\"const result = text.replace(/at/g, 'ond'); // \"cond, bond, sond, fond\"const result = text.replace(/(.at)/g, 'word($1)'); // \"word(cat), word(bat), word(sat), word(fat)\" split() 基于指定的分隔符将一个字符串分割成多个子字符串；localeCompare()比较两个字符串，返回与字符串在字母表中的排序有关，靠前，返回1，否则-1，相同为0；const stringVal = ‘yellow’;stringVal.localeCompare(‘brick’); // 1fromCharCode()：接收一或多个字符编码，并转换成字符串；String.fromCharCode(104, 101, 108, 108, 111); // hello chap6、面向对象 对象的属性类型ECMAScript中有两种属性：数据属性和访问器属性。数据属性包含一个数据值的位置，可以读取和写入值。数据属性有4个描述其行为的特性：[[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。默认值为true；[[Enumberable]]：表示能否通过 for-in 循环返回属性。默认值为true；[[Writable]]：表示能否修改属性的值。[[Value]]：包含这个属性的数据值，读取属性值时，从这个位置读，写入属性值时，把新值保存在这个位置。 123const person = &#123; name: 'ruby'&#125; 要修改属性默认的特性，需要使用 Object.defineProperty()（见“Object 创建/修改/获取属性的方法”）。 访问器属性不包含数据值，包含 getter 和 setter 函数。访问器属性有4个特性：[[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。默认值为true；[[Enumberable]]：表示能否通过 for-in 循环返回属性。默认值为true；[[Get]]：在读取属性时调用的函数，默认为undefined。[[Set]]：在写入属性时调用的函数，默认为undefined。 访问器属性不能直接定义，必须使用Object.defineProperties()来定义。","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JS基础总结","slug":"[JS] JS基础总结","date":"2018-09-26T06:48:21.000Z","updated":"2018-10-12T09:20:03.000Z","comments":true,"path":"2018/09/26/[JS] JS基础总结/","link":"","permalink":"http://yoursite.com/2018/09/26/[JS] JS基础总结/","excerpt":"","text":"目录：一、JS 中的数据类型二、JS 中类型检测三、$.extend()和$.fn.extend()四、jquery的事件绑定on、bind、dele五、defer和async六、module.exports和export的区别七、Promise八、JS中正则表达式的使用九、数组十、前端的各种排序十一、列举HTML5新特性十二、列举Css3新特性 一、JS 中的数据类型JavaScript 有 5 种简单数据类型：Undefined、Null、Boolean、Number、String 和 1 种复杂数据类型 Object 。基本类型（值类型）：Undefined、Null、Boolean、Number、String复杂类型（引用类型）：Object、Array、Date、RegExp、Function、基本包装类型（Boolean | Number | String）、单体内置对象（Global | Math）。类型检测：typeof、instanceof、Object.prototype.toString.call()； 值类型与引用类型的差别: 基本类型在内存中占据固定大小的空间，因此被保存在栈内存中; 从一个变量向另一个变量复制基本类型的值，复制的是值的副本; 引用类型的值是对象，保存在堆内存; 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针; 从一个变量向另一个变量复制引用类型的值的时候，复制是引用指针，因此两个变量最终都指向同一个对象。 二、JS中类型检测在JavaScript里使用typeof判断数据类型，只能区分基本类型，即：number、string、undefined、boolean、object。对于null、array、function、object来说，使用typeof都会统一返回object字符串。 要想区分对象、数组、函数、单纯使用typeof是不行的。在JS中，可以通过Object.prototype.toString方法，判断某个对象之属于哪种内置类型。分为null、string、boolean、number、undefined、RegExp、array、function、object、date、math。 判断原生JSON对象: window.JSON &amp;&amp; Object.prototype.toString.call(JSON) 输出结果为”[object JSON]”说明JSON是原生的，否则不是。注意：Object.prototpye.toString()本身也可能会被修改 对于自定义的函数，可以使用 instanceof判断，判断一个实例是否属于某种类型。console.log(person instanceof Person); 三、$.extend和$.fn.extend extend(dest,src1,src2,src3...): 将src1,src2,src3…合并到dest中,返回值为合并后的dest,修改了dest的结构。 $.extend({},src1,src2,src3...) // 也就是将”{}”作为dest参数，不修改dest的结构。 12// 后面的参数如果和前面的参数存在相同的名称，那么后面的会覆盖前面的参数值。$.extend(&#123;&#125;,&#123;name:\"Tom\",age:21&#125;,&#123;name:\"Jerry\",sex:\"Boy\"&#125;); // &#123;name:\"Jerry\",age:21,sex:\"Boy\"&#125; 省略 dest 参数$.extend(src): 将src合并到jquery的全局对象中去。 123456// 将hello方法合并到jquery的全局对象中$.extend(&#123; hello: function() &#123; alert('hello'); &#125;&#125;); $.fn.extend(src): 将src合并到jquery的实例对象中去 ($.fn=jquery.prototype) 1234567// 这是在jquery全局对象中扩展一个net命名空间。$.extend(&#123;net:&#123;&#125;&#125;); // 这是将hello方法扩展到之前扩展的Jquery的net命名空间中去$.extend($.net, &#123; hello:function()&#123;alert('hello');&#125;&#125;); extend方法还有一个重载原型：extend(boolean,dest,src1,src2,src3...): boolean代表是否进行深度拷贝。 12345678var result=$.extend( true, &#123;&#125;, &#123; name:\"John\", location: &#123;city: \"Boston\",county:\"USA\"&#125; &#125;, &#123; last:\"Resig\", location: &#123;state: \"MA\",county:\"China\"&#125; &#125; );// result = &#123;name:\"John\",last:\"Resig\",location:&#123;city:\"Boston\",state:\"MA\",county:\"China\"&#125;&#125;var result=$.extend( false, &#123;&#125;, &#123; name:\"John\", location:&#123;city: \"Boston\",county:\"USA\"&#125; &#125;, &#123; last:\"Resig\", location: &#123;state: \"MA\",county:\"China\"&#125; &#125;);// result = &#123;name:\"John\",last:\"Resig\",location:&#123;state:\"MA\",county:\"China\"&#125;&#125; 四、jquery的事件绑定on、bind、dele sdas 五、defer和asyncdefer可以让脚本在文档完全呈现之后再执行，延迟脚本总是按照指定它们的顺序执行。async可表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚本按照它们在页面中出现的顺序执行。 六、module.exports和export的区别模块化：公共代码抽离成为一个单独的js文件，作为一个模块，模块只有通过module.exports 和 exports 才能对外暴露接口。区别： exports 是指向的module.exports 的引用； module.exports 初始值为一个空对象{}，所以exports 初始值也是{}； require() 返回的是module.exports 而不是exports。 七、PromisePromise代表了某个未来才会知道结果的事件（通常是一个异步操作），可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。Promise对象有三种状态：pending状态（ 等待中），fulfilled状态（操作完成的状态），rejected状态（操作失败的状态），状态不受外界影响，一旦状态改变，就不会再变。 基本的API有： Promise.resolve() Promise.reject() Promise.prototype.then() Promise.prototype.catch() Promise.all() Promise.race() 常见使用场景：ajax请求，定时器，数据验证，动画结束回调，多重回调解耦等。 八、JS中正则表达式的使用 String.prototype.search方法。eg：”abchello”.search(/hello/); // 3 String.prototype.replace方法。eg：”abchello”.replace(/hello/,”hi”); // “abchi” String.prototype.split方法。 eg: “abchelloasdasdhelloasd”.split(/hello/); //[“abc”, “asdasd”, “asd”] String.prototype.match方法。 eg:用来捕获字符串中的子字符串到一个数组中。默认情况下只捕获一个结果到数组中。eg： “abchelloasdasdhelloasd”.match(/hello/); //[“hello”] “abchelloasdasdhelloasd”.match(/hello/g); //[“hello”,”hello”] RegExp.prototype.exec方法。1、exec方法一次只能捕获一份子字符串到数组中，无论正则表达式是否有全局属性eg: /hello/g.exec(&quot;abchelloasdasdhelloasd&quot;); // [“hello”]2、正则表达式对象有一个lastIndex属性，用来表示下一次从哪个位置开始捕获，每一次执行exec方法后，lastIndex就会往后推，直到找不到匹配的字符返回null，然后又从头开始捕获。 这个属性可以用来遍历捕获字符串中的子串。 12345678var reg=/hello/g;reg.lastIndex; //0reg.exec(\"abchelloasdasdhelloasd\"); // [\"hello\"]reg.lastIndex; //8reg.exec(\"abchelloasdasdhelloasd\"); // [\"hello\"]reg.lastIndex; //19reg.exec(\"abchelloasdasdhelloasd\"); // nullreg.lastIndex; //0 RegExp.prototype.test方法: 用来测试字符串中是否含有子字符串eg: /hello/.test(“abchello”); // true 九、数组 Array.prototype.flat(depth)（扁平化数组）会递归到指定深度将所有子数组连接，并返回一个新数组。depth 指定嵌套数组中的结构深度，默认值为11234567891011var arr1 = [1, 2, [3, 4]];arr1.flat(); // [1, 2, 3, 4]var arr2 = [1, 2, [3, 4, [5, 6]]];arr2.flat(); // [1, 2, 3, 4, [5, 6]]var arr3 = [1, 2, [3, 4, [5, 6]]];arr3.flat(2); // [1, 2, 3, 4, 5, 6]var arr4 = [1, 2, , 4, 5];arr4.flat(); // [1, 2, 4, 5] 会移除数组中的空项 十、前端的各种排序 快速排序思想： 1、找基准（一般是以中间项为基准）；2、遍历数组，小于基准的放在left，大于基准的放在right；3、递归 12345678910111213141516171819202122232425var times = 0;function quickSort(arr) &#123; //如果数组&lt;=1,则直接返回 if(arr.length &lt;= 1)&#123; return arr; &#125; var pivotIndex = Math.floor(arr.length/2); //找基准，并把基准从原数组删除 var pivot = arr.splice(pivotIndex,1)[0]; //定义左右数组 var left = []; var right = []; //比基准小的放在left，比基准大的放在right for(var i=0; i&lt;arr.length; i++) &#123; if(arr[i] &lt;= pivot) &#123; left.push(arr[i]); &#125; else&#123; right.push(arr[i]); &#125; console.log(\"第\"+(++times)+\"次排序后：\"+arr); &#125; //递归 return quickSort(left).concat([pivot],quickSort(right));&#125;// 数组长度10，排序次数22次。 冒牌排序思想： 每一次对比相邻两个数据的大小，小的排在前面，如果前面的数据比后面的大就交换这两个数的位置 12345678910111213141516var times=0;function(arr)&#123; for(var i = 0;i &lt; arr.length-1; i++) &#123; for(var j = i + 1;j &lt; arr.length; j++) &#123; if(arr[i] &gt; arr[j]) &#123; //如果前面的数据比后面的大就交换 var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; console.log(\"第\"+(++times)+\"次排序后：\"+arr); &#125; &#125; return arr;&#125;// 数组长度10，排序次数45次。 选择排序思想：每次选择最小的数，将最小的数记录下来，然后排到最前面 十一、列举HTML5新特性 语意化标签(nav、aside、dialog、header、footer等) canvas 拖放相关api Audio、Video 获取地理位置 更好的input校验 web存储(localStorage、sessionStorage) webWorkers(类似于多线程并发) webSocket 十二、列举Css3新特性 选择器 边框(border-image、border-radius、box-shadow) 背景(background-clip、background-origin、background-size) 渐变(linear-gradients、radial-gradents) 字体(@font-face) 转换、形变(transform) 过度(transition) 动画(animation) 弹性盒模型(flex-box) 媒体查询(@media) 十三、页面渲染机制1.CSS加载会阻塞DOM树吗？1234567891011121314151617181920&lt;head&gt; &lt;title&gt;css阻塞&lt;/title&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;style&gt; h1 &#123; color: red !important &#125; &lt;/style&gt; &lt;script&gt; function h () &#123; console.log(document.querySelectorAll('h1')) &#125; setTimeout(h, 0) &lt;/script&gt; &lt;link href=\"https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css\" rel=\"stylesheet\"&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;这是红色的&lt;/h1&gt;&lt;/body&gt; 由上图可以看出，控制台已打出console.log，说明此时的h1已经被解析，但是并没有显示。 解释：是浏览器的一种优化机制。因为加载css时，可能会修改下面DOM节点的样式，如果css加载不阻塞DOM树渲染的话，那么当css加载完之后，DOM树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。所以就先把DOM树的结构先解析完，把可以做的工作做完，然后等css加载完之后，在根据最终的样式来渲染DOM树。 css加载不会阻塞DOM树解析，但是会阻塞DOM树渲染 2.css加载会阻塞js运行吗？123456789101112131415161718&lt;head&gt; &lt;title&gt;css阻塞&lt;/title&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;script&gt; console.log('before css') var startDate = new Date() &lt;/script&gt; &lt;link href=\"https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css\" rel=\"stylesheet\"&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;这是红色的&lt;/h1&gt; &lt;script&gt; var endDate = new Date() console.log('after css') console.log('经过了' + (endDate -startDate) + 'ms') &lt;/script&gt;&lt;/body&gt; 可以看出，css之前的js代码已经解析完毕，但是css之后的js等到css加载完才执行。 css加载会阻塞后面的js语句的执行css会阻塞Dom渲染和js执行，而js会阻塞Dom解析 提高css加载速度的方法： 使用CDN(因为CDN会根据你的网络状况，替你挑选最近的一个具有缓存内容的节点为你提供资源，因此可以减少加载时间) 对css进行压缩(可以用很多打包工具，比如webpack,gulp等，也可以通过开启gzip压缩) 合理的使用缓存(设置cache-control,expires,以及E-tag都是不错的，不过要注意一个问题，就是文件更新后，你要避免缓存而带来的影响。其中一个解决防范是在文件名字后面加一个版本号) 减少http请求数，将多个css文件合并，或者是干脆直接写成内联样式(内联样式的一个缺点就是不能缓存) 3. 说明上述的原因不用浏览器使用的内核不同，目前主要有两个：webkit渲染过程Gecko渲染过程 从上面两个流程图我们可以看出来，浏览器渲染的流程如下： HTML解析文件，生成DOM Tree，解析CSS文件生成CSSOM Tree 将Dom Tree和CSSOM Tree结合，生成Render Tree(渲染树) 根据Render Tree渲染绘制，将像素渲染到屏幕上。 因此： 1. DOM解析和CSS解析是两个并行的进程，所以这也解释了为什么CSS加载不会阻塞DOM的解析。2. 然而，由于Render Tree是依赖于DOM Tree和CSSOM Tree的，所以他必须等待到CSSOM Tree构建完成，也就是CSS资源加载完成(或者CSS资源加载失败)后，才能开始渲染。因此，CSS加载是会阻塞Dom的渲染的。3. 由于js可能会操作之前的Dom节点和css样式，因此浏览器会维持html中css和js的顺序。因此，样式表会在后面的js执行前先加载执行完毕。所以css会阻塞后面js的执行。 4.DOMContentLoaded对于浏览器来说，页面加载主要有两个事件，一个是 DOMContentLoaded ，另一个是 onLoad 。onLoad: 等待页面的所有资源都加载完成才会触发，css、js、图片视频DOMContentLoaded: 当页面的内容解析完成后，则触发该事件","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"CSS3 单位汇总","slug":"[CSS] CSS3 单位","date":"2018-09-12T08:31:38.000Z","updated":"2018-10-08T02:22:00.000Z","comments":true,"path":"2018/09/12/[CSS] CSS3 单位/","link":"","permalink":"http://yoursite.com/2018/09/12/[CSS] CSS3 单位/","excerpt":"","text":"px：绝对单位，页面按精确像素展示。 em：相对单位，基准点为父节点字体的大小。如果自身定义了font-size按自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值。 rem：相对单位，可理解为”root em”, 相对根节点html的字体大小来计算，CSS3新加属性，chrome/firefox/IE9+支持。(另外需注意chrome强制最小字体为12号，即使设置成 10px 最终都会显示成 12px，当把html的font-size设置成10px,子节点rem的计算还是以12px为基准)。 vw：viewpoint width，视窗宽度，1vw等于视窗宽度的1%。 vh：viewpoint height，视窗高度，1vh等于视窗高度的1%。 vmin：vw和vh中较小的那个。 vmax：vw和vh中较大的那个。vw, vh, vmin, vmax：IE9+局部支持，chrome/firefox/safari/opera支持，ios safari 8+支持，android browser4.4+支持，chrome for android39支持 ex：取当前作用效果的字体的x的高度，在无法确定x高度的情况下以0.5em计算(IE11及以下均不支持 firefox/chrome/safari/opera/ios safari/android browser4.4+等均需属性加么有前缀) ch:以节点所使用字体中的“0”字符为基准，找不到时为0.5em(ie10+,chrome31+,safair7.1+,opera26+,ios safari 7.1+,android browser4.4+支持)","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"}]},{"title":"Vue知识点总结","slug":"vue知识点总结","date":"2018-09-06T02:30:23.000Z","updated":"2018-10-08T02:21:07.000Z","comments":true,"path":"2018/09/06/vue知识点总结/","link":"","permalink":"http://yoursite.com/2018/09/06/vue知识点总结/","excerpt":"","text":"1、Vue nextTick 使用原因Vue批量挂起DOM更新并异步应用它们以防止由多个数据突变导致的不必要的重新呈现。在实践中我们经常不得不Vue.nextTick等待Vue在我们触发某些状态更改之后执行实际的DOM更新。 2、Vue实现数据双向绑定的原理：Object.defineProperty()","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"JS 函数式编程指南","slug":"[JS] JS 函数式编程指南","date":"2018-09-06T02:30:23.000Z","updated":"2018-10-08T02:21:50.000Z","comments":true,"path":"2018/09/06/[JS] JS 函数式编程指南/","link":"","permalink":"http://yoursite.com/2018/09/06/[JS] JS 函数式编程指南/","excerpt":"","text":"","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"git 命令","slug":"git 命令","date":"2018-09-06T02:30:23.000Z","updated":"2018-10-08T02:21:10.000Z","comments":true,"path":"2018/09/06/git 命令/","link":"","permalink":"http://yoursite.com/2018/09/06/git 命令/","excerpt":"","text":"删除分支【git 删除本地分支】：git branch -D br【git 删除远程分支】：git push origin :br (origin 后面有空格)【恢复删除掉的分支】：git branch 分支名 hash_val 其中 hash_val 为散列值，如果不知，可利用 reflog。 reflog命令：显示整个本地仓储的commit，包括所有branch的commit，甚至包括已经撤销的commit。 eg: git branch 分支名 HEAD@{4} 【将远程的某个分支，拉取到本地】： 方法一： git checkout -b 本地分支名x origin/远程分支名x 方法二： git fetch origin 远程分支名x:本地分支名x 回退回滚取消提交返回上一版本【没有push】：git reset [ --soft || --hard || --mixed ] commitIdeg：git reset –hard 139dcfaa558e3276b30b6b2e5cbbb9c00bbdca96 (ID) –soft 保留源码（work），回退到 commit 信息到某个版本，不涉及index的回退 如果还需要提交，直接commit commit 回退，index和work不会 –hard 源码也会回退到某个版本，commit和index 都回退到某个版本。 commit、index和work都会改变 push之后千万不要使用，因为线上代码没变，包括commit和index； 但把本地代码修改完提交时会发生权限冲突 加 force 把修改推到远程： git push -f -u origin master –mixed 会保留源码，只会将 git commit 和index 回退 commit和index会回退，work保留 【已经push】git revert commintIdgit revert 反转提交（工作树必须干净 三个区域的状态、git status干净）用一个新提交来消除一个历史提交所做的任何修改。revert 本地代码回退，再git push 更新线上代码","categories":[{"name":"编码规范","slug":"编码规范","permalink":"http://yoursite.com/categories/编码规范/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"懒加载的实现","slug":"[JS] 懒加载","date":"2018-09-06T02:10:13.000Z","updated":"2018-10-08T02:21:36.000Z","comments":true,"path":"2018/09/06/[JS] 懒加载/","link":"","permalink":"http://yoursite.com/2018/09/06/[JS] 懒加载/","excerpt":"","text":"方法一：IntersectionObserver方法二：","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"node制作命令行","slug":"[Command] node制作命令行","date":"2018-08-25T02:55:51.000Z","updated":"2018-10-08T02:22:10.000Z","comments":true,"path":"2018/08/25/[Command] node制作命令行/","link":"","permalink":"http://yoursite.com/2018/08/25/[Command] node制作命令行/","excerpt":"","text":"目标：利用自制的命令行实现输出自己的简历；增加常用的命令：ls、 ls -a、打开当前目录 怎么制作命令行1、配置基础框架2、新建bin/qqResume.js目录，并如下:1234567891011121314151617181920212223242526#!/usr/bin/env node// 被成为 shebang ，表示用后面的路径所示的程序来执行当前文件夹const fs = require('fs');const path = process.cwd();const run = (obj) =&gt; &#123; if (obj[0] === '-v') &#123; console.log('verson is 1.0.0.0'); &#125; else if (obj[0] === '-h')&#123; console.log('Useage:'); console.log(' -v --version [show version]'); &#125; else &#123; fs.readdir(path, (err, files) =&gt; &#123; if (err) &#123; return console.log(err); &#125; for(var i = 0; i &lt; files.length; i += 1)&#123; console.log(files[i]); &#125; &#125;) &#125;&#125;//获取除第一个命令以后的参数，使用空格拆分run(process.argv.slice(2)); 运行可使用 node，在 package.json文件中配置 &quot;bin&quot;: { &quot;qqResume&quot;: &quot;bin/qqResume.js&quot; };3、全局运营命令 sudo npm install . -g npm link4、发布安装发布到npm中，首先需要 npm、github 账号：npm publish发布完成后可和平时的命令一样，全局安装: sudo npm i -g qqResume commanderCommander 是一款重量轻，表现力和强大的命令行框架。提供了用户命令行输入和参数解析强大功能。Commander的优势：自记录代码、自动生成帮助、合并短参数（“ABC”==“-A-B-C”）、默认选项、强制选项​​、命令解析、提示符 APIOption(): 初始化自定义参数对象，设置“关键字”和“描述”Command(): 初始化命令行参数对象，直接获得命令行输入Command#command(): 定义一个命令名字Command#action(): 注册一个callback函数Command#option(): 定义参数，需要设置“关键字”和“描述”，关键字包括“简写”和“全写”两部分，以”,”,”|”,”空格”做分隔。Command#parse(): 解析命令行参数argvCommand#description(): 设置description值Command#usage(): 设置usage值","categories":[{"name":"Command","slug":"Command","permalink":"http://yoursite.com/categories/Command/"}],"tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"},{"name":"commander","slug":"commander","permalink":"http://yoursite.com/tags/commander/"}]},{"title":"小细节小技巧","slug":"[CSS] 小细节小技巧","date":"2018-08-08T09:59:12.000Z","updated":"2018-10-18T14:06:58.990Z","comments":true,"path":"2018/08/08/[CSS] 小细节小技巧/","link":"","permalink":"http://yoursite.com/2018/08/08/[CSS] 小细节小技巧/","excerpt":"","text":"1、overflow的奇葩事件2、BFC块级格式化上下文3、font-size4、position:sticky5、清除浮动&emsp;&emsp;这篇文章专门用于记录在开发过程中遇到的奇葩现象，平时经常更新，用于自己的一个记录。 1、overflow的奇葩事件&emsp;&emsp;背景：这次遇到一个很奇怪的样子，其实应用的场景很简单，就是一个轮播，采用hidden处理周边的待滚动的li，但又接到hover上有动画的需求，此时设置overflow-x: hidden; overflow-y: visible;不能实现。没办法，看到网上好多人说增加父级，并对父级分别设置overflow来处理，不靠谱，实现不了。&emsp;&emsp;原因：这块和overflow非visible值会使一个块级元素形成一个BFC（块级格式化上下文）有关。overflow-x和overflow-y的计算值跟给定的值相同，除了某些跟’visible’值的不合理组合：如果一个其中一个属性的值被赋为’visible’，而另一个被赋值为’scroll’或’auto’，那么’visible’会被重置为’auto’。overflow的计算值与overflow-x相等（如果overflow-y相同的话）；否则就是一对overflow-x和overflow-y的计算值。 其实另一个值设置为hidden的时候，visible也会被重置为auto。&emsp;&emsp;处理方法：增加外围父级的高度，用于hover时的阴影用，然后margin点位置，用于hover时的上移。其他依旧正常设置，只是不让动画局限在撑起的高度内。 2、BFC块级格式化上下文3、font-size&emsp;&emsp;很简单的div模型，设置宽高后，同样可以利用font-size来扩大div的宽度，其原因可由 line-height 解释 4、position:sticky&emsp;&emsp;sticky原意为黏糊的，但在css中更多的表现为吸顶、吸底(移动端网站的头部返回栏,底部切换栏之类)的效果用这个属性非常适合。导航的效果像是在页面打开时是 relative 的,向下滑动的时候 fixed 并且 top:0 为零。 position:sticky可以认为是 position:relative 和 position:fixed 两种定位功能于一体的特殊定位。12345.sticky &#123; position: sticky; position: -webkit-sticky; top: 0; &#125; 注意：可以放心在ios上使用，可以使用polyfill进行处理注意坑 1、sticky 不会触发 BFC。 2、z-index 无效。 3、sticky 是容器相关的,也就说 sticky 的特性只会在他所处的容器里生效。碰到 body 设置 height:100% 的时候 sticky 元素停在某一个位置不动了。 5、清除浮动方法一：12345/* 在容器内添加一个CSS伪元素， */.clear::before &#123; content: ''; clear: both;&#125; 方法二：清除浮动的另一个方法是在容器内创建BFC，一个BFC元素完全包裹住了它内部的所有元素，包括内部的浮动元素，保证浮动元素不会超出其底部。清除浮动的方式是为元素设置除visible（默认）之外的overflow属性值。123.container &#123; overflow: auto;&#125; 然而，在某些情况下，这可能会带来一些阴影的截断或是非预期的滚动条。同时它也使你的CSS变得不那么直观. 方法三：display: flow-root123.container &#123; display: flow-root;&#125; display: flow-root做的唯一的一件事就是去创建一个BFC，因此可以避免其他创建BFC方法带来的问题。 6、css容易不注意的块元素和行内元素块元素：会独自占据一整行或多整行，可以对其设置宽高 ~、、、、、行内元素：靠自身的字体大小和版本尺寸来支撑结构、、、、、、、、、 选择优先级行内 &gt; id &gt; 类 &gt; 标签 &gt; 通配符选择器 &gt; 继承样式 &gt; 浏览器默认的样式","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"commander开发命令行工具","slug":"[Command] commander开发命令行工具","date":"2018-07-27T06:28:31.000Z","updated":"2018-10-08T02:22:06.000Z","comments":true,"path":"2018/07/27/[Command] commander开发命令行工具/","link":"","permalink":"http://yoursite.com/2018/07/27/[Command] commander开发命令行工具/","excerpt":"","text":"在学习开发的时候，遇到了commander的使用，实现对数据","categories":[{"name":"Command","slug":"Command","permalink":"http://yoursite.com/categories/Command/"}],"tags":[{"name":"cli","slug":"cli","permalink":"http://yoursite.com/tags/cli/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"git commit 规范","slug":"[编码规范] git commit规范","date":"2018-07-19T01:55:12.000Z","updated":"2018-10-08T02:21:13.000Z","comments":true,"path":"2018/07/19/[编码规范] git commit规范/","link":"","permalink":"http://yoursite.com/2018/07/19/[编码规范] git commit规范/","excerpt":"","text":"&emsp;&emsp;前段时间组内规范了工作流，设定了commit message 规范，开始时甚是痛苦，但是习惯了发现好处颇多。现在社区中有很多 Commit message的写法规范，个人认为 Angular 规范 是目前使用最广的写法。 commit message 的作用 提供更多的历史信息，方便快速浏览。 可以过滤某些commit（比如文档改动），便于快速查找信息。 可以直接从commit生成Change log。 可读性好，清晰，不必深入看代码即可了解当前commit的作用。 为 Code Reviewing做准备 方便跟踪工程历史 让其他的开发者在运行 git blame 的时候想跪谢 提高项目的整体质量，提高个人工程素质 commit message 的格式&emsp;&emsp;Commit message 包括三个部分：header(必需)、body(可省)和footer(可省).任何一行都不得超过72个字符（或100个字符），这是为了避免自动换行影响美观。 HeaderHeader 部分只有一行，包括三个字段 type（必需）、scope（可选）和subject（必需）。 type ：用于说明 commit 的类别，只允许使用下面7个标识。 feat：新功能（feature） fix：修补bug docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改bug的代码变动） test：增加测试 chore：构建过程或辅助工具的变动 一般情况下，type为feat和fix，则该 commit 将肯定出现在 Change log 之中，其他的自己可以设置。 scope: 用于说明 commit 影响的范围，比如数据层、控制层、视图层等等。例如在Angular，可以是$location, $browser, $compile, $rootScope, ngHref, ngClick, ngView等。 subject: 是 commit 目的的简短描述，开头需要使用第一人称现在时的动词开头。 BodyBody 部分是对本次 commit 的详细描述，可以分成多行1、使用第一人称现在时，比如使用change而不是changed或changes。2、永远别忘了第2行是空行。3、应该说明代码变动的动机，以及与以前行为的对比。 FooterFooter 部分只用于以下两种情况：1、不兼容变动&emsp;&emsp;&emsp;&emsp;若当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法。12345678910111213BREAKING CHANGE: isolate scope bindings definition has changed. To migrate the code follow the example below: Before: scope: &#123; myAttr: 'attribute', &#125; After: scope: &#123; myAttr: '@', &#125;The removed `inject` wasn't generaly useful for directives so there should be no code using it. 2、关闭issue&emsp;&emsp;&emsp;&emsp;若当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。Closes #234 补充 Revrt若当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header。12revert: feat(pencil): add &apos;graphiteWidth&apos; optionThis reverts commit 667ecc1654a317a13331b17617d973392f415f02. Body部分的格式是固定的，必须写成This reverts commit &amp;lt;hash&gt;，其中的hash是被撤销 commit 的 SHA 标识符。若当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的Reverts小标题下面。 Commitizen可以使用典型的git工作流程或通过使用CLI向导Commitizen来添加提交消息格式。 安装 npm i -g commitizen然后，在项目目录里，运行下面的命令，使其支持 Angular 的 Commit message 格式。commitizen init cz-conventional-changelog --save --save-exact以后，凡是用到git commit命令，一律改为使用git cz。这时，就会出现选项，用来生成符合格式的 Commit message。 validate-commit-msgvalidate-commit-msg 用于检查项目的 Commit message 是否符合Angular规范。该包提供了使用githooks来校验commit message的一些二进制文件。推荐使用husky，只需要添加 “commitmsg”: “validate-commit-msg” 到package.json中的nam scripts即可. 当然，还可以通过定义配置文件.vcmrc来自定义校验格式。详细使用请见文档 validate-commit-msg 生成Change log如果commit都符合规则，则发布新版本时，Change log 就可以用脚本自动生成。生成的文档主要包括：New feature、Bug fixed、Breaking changes。每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。 conventional-changelog 就是生成 Change log 的工具，运行下面的命令即可。123$ npm install -g conventional-changelog$ cd my-project$ conventional-changelog -p angular -i CHANGELOG.md -w","categories":[{"name":"编码规范","slug":"编码规范","permalink":"http://yoursite.com/categories/编码规范/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"代码规范","slug":"代码规范","permalink":"http://yoursite.com/tags/代码规范/"}]},{"title":".eslintrc的解释","slug":"[编码规范] eslintrc的解释","date":"2018-07-18T10:08:12.000Z","updated":"2018-10-08T02:21:18.000Z","comments":true,"path":"2018/07/18/[编码规范] eslintrc的解释/","link":"","permalink":"http://yoursite.com/2018/07/18/[编码规范] eslintrc的解释/","excerpt":"","text":"可以通过三种方式配置ESLint:1、 使用 .eslintrc 文件(支持 JSON 和 YAML 两种语法)；2、 在 package.json 中添加 eslintConfig 配置块；3、 直接在代码文件中定义。 对 .eslintrc 的研究摘录如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514&#123; // 环境定义了预定义的全局变量。 \"env\": &#123; //环境定义了预定义的全局变量。更多在官网查看 \"browser\": true, \"node\": true, \"commonjs\": true, \"amd\": true, \"es6\":true, \"mocha\":true &#125;, // JavaScript 语言选项 \"parserOptions\": &#123; // ECMAScript 版本 \"ecmaVersion\": 6, \"sourceType\": \"script\",//module // 想使用的额外的语言特性: \"ecmaFeatures\": &#123; // 允许在全局作用域下使用 return 语句 \"globalReturn\":true, // impliedStric \"impliedStrict\":true, // 启用 JSX \"jsx\":true &#125; &#125;, /** * \"off\" 或 0 - 关闭规则 * \"warn\" 或 1 - 开启规则，使用警告级别的错误：warn (不会导致程序退出), * \"error\" 或 2 - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出) */ \"rules\": &#123; //////////////// // 可能的错误 // //////////////// // 禁止条件表达式中出现赋值操作符 \"no-cond-assign\": 2, // 禁用 console \"no-console\": 0, // 禁止在条件中使用常量表达式 // if (false) &#123; // doSomethingUnfinished(); // &#125; //cuowu \"no-constant-condition\": 2, // 禁止在正则表达式中使用控制字符 ：new RegExp(\"\\x1f\") \"no-control-regex\": 2, // 数组和对象键值对最后一个逗号， never参数：不能带末尾的逗号, always参数：必须带末尾的逗号， // always-multiline：多行模式必须带逗号，单行模式不能带逗号 \"comma-dangle\": [1, \"always-multiline\"], // 禁用 debugger \"no-debugger\": 2, // 禁止 function 定义中出现重名参数 \"no-dupe-args\": 2, // 禁止对象字面量中出现重复的 key \"no-dupe-keys\": 2, // 禁止重复的 case 标签 \"no-duplicate-case\": 2, // 禁止空语句块 \"no-empty\": 2, // 禁止在正则表达式中使用空字符集 (/^abc[]/) \"no-empty-character-class\": 2, // 禁止对 catch 子句的参数重新赋值 \"no-ex-assign\": 2, // 禁止不必要的布尔转换 \"no-extra-boolean-cast\": 2, // 禁止不必要的括号 //(a * b) + c;//报错 \"no-extra-parens\": 0, // 禁止不必要的分号 \"no-extra-semi\": 2, // 禁止对 function 声明重新赋值 \"no-func-assign\": 2, // 禁止在嵌套的块中出现 function 或 var 声明 \"no-inner-declarations\": [2, \"functions\"], // 禁止 RegExp 构造函数中无效的正则表达式字符串 \"no-invalid-regexp\": 2, // 禁止在字符串和注释之外不规则的空白 \"no-irregular-whitespace\": 2, // 禁止在 in 表达式中出现否定的左操作数 \"no-negated-in-lhs\": 2, // 禁止把全局对象 (Math 和 JSON) 作为函数调用 错误：var math = Math(); \"no-obj-calls\": 2, // 禁止直接使用 Object.prototypes 的内置属性 \"no-prototype-builtins\":0, // 禁止正则表达式字面量中出现多个空格 \"no-regex-spaces\": 2, // 禁用稀疏数组 \"no-sparse-arrays\": 2, // 禁止出现令人困惑的多行表达式 \"no-unexpected-multiline\": 2, // 禁止在return、throw、continue 和 break语句之后出现不可达代码 /* function foo() &#123; return true; console.log(\"done\"); &#125;//错误 */ \"no-unreachable\": 2, // 要求使用 isNaN() 检查 NaN \"use-isnan\": 2, // 强制使用有效的 JSDoc 注释 \"valid-jsdoc\": 1, // 强制 typeof 表达式与有效的字符串进行比较 // typeof foo === \"undefimed\" 错误 \"valid-typeof\": 2, ////////////// // 最佳实践 // ////////////// // 定义对象的set存取器属性时，强制定义get \"accessor-pairs\": 2, // 强制数组方法的回调函数中有 return 语句 \"array-callback-return\":0, // 强制把变量的使用限制在其定义的作用域范围内 \"block-scoped-var\": 0, // 限制圈复杂度，也就是类似if else能连续接多少个 \"complexity\": [2, 9], // 要求 return 语句要么总是指定返回的值，要么不指定 \"consistent-return\": 0, // 强制所有控制语句使用一致的括号风格 \"curly\": [2, \"all\"], // switch 语句强制 default 分支，也可添加 // no default 注释取消此次警告 \"default-case\": 2, // 强制object.key 中 . 的位置，参数: // property，'.'号应与属性在同一行 // object, '.' 号应与对象名在同一行 \"dot-location\": [2, \"property\"], // 强制使用.号取属性 // 参数： allowKeywords：true 使用保留字做属性名时，只能使用.方式取属性 // false 使用保留字做属性名时, 只能使用[]方式取属性 e.g [2, &#123;\"allowKeywords\": false&#125;] // allowPattern: 当属性名匹配提供的正则表达式时，允许使用[]方式取值,否则只能用.号取值 e.g [2, &#123;\"allowPattern\": \"^[a-z]+(_[a-z]+)+$\"&#125;] \"dot-notation\": [2, &#123; \"allowKeywords\": false &#125;], // 使用 === 替代 == allow-null允许null和undefined== \"eqeqeq\": [2, \"allow-null\"], // 要求 for-in 循环中有一个 if 语句 \"guard-for-in\": 2, // 禁用 alert、confirm 和 prompt \"no-alert\": 0, // 禁用 arguments.caller 或 arguments.callee \"no-caller\": 2, // 不允许在 case 子句中使用词法声明 \"no-case-declarations\":2, // 禁止除法操作符显式的出现在正则表达式开始的位置 \"no-div-regex\": 2, // 禁止 if 语句中有 return 之后有 else \"no-else-return\": 0, // 禁止出现空函数.如果一个函数包含了一条注释，它将不会被认为有问题。 \"no-empty-function\":2, // 禁止使用空解构模式no-empty-pattern \"no-empty-pattern\":2, // 禁止在没有类型检查操作符的情况下与 null 进行比较 \"no-eq-null\": 1, // 禁用 eval() \"no-eval\": 2, // 禁止扩展原生类型 \"no-extend-native\": 2, // 禁止不必要的 .bind() 调用 \"no-extra-bind\": 2, // 禁用不必要的标签 \"no-extra-label:\":0, // 禁止 case 语句落空 \"no-fallthrough\": 2, // 禁止数字字面量中使用前导和末尾小数点 \"no-floating-decimal\": 2, // 禁止使用短符号进行类型转换(!!fOO) \"no-implicit-coercion\":0, // 禁止在全局范围内使用 var 和命名的 function 声明 \"no-implicit-globals\":1, // 禁止使用类似 eval() 的方法 \"no-implied-eval\": 2, // 禁止 this 关键字出现在类和类对象之外 \"no-invalid-this\":0, // 禁用 __iterator__ 属性 \"no-iterator\": 2, // 禁用标签语句 \"no-labels\": 2, // 禁用不必要的嵌套块 \"no-lone-blocks\": 2, // 禁止在循环中出现 function 声明和表达式 \"no-loop-func\":1, // 禁用魔术数字(3.14什么的用常量代替) \"no-magic-numbers\":[1,&#123; \"ignore\": [0,-1,1] &#125;], // 禁止使用多个空格 \"no-multi-spaces\": 2, // 禁止使用多行字符串，在 JavaScript 中，可以在新行之前使用斜线创建多行字符串 \"no-multi-str\": 2, // 禁止对原生对象赋值 \"no-native-reassign\": 2, // 禁止在非赋值或条件语句中使用 new 操作符 \"no-new\": 2, // 禁止对 Function 对象使用 new 操作符 \"no-new-func\": 0, // 禁止对 String，Number 和 Boolean 使用 new 操作符 \"no-new-wrappers\": 2, // 禁用八进制字面量 \"no-octal\": 2, // 禁止在字符串中使用八进制转义序列 \"no-octal-escape\": 2, // 不允许对 function 的参数进行重新赋值 \"no-param-reassign\": 0, // 禁用 __proto__ 属性 \"no-proto\": 2, // 禁止使用 var 多次声明同一变量 \"no-redeclare\": 2, // 禁用指定的通过 require 加载的模块 \"no-return-assign\": 0, // 禁止使用 javascript: url \"no-script-url\": 0, // 禁止自我赋值 \"no-self-assign\":2, // 禁止自身比较 \"no-self-compare\": 2, // 禁用逗号操作符 \"no-sequences\": 2, // 禁止抛出非异常字面量 \"no-throw-literal\": 2, // 禁用一成不变的循环条件 \"no-unmodified-loop-condition\":2, // 禁止出现未使用过的表达式 \"no-unused-expressions\": 0, // 禁用未使用过的标签 \"no-unused-labels\":2, // 禁止不必要的 .call() 和 .apply() \"no-useless-call\":2, // 禁止不必要的字符串字面量或模板字面量的连接 \"no-useless-concat\":2, // 禁用不必要的转义字符 \"no-useless-escape\":0, // 禁用 void 操作符 \"no-void\": 0, // 禁止在注释中使用特定的警告术语 \"no-warning-comments\": 0, // 禁用 with 语句 \"no-with\": 2, // 强制在parseInt()使用基数参数 \"radix\": 2, // 要求所有的 var 声明出现在它们所在的作用域顶部 \"vars-on-top\": 0, // 要求 IIFE 使用括号括起来 \"wrap-iife\": [2, \"any\"], // 要求或禁止 “Yoda” 条件 \"yoda\": [2, \"never\"], // 要求或禁止使用严格模式指令 \"strict\": 0, ////////////// // 变量声明 // ////////////// // 要求或禁止 var 声明中的初始化(初值) \"init-declarations\":0, // 不允许 catch 子句的参数与外层作用域中的变量同名 \"no-catch-shadow\": 0, // 禁止删除变量 \"no-delete-var\": 2, // 不允许标签与变量同名 \"no-label-var\": 2, // 禁用特定的全局变量 \"no-restricted-globals\":0, // 禁止 var 声明 与外层作用域的变量同名 \"no-shadow\": 0, // 禁止覆盖受限制的标识符 \"no-shadow-restricted-names\": 2, // 禁用未声明的变量，除非它们在 /*global */ 注释中被提到 \"no-undef\": 2, // 禁止将变量初始化为 undefined \"no-undef-init\": 2, // 禁止将 undefined 作为标识符 \"no-undefined\": 0, // 禁止出现未使用过的变量 \"no-unused-vars\": [2, &#123; \"vars\": \"all\", \"args\": \"none\" &#125;], // 不允许在变量定义之前使用它们 \"no-use-before-define\": 0, ////////////////////////// // Node.js and CommonJS // ////////////////////////// // require return statements after callbacks \"callback-return\":0, // 要求 require() 出现在顶层模块作用域中 \"global-require\": 1, // 要求回调函数中有容错处理 \"handle-callback-err\": [2, \"^(err|error)$\"], // 禁止混合常规 var 声明和 require 调用 \"no-mixed-requires\": 0, // 禁止调用 require 时使用 new 操作符 \"no-new-require\": 2, // 禁止对 __dirname 和 __filename进行字符串连接 \"no-path-concat\": 0, // 禁用 process.env \"no-process-env\": 0, // 禁用 process.exit() \"no-process-exit\": 0, // 禁用同步方法 \"no-sync\": 0, ////////////// // 风格指南 // ////////////// // 指定数组的元素之间要以空格隔开(, 后面)， never参数：[ 之前和 ] 之后不能带空格，always参数：[ 之前和 ] 之后必须带空格 \"array-bracket-spacing\": [2, \"never\"], // 禁止或强制在单行代码块中使用空格(禁用) \"block-spacing\":[1,\"never\"], //强制使用一致的缩进 第二个参数为 \"tab\" 时，会使用tab， // if while function 后面的&#123;必须与if在同一行，java风格。 \"brace-style\": [2, \"1tbs\", &#123; \"allowSingleLine\": true &#125;], // 双峰驼命名格式 \"camelcase\": 2, // 控制逗号前后的空格 \"comma-spacing\": [2, &#123; \"before\": false, \"after\": true &#125;], // 控制逗号在行尾出现还是在行首出现 (默认行尾) // http://eslint.org/docs/rules/comma-style \"comma-style\": [2, \"last\"], //\"SwitchCase\" (默认：0) 强制 switch 语句中的 case 子句的缩进水平 // 以方括号取对象属性时，[ 后面和 ] 前面是否需要空格, 可选参数 never, always \"computed-property-spacing\": [2, \"never\"], // 用于指统一在回调函数中指向this的变量名，箭头函数中的this已经可以指向外层调用者，应该没卵用了 // e.g [0,\"that\"] 指定只能 var that = this. that不能指向其他任何值，this也不能赋值给that以外的其他值 \"consistent-this\": [1,\"that\"], // 强制使用命名的 function 表达式 \"func-names\": 0, // 文件末尾强制换行 \"eol-last\": 2, \"indent\": [2, 4, &#123; \"SwitchCase\": 1 &#125;], // 强制在对象字面量的属性中键和值之间使用一致的间距 \"key-spacing\": [2, &#123; \"beforeColon\": false, \"afterColon\": true &#125;], // 强制使用一致的换行风格 \"linebreak-style\": [1,\"unix\"], // 要求在注释周围有空行 ( 要求在块级注释之前有一空行) \"lines-around-comment\": [1,&#123;\"beforeBlockComment\":true&#125;], // 强制一致地使用函数声明或函数表达式，方法定义风格，参数： // declaration: 强制使用方法声明的方式，function f()&#123;&#125; e.g [2, \"declaration\"] // expression：强制使用方法表达式的方式，var f = function() &#123;&#125; e.g [2, \"expression\"] // allowArrowFunctions: declaration风格中允许箭头函数。 e.g [2, \"declaration\", &#123; \"allowArrowFunctions\": true &#125;] \"func-style\": 0, // 强制回调函数最大嵌套深度 5层 \"max-nested-callbacks\": [1,5], // 禁止使用指定的标识符 \"id-blacklist\":0, // 强制标识符的最新和最大长度 \"id-length\":0, // 要求标识符匹配一个指定的正则表达式 \"id-match\":0, // 强制在 JSX 属性中一致地使用双引号或单引号 \"jsx-quotes\":0, // 强制在关键字前后使用一致的空格 (前后腰需要) \"keyword-spacing\":2, // 强制一行的最大长度 \"max-len\":[1,200], // 强制最大行数 \"max-lines\":0, // 强制 function 定义中最多允许的参数数量 \"max-params\":[1,7], // 强制 function 块最多允许的的语句数量 \"max-statements\":[1,200], // 强制每一行中所允许的最大语句数量 \"max-statements-per-line\":0, // 要求构造函数首字母大写 （要求调用 new 操作符时有首字母大小的函数，允许调用首字母大写的函数时没有 new 操作符。） \"new-cap\": [2, &#123; \"newIsCap\": true, \"capIsNew\": false &#125;], // 要求调用无参构造函数时有圆括号 \"new-parens\": 2, // 要求或禁止 var 声明语句后有一行空行 \"newline-after-var\": 0, // 禁止使用 Array 构造函数 \"no-array-constructor\": 2, // 禁用按位运算符 \"no-bitwise\":0, // 要求 return 语句之前有一空行 \"newline-before-return\":0, // 要求方法链中每个调用都有一个换行符 \"newline-per-chained-call\":1, // 禁用 continue 语句 \"no-continue\": 0, // 禁止在代码行后使用内联注释 \"no-inline-comments\": 0, // 禁止 if 作为唯一的语句出现在 else 语句中 \"no-lonely-if\": 0, // 禁止混合使用不同的操作符 \"no-mixed-operators\":0, // 不允许空格和 tab 混合缩进 \"no-mixed-spaces-and-tabs\": 2, // 不允许多个空行 \"no-multiple-empty-lines\": [2, &#123; \"max\": 2 &#125;], // 不允许否定的表达式 \"no-negated-condition\":0, // 不允许使用嵌套的三元表达式 \"no-nested-ternary\": 0, // 禁止使用 Object 的构造函数 \"no-new-object\": 2, // 禁止使用一元操作符 ++ 和 -- \"no-plusplus\":0, // 禁止使用特定的语法 \"no-restricted-syntax\":0, // 禁止 function 标识符和括号之间出现空格 \"no-spaced-func\": 2, // 不允许使用三元操作符 \"no-ternary\": 0, // 禁用行尾空格 \"no-trailing-spaces\": 2, // 禁止标识符中有悬空下划线_bar \"no-underscore-dangle\": 0, // 禁止可以在有更简单的可替代的表达式时使用三元操作符 \"no-unneeded-ternary\": 2, // 禁止属性前有空白 \"no-whitespace-before-property\":0, // 强制花括号内换行符的一致性 \"object-curly-newline\":0, // 强制在花括号中使用一致的空格 \"object-curly-spacing\": 0, // 强制将对象的属性放在不同的行上 \"object-property-newline\":0, // 强制函数中的变量要么一起声明要么分开声明 \"one-var\": [2, &#123; \"initialized\": \"never\" &#125;], // 要求或禁止在 var 声明周围换行 \"one-var-declaration-per-line\":0, // 要求或禁止在可能的情况下要求使用简化的赋值操作符 \"operator-assignment\": 0, // 强制操作符使用一致的换行符 \"operator-linebreak\": [2, \"after\", &#123; \"overrides\": &#123; \"?\": \"before\", \":\": \"before\" &#125; &#125;], // 要求或禁止块内填充 \"padded-blocks\": 0, // 要求对象字面量属性名称用引号括起来 \"quote-props\": 0, // 强制使用一致的反勾号、双引号或单引号 \"quotes\": [2, \"single\", \"avoid-escape\"], // 要求使用 JSDoc 注释 \"require-jsdoc\":1, // 要求或禁止使用分号而不是 ASI（这个才是控制行尾部分号的，） \"semi\": [2, \"always\"], // 强制分号之前和之后使用一致的空格 \"semi-spacing\": 0, // 要求同一个声明块中的变量按顺序排列 \"sort-vars\": 0, // 强制在块之前使用一致的空格 \"space-before-blocks\": [2, \"always\"], // 强制在 function的左括号之前使用一致的空格 \"space-before-function-paren\": [2, \"always\"], // 强制在圆括号内使用一致的空格 \"space-in-parens\": [2, \"never\"], // 要求操作符周围有空格 \"space-infix-ops\": 2, // 强制在一元操作符前后使用一致的空格 \"space-unary-ops\": [2, &#123; \"words\": true, \"nonwords\": false &#125;], // 强制在注释中 // 或 /* 使用一致的空格 \"spaced-comment\": [2, \"always\", &#123; \"markers\": [\"global\", \"globals\", \"eslint\", \"eslint-disable\", \"*package\", \"!\"] &#125;], // 要求或禁止 Unicode BOM \"unicode-bom\": 0, // 要求正则表达式被括号括起来 \"wrap-regex\": 0, ////////////// // ES6.相关 // ////////////// // 要求箭头函数体使用大括号 \"arrow-body-style\": 2, // 要求箭头函数的参数使用圆括号 \"arrow-parens\": 2, \"arrow-spacing\":[2,&#123; \"before\": true, \"after\": true &#125;], // 强制在子类构造函数中用super()调用父类构造函数，TypeScrip的编译器也会提示 \"constructor-super\": 0, // 强制 generator 函数中 * 号周围使用一致的空格 \"generator-star-spacing\": [2, &#123; \"before\": true, \"after\": true &#125;], // 禁止修改类声明的变量 \"no-class-assign\":2, // 不允许箭头功能，在那里他们可以混淆的比较 \"no-confusing-arrow\":0, // 禁止修改 const 声明的变量 \"no-const-assign\":2, // 禁止类成员中出现重复的名称 \"no-dupe-class-members\":2, // 不允许复制模块的进口 \"no-duplicate-imports\":0, // 禁止 Symbol 的构造函数 \"no-new-symbol\":2, // 允许指定模块加载时的进口 \"no-restricted-imports\":0, // 禁止在构造函数中，在调用 super() 之前使用 this 或 super \"no-this-before-super\": 2, // 禁止不必要的计算性能键对象的文字 \"no-useless-computed-key\":0, // 要求使用 let 或 const 而不是 var \"no-var\": 0, // 要求或禁止对象字面量中方法和属性使用简写语法 \"object-shorthand\": 0, // 要求使用箭头函数作为回调 \"prefer-arrow-callback\":0, // 要求使用 const 声明那些声明后不再被修改的变量 \"prefer-const\": 0, // 要求在合适的地方使用 Reflect 方法 \"prefer-reflect\":0, // 要求使用扩展运算符而非 .apply() \"prefer-spread\":0, // 要求使用模板字面量而非字符串连接 \"prefer-template\":0, // Suggest using the rest parameters instead of arguments \"prefer-rest-params\":0, // 要求generator 函数内有 yield \"require-yield\":0, // enforce spacing between rest and spread operators and their expressions \"rest-spread-spacing\":0, // 强制模块内的 import 排序 \"sort-imports\":0, // 要求或禁止模板字符串中的嵌入表达式周围空格的使用 \"template-curly-spacing\":1, // 强制在 yield* 表达式中 * 周围使用空格 \"yield-star-spacing\":2 &#125;&#125;","categories":[{"name":"编码规范","slug":"编码规范","permalink":"http://yoursite.com/categories/编码规范/"}],"tags":[{"name":"代码规范","slug":"代码规范","permalink":"http://yoursite.com/tags/代码规范/"},{"name":"eslint","slug":"eslint","permalink":"http://yoursite.com/tags/eslint/"}]},{"title":"学习cli","slug":"[Command] 学习cli","date":"2018-07-18T10:08:12.000Z","updated":"2018-10-15T09:33:59.000Z","comments":true,"path":"2018/07/18/[Command] 学习cli/","link":"","permalink":"http://yoursite.com/2018/07/18/[Command] 学习cli/","excerpt":"","text":"&emsp;在这之前一直想做一个cli的脚手架，近期公司团队中有一位大牛开发完成，想自己学习，做了这篇学习记录，他的cli工具支持ValillaJS、VueJS、React、Angular等四大主流框架，我就学习Vue的即可，等之后有了自己的需求，自己再加。&emsp;Cli有三个模块组成：初始化、开发和构建 co、co-prompt的方法类似于 inquirer 1、项目的初始化目录 .gitignore.editorconfigindex.jsLINCESEpackage.jsonREADME.md 2、安装eslint以及配置lint、eslintConfig 在package.json中对 lint和eslint进行配置，对eslint中的rules进行约束 comma-dangle、no-console等3、利用husky设置git hooksprecommit 结合2 中的lint 规范代码4、利用commitlint lint commit 信息commitmsg、commitlint 提交信息的lint 规范，可参考 git commit 规范5、增加基础的cli信息，commander的使用init|server|build command -&gt; bin/cli.js commander 命令行自制 init | server | build6、i18n（国际化）的支持 增加i18n 英中文 对init|server|build 的说明，并修改bin/cli.js 的描述7、在lib中增加 logger.js 增加 logger util，用于 commander 命令的处理并作出不同的运行结果显示，比如：安装完毕，服务开启完毕，报错提示等。 补充：1、chalk 是一个颜色的插件123456const chalk = require('chalk');// Use RGB colors in terminal emulators that support it.console.log(chalk.blue('Hello') + 'World' + chalk.red('!'));console.log(chalk.keyword('orange')('Yay for orange colored text!'));console.log(chalk.rgb(123, 45, 67).underline('Underlined reddish color'));console.log(chalk.hex('#DEADED').bold('Bold gray!')); 2、readline 处理日志文本很方便，逐行读取 可参考node中文网查看API Node.js里实现标准输入输出的封装好的模块，通过这个模块我们可以以逐行的方式读取数据流。 3、nodejs的知识点：process.cwd() 是当前执行node命令时候的文件夹地址 ——工作目录（当前Node.js进程执行时的工作目录）dirname 是被执行的js 文件的地址 ——文件所在目录（当前模块的目录名） node.js进程当前工作的目录有可能不是该文件所在目录的完整目录 filename 获取当前模块文件的带有完整绝对路径的文件名 eg:process.cwd() /Users/meizu/myfile/programFile/cli-learn/lib__dirname /Users/meizu/myfile/programFile/cli-learn/lib__filename /Users/meizu/myfile/programFile/cli-learn/lib/config.js 4、node child_process 子进程 4、rimraf：以包的形式包装rm -rf命令，用来删除文件和文件夹的，不管文件夹是否为空，都可删除。5、extend：","categories":[{"name":"Command","slug":"Command","permalink":"http://yoursite.com/categories/Command/"}],"tags":[{"name":"cli","slug":"cli","permalink":"http://yoursite.com/tags/cli/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"flex遇到的那些坑","slug":"[CSS] flex遇到的那些坑","date":"2018-07-17T14:26:08.000Z","updated":"2018-10-08T02:21:58.000Z","comments":true,"path":"2018/07/17/[CSS] flex遇到的那些坑/","link":"","permalink":"http://yoursite.com/2018/07/17/[CSS] flex遇到的那些坑/","excerpt":"","text":"&emsp;在一次H5的项目开发中，由于是典型的左中右的布局，就使用了flex，但是遇到了一些坑，在记录之前，先简单的说下flex吧，想兼容PC IE10之前的，就不要用了，还是老实的使用float吧。 flex基础&emsp; flex布局主要设计12个属性（父容器和子容器各6个），但实际常用的只有4个（各2个） 作用于父容器的属性：flex-direction：决定主轴的方向flex-wrap：换行的方式flex-flow：为flex-direction和flex-wrap的简写形式，默认为：row nowrapjust-content：在主轴上的对齐方式（eg 水平）align-items：在交叉轴上的对齐方式（eg 垂直）align-content：多根轴线的对齐方式，若只有一根轴线，不起作用 作用于子容器的属性：order：排列顺序，数值越小，排列越靠前flex-grow：放大比例，默认为0，不放大&emsp;&emsp;&emsp;&emsp;&emsp;若所有项目该值都为1，表示等分&emsp;&emsp;&emsp;&emsp;&emsp;若有一个是2，其他的都为1 ，前者占据的剩余空间将比其他项多一倍flex-shrink：缩小比例，默认为1 ，即空间不足，项目将缩小&emsp;&emsp;&emsp;&emsp;&emsp;若所有项目该值为1 ，当空间不足时，将等比例缩小&emsp;&emsp;&emsp;&emsp;&emsp;若有一个是0，其他的都为1，则空间不足时，前者不缩小flex-basis：在分配多余空间之前，项目占据的主轴空间flex：flex-grow, flex-shrink 和 flex-basis的缩写，有auto(1 1 auto)和none(0 0 auto)快捷键align-self：允许单个项目有与其他小哀公母不一样的对齐方式，可覆盖align-items属性 遇坑计设置了flex-grow元素的子级宽度问题基础总结：","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"css3","slug":"css3","permalink":"http://yoursite.com/tags/css3/"}]},{"title":"canvas系列之小球的碰撞运动","slug":"[Canvas] canvas系列之小球的碰撞运动","date":"2018-07-16T08:13:45.000Z","updated":"2018-10-15T06:19:49.000Z","comments":true,"path":"2018/07/16/[Canvas] canvas系列之小球的碰撞运动/","link":"","permalink":"http://yoursite.com/2018/07/16/[Canvas] canvas系列之小球的碰撞运动/","excerpt":"","text":"&emsp;之前分享过一次canvas的技术","categories":[{"name":"Canvas","slug":"Canvas","permalink":"http://yoursite.com/categories/Canvas/"}],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/tags/canvas/"}]}]}