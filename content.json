{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"rubyliuqq","url":"http://yoursite.com"},"pages":[{"title":"书单","date":"2018-10-15T15:07:38.673Z","updated":"2018-10-08T02:08:44.000Z","comments":false,"path":"books/index.html","permalink":"http://yoursite.com/books/index.html","excerpt":"","text":"douban 豆瓣书单douban: user: 琴琴0126 # 豆瓣用户名 start: 0 # 从哪一条记录开始 count: 100 # 获取豆瓣书单数据条数"},{"title":"Repositories","date":"2018-10-15T15:07:38.656Z","updated":"2018-10-08T02:02:09.000Z","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":"Githubgithub: username: rubyliuqq # github username"}],"posts":[{"title":"深拷贝与浅拷贝","slug":"[JS] 深拷贝与浅拷贝","date":"2018-10-31T10:56:31.000Z","updated":"2018-10-31T10:56:30.177Z","comments":true,"path":"2018/10/31/[JS] 深拷贝与浅拷贝/","link":"","permalink":"http://yoursite.com/2018/10/31/[JS] 深拷贝与浅拷贝/","excerpt":"","text":"","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"客户端存储技术.md","slug":"[JS] 客户端存储技术","date":"2018-10-29T08:45:25.000Z","updated":"2018-10-29T13:04:42.605Z","comments":true,"path":"2018/10/29/[JS] 客户端存储技术/","link":"","permalink":"http://yoursite.com/2018/10/29/[JS] 客户端存储技术/","excerpt":"","text":"常用的客户端存储方法有哪些？cookie：是客户端用来存储数据的一种选项，它既可以在客户端设置也可以在服务器端设置。cookie会跟随任意HTTP请求一起发送。是「浏览器」提供的一种机制。sessionStorage：严格用于一个浏览器会话中存储数据，因为数据在浏览器关闭后会立即删除localStorage：用于跨会话持久化地存储数据indexedDB：在浏览器中保存结构化数据的一种「数据库」cookie：兼容性好，可以通过document.cookie访问它缺点：1、增加了网络流量；2、它的数据容量有限，最多只能存储4KB的数据，浏览器之间各有不同；3、不安全。SessionStorage、LocalStorage缺点：IE不支持 SessionStorage，低版本IE ( IE6, IE7 ) 不支持 LocalStorage，并且不支持查询语言indexedDB：兼容性不好，未得到大部分浏览器的支持 cookie、sessionStorage和localStorage的区别？ 存储时效：cookie可以手动设置失效期，默认为会话级sessionStorage的存储时长是会话级localStorage的存储时长是永久，除非用户手动利用浏览器的工具删除 访问的局限性：cookie可以设置路径path，所以它要比另外两个多了一层访问限制localStorage和sessionStorage的访问限制是文档源级别，即协议、主机名和端口cookie可以通过设置domain属性值，可以在不同二级域名下共享cookie，而Storage不可以，比如http://image.baidu.com的cookie http://map.baidu.com是可以访问的，前提是cookie的domain设置为http://baidu.com，而Storage是不可以的 存储大小限制：cookie适合存储少量数据，他的大小限制是个数进行限制，每个浏览器的限制数量不同Storage可以存储数据的量较大，此外它是通过占用空间大小来做限制的，每个浏览器的实现也是不同的 操作方法：cookie是作为document的属性存在，并没有提供标准的方法来直接操作cookieStorage提供了setItem()和getItem()还有removeItem()方法，操作方便不易出错 其他：cookie在发送http请求时，会将本地的cookie作为http头部信息传递给服务器cookie可以由服务器通过http来设定 cookie由哪些部分组成？一般有以下几部分组成:set cookie: name=value; domain=.mozilla.org; expires=Feb, 13-Mar-2018 11:47:50; path=/; secure1、name名称：一个唯一确定cookie的名称，部分大小写，cookie的名字必须是经过URL编码的，一般可以采用某个前缀在加上当前时间的做法，这样的话名称能够确保是唯一的，也比较方便。2、value值：存储在cookie中的字符串值，必须经过被URL编码3、domain域：对于哪个域是有效的，如果没有设置的话，默认来自设置cookie的那个域，在上诉例子中就是.Mozilla.org4、expires失效时间：表示cookie何时应该被删除的时间戳，这个日期是GMT格式的日期，如果设置是以前的时间，cookie会被立刻删除。上诉cookie的失效时间是Feb,13-Mar-2018 11:47:50。5、path路径：指定域中的那个路径，应该想服务器发送cookie，/ 表示没有限制6、secure安全标志：指定以后，cookie只有在使用SSL连接的时候才可以发送到服务器。","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JS设计模式","slug":"[JS] JS设计模式","date":"2018-10-28T09:46:34.000Z","updated":"2018-10-30T10:28:20.586Z","comments":true,"path":"2018/10/28/[JS] JS设计模式/","link":"","permalink":"http://yoursite.com/2018/10/28/[JS] JS设计模式/","excerpt":"","text":"","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"ES6基础知识—Symbol","slug":"[ES6] ES6基础知识—Symbol","date":"2018-10-26T02:38:24.000Z","updated":"2018-10-29T13:04:42.600Z","comments":true,"path":"2018/10/26/[ES6] ES6基础知识—Symbol/","link":"","permalink":"http://yoursite.com/2018/10/26/[ES6] ES6基础知识—Symbol/","excerpt":"","text":"1、概述2、作为属性名的Symbol3、消除魔术字符串4、属性名的遍历5、Symbol.for/Symbol.keyFor JS 有了第七种数据类型：Symbol，创建一个独一无二的值；它用于对象的属性，设计初衷是为了避免对象属性冲突的问题。要获取对象symbol类型的属性，要用Object.getOwnPropertySymbols()；还提供了Symbol.for()和Symbol.keyFor()方法用于搜索对应的symbol值。 1、概述1、原始数据类型Symbol：防止属性名的冲突2、它是 JS 语言的第七种数据类型，前六种是：undefined、null、Boolean、String、Number、Object。3、Symbol 值不是对象，不能添加属性，基本上，它是一种类似于字符串的数据类型。4、Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。5、Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。6、Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。7、Symbol 值不能与其他类型的值进行运算，会报错8、Symbol 值可以显式转为字符串，Symbol 值也可以转为布尔值，但是不能转为数值。123456789101112131415161718192021222324252627282930313233343536let s = Symbol();let s1 = Symbol('foo');let s2 = Symbol('bar');s; // Symbol()typeof s // \"symbol\"s1; // Symbol(foo)s2; // Symbol(bar)s1.toString() // \"Symbol(foo)\"s2.toString() // \"Symbol(bar)\"// 5、Symbol 的参数是一个对象const obj = &#123; toString() &#123; return 'abc'; &#125;&#125;;const sym = Symbol(obj);sym // Symbol(abc)// 7、Symbol 值不能与其他类型的值进行运算，会报错let sym = Symbol('My symbol');\"your symbol is \" + sym // TypeError: can't convert symbol to string`your symbol is $&#123;sym&#125;` // TypeError: can't convert symbol to string// Symbol 值可以显式转为字符串、布尔值，不能转为数值let sym = Symbol('My symbol');String(sym) // 'Symbol(My symbol)'sym.toString() // 'Symbol(My symbol)'let sym = Symbol();Boolean(sym) // true!sym // falseif (sym) &#123;&#125;Number(sym) // TypeErrorsym + 2 // TypeError 2、作为属性名的Symbol1、由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。2、Symbol 值作为对象属性名时，不能用点运算符。3、在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。如果不放在方括号中，该属性的键名就是字符串，而不是所代表的那个 Symbol 值。4、Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。 123456789101112131415161718192021222324let mySymbol = Symbol();// 第一种写法let a = &#123;&#125;;a[mySymbol] = 'Hello!';// 第二种写法let a = &#123; [mySymbol]: 'Hello'&#125;;// 第三种写法let a = &#123;&#125;;Object.defineProperty(a, mySymbol, &#123; value: 'Hello!' &#125;);// 以上写法都得到同样结果a[mySymbol] // \"Hello!\"// 3、在对象的内部使用 Symbol 值定义属性let s = Symbol();let obj = &#123; [s]: function (arg) &#123; ... &#125;&#125;;// 等价于let obj = &#123; [s](arg) &#123; ... &#125;&#125;;obj[s](123); 3、消除魔术字符串魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。12345678910111213141516171819const shapeType = &#123; triangle: 'Triangle'&#125;;// 等价于 triangle 的值不影响const shapeType = &#123; triangle: Symbol()&#125;;function getArea(shape, options) &#123; let area = 0; switch (shape) &#123; case shapeType.triangle: area = .5 * options.width * options.height; break; &#125; return area;&#125;getArea(shapeType.triangle, &#123; width: 100, height: 100 &#125;); 4、属性名的遍历Symbol 作为属性名，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。1、Object.getOwnPropertySymbols方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。2、Reflect.ownKeys方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。3、以 Symbol 值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。123456789101112131415161718192021222324252627282930313233343536const obj = &#123;&#125;;let a = Symbol('a');let b = Symbol('b');obj[a] = 'Hello';obj[b] = 'World';Object.getOwnPropertySymbols(obj); // [Symbol(a), Symbol(b)]// `Reflect.ownKeys`方法let obj = &#123; [Symbol('my_key')]: 1, enum: 2, nonEnum: 3&#125;;Reflect.ownKeys(obj) // [\"enum\", \"nonEnum\", Symbol(my_key)]// 以 Symbol 值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性let size = Symbol('size');class Collection &#123; constructor() &#123; this[size] = 0; &#125; add(item) &#123; this[this[size]] = item; this[size]++; &#125; static sizeOf(instance) &#123; return instance[size]; &#125;&#125;let x = new Collection();Collection.sizeOf(x) // 0x.add('foo');Collection.sizeOf(x) // 1Object.keys(x) // ['0']Object.getOwnPropertyNames(x) // ['0']Object.getOwnPropertySymbols(x) // [Symbol(size)] 5、Symbol.for/Symbol.keyFor1、Symbol.for方法重新使用同一个 Symbol 值。Symbol.for()与Symbol()这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。2、Symbol()写法没有登记机制，所以每次调用都会返回一个不同的值。3、Symbol.for为 Symbol 值登记的名字，是全局环境的，可以在不同的 iframe 或 service worker 中取到同一个值。4、Symbol.keyFor方法返回一个已登记的 Symbol 类型值的key。1234567891011121314Symbol.for(\"bar\") === Symbol.for(\"bar\") // trueSymbol(\"bar\") === Symbol(\"bar\") // false// 3、`Symbol.for`为 Symbol 值登记的名字，是全局环境的iframe = document.createElement('iframe');iframe.src = String(window.location);document.body.appendChild(iframe);iframe.contentWindow.Symbol.for('foo') === Symbol.for('foo') // true// 4、`Symbol.keyFor`let s1 = Symbol.for(\"foo\");Symbol.keyFor(s1) // \"foo\"let s2 = Symbol(\"foo\");Symbol.keyFor(s2) // undefined 变量s2属于未登记的 Symbol 值","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6基础知识—Set和Map数据结构","slug":"[ES6] ES6基础知识—Set和Map数据结构","date":"2018-10-26T02:23:14.000Z","updated":"2018-10-29T13:04:42.599Z","comments":true,"path":"2018/10/26/[ES6] ES6基础知识—Set和Map数据结构/","link":"","permalink":"http://yoursite.com/2018/10/26/[ES6] ES6基础知识—Set和Map数据结构/","excerpt":"","text":"1、Set2、Set实例的属性和方法 1、Set1、Set类似于数组，但是成员的值都是唯一的，没有重复的值。2、Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，类似于精确相等运算符（===），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。3、在 Set 内部，两个NaN是相等。4、由于两个空对象不相等，所以Set 内部视为两个值。1234567891011// 例一const set = new Set([1, 2, 3, 4, 4]);[...set] // [1, 2, 3, 4]// 例二const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);items.size // 5// 例三const set = new Set(document.querySelectorAll('div'));set.size // 56 2、Set实例的属性和方法1、属性Set.prototype.constructor：构造函数，默认就是Set函数。Set.prototype.size：返回Set实例的成员总数。2、方法Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）Array.from方法可以将 Set 结构转为数组。 操作方法（用于操作数据）add(value)：添加某个值，返回 Set 结构本身。delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。has(value)：返回一个布尔值，表示该值是否为Set的成员。clear()：清除所有成员，没有返回值。 遍历方法（用于遍历成员）keys()：返回键名的遍历器values()：返回键值的遍历器entries()：返回键值对的遍历器forEach()：使用回调函数遍历每个成员 3、Set的遍历顺序就是插入顺序4、keys方法、values方法、entries方法返回的都是遍历器对象。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。5、Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。这意味着，可以省略values方法，直接用for…of循环遍历 Set。6、数组的map和filter方法也可以间接用于 Set。7、使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。123456789101112131415161718192021// 去除数组重复成员function dedupe(array) &#123; return Array.from(new Set(array));&#125;dedupe([1, 1, 2, 3]) // [1, 2, 3][...new Set([3, 5, 2, 2, 5, 5])]; // [3, 5, 2]// 6、数组的`map`和`filter`方法也可以间接用于 Set。new Set([...new Set([1, 2, 3])].map(x =&gt; x * 2)); // 返回Set结构：&#123;2, 4, 6&#125;new Set([...new Set([1, 2, 3, 4, 5])].filter(x =&gt; (x % 2) == 0)); // 返回Set结构：&#123;2, 4&#125;// 7、使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);// 并集let union = new Set([...a, ...b]); // Set &#123;1, 2, 3, 4&#125;// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x))); // set &#123;2, 3&#125;// 差集let difference = new Set([...a].filter(x =&gt; !b.has(x))); // Set &#123;1&#125;","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6基础知识—class类","slug":"[ES6] ES6基础知识—class类","date":"2018-10-25T14:01:41.000Z","updated":"2018-10-29T13:04:42.600Z","comments":true,"path":"2018/10/25/[ES6] ES6基础知识—class类/","link":"","permalink":"http://yoursite.com/2018/10/25/[ES6] ES6基础知识—class类/","excerpt":"","text":"1、简介1、constructor是构造方法，this代表实例对象2、方法之间不需要逗号分隔3、类的数据类型就是函数，类本身就指向构造函数4、类的所有方法都定义在类的prototype属性上5、实例的constructor方法 === 类原型的constructor方法6、类的方法定义在prototype对象上，所以类的新方法可添加在prototype对象上。Object.assign方法可以很方便地一次向类添加多个方法。7、prototype对象的constructor属性，直接指向“类”的本身，这与 ES5 的行为是一致的。8、类的内部所有定义的方法，都是不可枚举的，这与 ES5 的行为是不一致的。9、类的属性名，可以采用表达式。10、类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式11、constructor方法是类的默认方法，如果没有显式定义，一个空的constructor方法会被默认添加。12、constructor 方法默认返回实例对象（即this），完全可以指定返回另外一个对象13、类不存在变量提升（hoist），这一点与 ES5 完全不同，原因与继承有关14、name属性总是返回紧跟在class关键字后面的类名。 12345678910111213141516171819202122232425262728293031323334353637383940414243// 4、类的所有方法都定义在类的prototype属性上class Point &#123; constructor() &#123;&#125; toString() &#123;&#125; toValue() &#123;&#125;&#125;// 等同于Point.prototype = &#123; constructor() &#123;&#125;, toString() &#123;&#125;, toValue() &#123;&#125;,&#125;;Point.prototype.constructor === Point // true// 5、实例的constructor方法 === 类原型的constructor方法class B &#123;&#125;let b = new B();b.constructor === B.prototype.constructor // true// 8、类的内部所有定义的方法，都是不可枚举的class Point &#123; constructor(x, y) &#123; &#125; toString() &#123;&#125;&#125;Object.keys(Point.prototype) // []Object.getOwnPropertyNames(Point.prototype) // [\"constructor\",\"toString\"]// toString方法是Point类内部定义的方法，它是不可枚举的。这一点与 ES5 的行为不一致。var Point = function (x, y) &#123;&#125;;Point.prototype.toString = function() &#123;&#125;;Object.keys(Point.prototype); // [\"toString\"]Object.getOwnPropertyNames(Point.prototype); // [\"constructor\",\"toString\"]// 9、类的属性名，可以采用表达式。let methodName = 'getArea';class Square &#123; constructor(length) &#123;&#125; [methodName]() &#123;&#125;&#125;// 14、name属性总是返回紧跟在class关键字后面的类名。class Point &#123;&#125;Point.name // \"Point\" 2、类的实例对象1、实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）；2、类的所有实例共享一个原型对象，与 ES5 一样。3、可以通过实例的__proto__属性为“类”添加方法(必须谨慎，不推荐使用)。1234567891011121314151617181920212223242526// 定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125;var point = new Point(2, 3);point.toString() // (2, 3)point.hasOwnProperty('x') // truepoint.hasOwnProperty('y') // truepoint.hasOwnProperty('toString') // falsepoint.__proto__.hasOwnProperty('toString') // truevar p1 = new Point(2,3);var p2 = new Point(3,2);p1.__proto__ === p2.__proto__; // truep1.__proto__.printName = function () &#123; return 'Oops' &#125;;p1.printName() // \"Oops\"p2.printName() // \"Oops\"var p3 = new Point(4,2);p3.printName() // \"Oops\" 3、私有方法和私有属性1、在方法前加下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。2、将私有方法移出模块。3、利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。4、在属性名之前使用#表示.5、私有属性也可以设置 getter 和 setter 方法6、私有属性不限于从this引用，类的实例也可以引用私有属性7、直接从实例上引用私有属性是不可以的，只能在类的定义中引用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Widget &#123; // 公有方法 foo (baz) &#123; this._bar(baz); &#125; // 私有方法 _bar (baz) &#123; return this.snaf = baz; &#125; // 2、将私有方法移出模块； foo1 (baz) &#123; bar.call(this, baz); &#125;&#125;function bar(baz) &#123; return this.snaf = baz;&#125;// 3、利用`Symbol`值的唯一性const bar = Symbol('bar');const snaf = Symbol('snaf');export default class myClass&#123; // 公有方法 foo(baz) &#123; this[bar](baz); &#125; // 私有方法 [bar](baz) &#123; return this[snaf] = baz; &#125;&#125;;// bar和snaf都是Symbol值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果// 5、私有属性也可以设置 getter 和 setter 方法class Counter &#123; #xValue = 0; get #x() &#123; return #xValue; &#125; set #x(value) &#123; this.#xValue = value; &#125; constructor() &#123; super(); // ... &#125;&#125;// 6、私有属性不限于从this引用，类的实例也可以引用私有属性class Foo &#123; #privateValue = 42; static getPrivateValue(foo) &#123; return foo.#privateValue; &#125;&#125;Foo.getPrivateValue(new Foo()); // 42 4、this 的指向1、类的方法内部如果含有this，它默认指向类的实例。但不能单独使用该方法，很可能报错。2、解决办法：在构造方法中绑定this。3、解决办法：使用箭头函数。4、解决办法：使用Proxy，获取方法的时候，自动绑定this。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Logger &#123; printName(name = 'there') &#123; this.print(`Hello $&#123;name&#125;`); &#125; print(text) &#123; console.log(text); &#125;&#125;const logger = new Logger();const &#123; printName &#125; = logger;printName(); // TypeError: Cannot read property 'print' of undefinedlogger.printName(); // Hello there// 2、在构造方法中绑定thisclass Logger &#123; constructor() &#123; this.printName = this.printName.bind(this); &#125;&#125;// 3、使用箭头函数class Logger &#123; constructor() &#123; this.printName = (name = 'there') =&gt; &#123; this.print(`Hello $&#123;name&#125;`); &#125;; &#125;&#125;// 4、使用Proxyfunction selfish (target) &#123; const cache = new WeakMap(); const handler = &#123; get (target, key) &#123; const value = Reflect.get(target, key); if (typeof value !== 'function') &#123; return value; &#125; if (!cache.has(value)) &#123; cache.set(value, value.bind(target)); &#125; return cache.get(value); &#125; &#125;; const proxy = new Proxy(target, handler); return proxy;&#125;const logger = selfish(new Logger()); 5、Class 的取值函数（getter）和存值函数（setter）在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。1234567891011121314class MyClass &#123; constructor() &#123; // ... &#125; get prop() &#123; return 'getter'; &#125; set prop(value) &#123; console.log('setter: '+value); &#125;&#125;let inst = new MyClass();inst.prop = 123; // setter: 123inst.prop; // 'getter'","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"关于前端异常的捕获","slug":"[JS] 关于前端异常的捕获","date":"2018-10-25T09:47:42.000Z","updated":"2018-10-29T13:04:42.604Z","comments":true,"path":"2018/10/25/[JS] 关于前端异常的捕获/","link":"","permalink":"http://yoursite.com/2018/10/25/[JS] 关于前端异常的捕获/","excerpt":"","text":"开发过程中，有不少bug能够逃过各种test、QA、review，最终出现在线上，对于线上bug，如果没有足够的log分析，那会大大增加定位时间。所以不论前后端开发，日志系统都是必不可少的一个环节。前端日志系统不像后端有比较成熟统一的解决方案，对于前端异常日志的处理通常采用前端埋点或其它异常捕获方式收集错误日志，然后提交给服务器持久化。 收集日志的方法js的异常机制并不如其它编译型语言严谨，比如java中对可检查异常需要强制捕获处理，而js代码可能就会在运行时才发现有个异常直接导致线程终止。平时收集日志的手段，可以归类为两个方面，一个是逻辑中的错误判断，为主动判断；一个是利用语言给我们提供的捷径，暴力式获取错误信息，如 try..catch 和 window.onerror。所以在js项目中，更需要对异常捕获机制有统一约定，一般来说基本方法有几种： 1.直接捕获对于很明确的某些达到约定异常条件的（接口返回状态不对，客户端认证异常等），直接捕获提交服务端，在可预测范围内反馈异常并记录，比如：12345678asyncRequest((data) =&gt; &#123; // 接口返回的数据不在约定范围内，直接捕获提交 if (data !== 'someValue') &#123; reportToServer(&#123; // error message &#125;); &#125;&#125;) 2.主动判断我们在一些运算之后，得到一个期望的结果，然而结果不是我们想要的，这种属于逻辑错误/状态错误的反馈，在接口 status 判断中用的比较多。1234567891011// test.jsfunction calc()&#123; // code... return val;&#125;if(calc() !== \"someVal\")&#123; Reporter.send(&#123; position: \"test.js::&lt;Function&gt;calc\" msg: \"calc error\" &#125;);&#125; 3.try…catch 捕获java中如果某段代码可能抛出checked Exception，那么就需要强制在外层加上try…catch，类似于这样的处理机制，js中，在有可能抛出异常的地方，使用try…catch进行异常捕获处理，比如，对于一个有可能为undefined的数组参数arr，常规处理和try..catch方式对比：123456789101112// normal// 会报TypeError: Cannot read property 'length' of undefined错误，并且线程终止doSomething(a.length);doOtherthings();// try...catchtry &#123; doSomething(a.length);&#125; catch (e) &#123; reportToServer(e); console.log('HaHa, I catch the error');&#125;doOtherthings(); 4.window.onerror/window.addEventListener(‘error’)捕获全局错误：12345window.onerror = function() &#123; var errInfo = format(arguments); Reporter.send(errInfo); return true;&#125;; 在上面的函数中返回 return true，错误便不会暴露到控制台中。下面是它的参数信息： 12345678910/** * @param &#123;String&#125; errorMessage 错误信息 * @param &#123;String&#125; scriptURI 出错的文件 * @param &#123;Long&#125; lineNumber 出错代码的行号 * @param &#123;Long&#125; columnNumber 出错代码的列号 * @param &#123;Object&#125; errorObj 错误的详细信息，Anything */window.onerror = function(errorMessage, scriptURI, lineNumber,columnNumber,errorObj) &#123; // code..&#125; window.addEventListener(&#39;error)监听error事件时，只有一个ErrorEvent事件参数，继承自Event，包含以下属性：ErrorEvent.message：错误信息ErrorEvent.filename：出错文件位置ErrorEvent.lineno：出错位置行号ErrorEvent.colno：出错位置列号ErrorEvent.error：错误详细信息window.onerror 算是一种特别暴力的容错手段，try..catch 也是如此，他们底层的实现就是利用 C/C++ 中的 goto 语句实现，一旦发现错误，不管目前的堆栈有多深，不管代码运行到了何处，直接跑到顶层或者 try..catch 捕获的那一层，这种一脚踢开错误的处理方式并不是很好。 收集日志存在的问题收集日志的目的是为了及时发现问题，最好日志能够告诉我们，错误在哪里，更优秀的做法是，不仅告诉错误在哪里，还告诉我们，如何处理这个错误。终极目标是，发现错误，自动容错，这一步是最难的。 1.无具体报错信息，Script error.具体原因 可看这里，修改方式为：1、在script标签中加入crossorigin属性&lt;script crossorigin=&quot;anonymous&quot; src=&quot;your.crossorigin.script&quot;&gt;&lt;/script&gt;2、响应头增加Access-Control-Allow-OriginAccess-Control-Allow-Origin: * 2.上报方式常使用的方式有两种： 1、ajax请求上报2、利用img标签的src属性上报(考虑解析性能和多站点服务，更常用的上报方式) 需要注意的是，尽量避免简单直接的捕获–&gt; 上报这样的流程，可能造成日志量过大、阻塞用户操作等问题。所以一些错误合并、延迟上报、抽样采集还是有必要做的。 压缩混淆的线上代码对于线上经压缩混淆后的代码，即使拿到错误行列信息也很难去代码中定位问题，看到的解决方案有： 生成不同文件配合sourceMap 后台实现功能：上传源码，选择压缩平台产生对应sourceMap，再通过转换将压缩的行列信息对应到源码的行列信息这部分目前缺少实践经验，实践后再补充实现方案。","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"macrotasks&microtasks执行顺序总结","slug":"[JS] macrotasks&microtasks执行顺序总结","date":"2018-10-23T13:15:43.000Z","updated":"2018-10-30T15:49:20.349Z","comments":true,"path":"2018/10/23/[JS] macrotasks&microtasks执行顺序总结/","link":"","permalink":"http://yoursite.com/2018/10/23/[JS] macrotasks&microtasks执行顺序总结/","excerpt":"","text":"macrotasks：setTimeout，setInterval， setImmediate，requestAnimationFrame, I/O，UI渲染microtasks:Promise， process.nextTick， Object.observe， MutationObserver再简单点可以总结为： 在 macrotask 队列中执行最早的那个 task ，然后移出 再执行 microtask 队列中所有可用的任务，然后移出 下一个循环，执行下一个 macrotask 中的任务 (再跳到第2步) 任务队列的总结1、一个事件循环有一个或者多个任务队列；2、每个事件循环都有一个microtask队列；3、macrotask队列就是我们常说的任务队列，microtask队列不是任务队列；4、一个任务可以被放入到macrotask队列，也可以放入microtask队列；5、当一个任务被放入microtask或者macrotask队列后，准备工作就已经结束，这时候可以开始执行任务了。 microtasks 的作用是用来调度应在当前执行的脚本执行结束后立即执行的任务。例如响应事件、或者异步操作，以避免付出额外的一个task的费用。microtask会在两种情况下执行：任务队列(macrotask = task queue)回调后执行，前提条件是当前没有其他执行中的代码。每个task末尾执行。另外在处理microtask期间，如果有新添加的microtasks，也会被添加到队列的末尾并执行。 也就是说执行顺序是：开始 -&gt; 取task queue第一个task执行 -&gt; 取microtask全部任务依次执行 -&gt; 取task queue下一个任务执行 -&gt; 再次取出microtask全部任务执行 -&gt; … 这样循环往复Promise一旦状态置为完成态，便为其回调(.then内的函数)安排一个microtask。Promise是一个立即执行函数，但是其是否成功（或失败：reject）的回调函数resolve却是一个异步执行的回调。当执行到resolve()时，这个任务会被放入到回调队列中，等待调用栈有空闲时事件循环再来取走它。 HTML5中规定setTimeout的最小时间延迟是4ms，也就是说理想环境下异步回调最快也是4ms才能触发。 123456789101112131415161718192021setTimeout(function()&#123; console.log(1)&#125;,0);new Promise(function(resolve)&#123; console.log(2) for( var i=100000 ; i&gt;0 ; i-- )&#123; i==1 &amp;&amp; resolve() &#125; console.log(3)&#125;).then(function()&#123; console.log(4)&#125;);console.log(5);// 2 3 5 4 1// 1. 当运行到setTimeout时，会把setTimeout的回调函数console.log(1)放到任务队列里去，然后继续向下执行。// 2. 接下来会遇到一个Promise。首先执行打印console.log(2)，然后执行for循环，即时for循环要累加到10万，也是在执行栈里面，等待for循环执行完毕以后，将Promise的状态从fulfilled切换到resolve，随后把要执行的回调函数，也就是then里面的console.log(4)推到microtask里面去。接下来马上执行马上console.log(3)。// 3. 然后出Promise，还剩一个同步的console.log(5)，直接打印。这样第一轮下来，已经依次打印了2，3，5。// 4. 现在第一轮任务队列已经执行完毕，没有正在执行的代码。符合上面讲的microtask执行条件，因此会将microtask中的任务优先执行，因此执行console.log(4);// 5. 最后还剩macrotask里的setTimeout放入的函数console.log(1)最后执行。 当一个程序有：setTimeout， setInterval，setImmediate， I/O， UI渲染，Promise，process.nextTick， Object.observe， MutationObserver的时候：1. 先执行 macrotasks：I/O –&gt; UI渲染2. 再执行 microtasks ：process.nextTick –&gt; Promise –&gt; MutationObserver –&gt; Object.observe3. 再把setTimeout setInterval setImmediate 塞入一个新的macrotasks，依次：setImmediate –&gt; setTimeout ，setInterval综上，nextTick的目的就是产生一个回调函数加入task或者microtask中，当前栈执行完以后（可能中间还有别的排在前面的函数）调用该回调函数，起到了异步触发（即下一个tick时触发）的目的。 12345678910111213141516171819setImmediate(function()&#123; console.log(1);&#125;,0);setTimeout(function()&#123; console.log(2);&#125;,0);new Promise(function(resolve)&#123; console.log(3); resolve(); console.log(4);&#125;).then(function()&#123; console.log(5);&#125;);console.log(6);process.nextTick(function()&#123; console.log(7);&#125;);console.log(8);// 结果是：3 4 6 8 7 5 1 2 还有acync和await","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"webpack流程","slug":"[构建] webpack流程","date":"2018-10-20T14:49:14.000Z","updated":"2018-10-20T15:40:37.077Z","comments":true,"path":"2018/10/20/[构建] webpack流程/","link":"","permalink":"http://yoursite.com/2018/10/20/[构建] webpack流程/","excerpt":"","text":"流程概括Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程： 1、初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；2、开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；3、确定入口：根据配置中的 entry 找出所有的入口文件；4、编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；5、完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；6、输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；7、输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。 在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。 流程细节Webpack 的构建流程可以分为以下三大阶段：1、初始化：启动构建，读取与合并配置参数，加载 Plugin，实例化Compiler。2、编译：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理。3、输出：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统。 在每个大阶段中又会发生很多事件，Webpack 会把这些事件广播出来供给 Plugin 使用，下面来一一介绍。 初始化阶段 事件名 解释 初始化参数 从配置文件和 Shell 语句中读取与合并参数，得出最终的参数。 这个过程中还会执行配置文件中的插件实例化语句 new Plugin()。 实例化 Compiler 用上一步得到的参数初始化 Compiler 实例，Compiler 负责文件监听和启动编译。Compiler 实例中包含了完整的 Webpack 配置，全局只有一个 Compiler 实例。 加载插件 依次调用插件的 apply 方法，让插件可以监听后续的所有事件节点。同时给插件传入 compiler 实例的引用，以方便插件通过 compiler 调用 Webpack 提供的 API。 environment 开始应用 Node.js 风格的文件系统到 compiler 对象，以方便后续的文件寻找和读取。 entry-option 读取配置的 Entrys，为每个 Entry 实例化一个对应的 EntryPlugin，为后面该 Entry 的递归解析工作做准备。 after-plugins 调用完所有内置的和配置的插件的 apply 方法。 after-resolvers 根据配置初始化完 resolver，resolver负责在文件系统中寻找指定路径的文件。 编译阶段 事件名 解释 run 启动一次新的编译。 watch-run 和 run 类似，区别在于它是在监听模式下启动的编译，在这个事件中可以获取到是哪些文件发生了变化导致重新启动一次新的编译。 compile 该事件是为了告诉插件一次新的编译将要启动，同时会给插件带上 compiler 对象。 compilation 当 Webpack 以开发模式运行时，每当检测到文件变化，一次新的 Compilation 将被创建。一个 Compilation 对象包含了当前的模块资源、编译生成资源、变化的文件等。Compilation 对象也提供了很多事件回调供插件做扩展。 make 一个新的 Compilation 创建完毕，即将从 Entry 开始读取文件，根据文件类型和配置的 Loader 对文件进行编译，编译完后再找出该文件依赖的文件，递归的编译和解析。 after-compile 一次 Compilation 执行完成。 invalid 当遇到文件不存在、文件编译错误等异常时会触发该事件，该事件不会导致 Webpack 退出。 在编译阶段中，最重要的要数 compilation 事件了，因为在 compilation 阶段调用了 Loader 完成了每个模块的转换操作，在 compilation 阶段又包括很多小的事件，它们分别是： 事件名 解释 build-module 使用对应的 Loader 去转换一个模块。 normal-module-loader 在用 Loader 对一个模块转换完后，使用 acorn 解析转换后的内容，输出对应的抽象语法树（AST），以方便 Webpack 后面对代码的分析。 program 从配置的入口模块开始，分析其 AST，当遇到 require 等导入其它模块语句时，便将其加入到依赖的模块列表，同时对新找出的依赖模块递归分析，最终搞清所有模块的依赖关系。 seal 所有模块及其依赖的模块都通过 Loader 转换完成后，根据依赖关系开始生成 Chunk。 输出阶段 事件名 解释 should-emit 所有需要输出的文件已经生成好，询问插件哪些文件需要输出，哪些不需要。 emit 确定好要输出哪些文件后，执行文件输出，可以在这里获取和修改输出内容。 after-emit 文件输出完毕。 done 成功完成一次完成的编译和输出流程。 failed 如果在编译和输出流程中遇到异常导致 Webpack 退出时，就会直接跳转到本步骤，插件可以在本事件中获取到具体的错误原因。 输出文件分析bundle.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364( // webpackBootstrap 启动函数 // modules 即为存放所有模块的数组，数组中的每一个元素都是一个函数 function (modules) &#123; // 安装过的模块都存放在这里面 // 作用是把已经加载过的模块缓存在内存中，提升性能 var installedModules = &#123;&#125;; // 去数组中加载一个模块，moduleId 为要加载模块在数组中的 index // 作用和 Node.js 中 require 语句相似 function __webpack_require__(moduleId) &#123; // 如果需要加载的模块已经被加载过，就直接从内存缓存中返回 if (installedModules[moduleId]) &#123; return installedModules[moduleId].exports; &#125; // 如果缓存中不存在需要加载的模块，就新建一个模块，并把它存在缓存中 var module = installedModules[moduleId] = &#123; // 模块在数组中的 index i: moduleId, // 该模块是否已经加载完毕 l: false, // 该模块的导出值 exports: &#123;&#125; &#125;; // 从 modules 中获取 index 为 moduleId 的模块对应的函数 // 再调用这个函数，同时把函数需要的参数传入 modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); // 把这个模块标记为已加载 module.l = true; // 返回这个模块的导出值 return module.exports; &#125; // Webpack 配置中的 publicPath，用于加载被分割出去的异步代码 __webpack_require__.p = \"\"; // 使用 __webpack_require__ 去加载 index 为 0 的模块，并且返回该模块导出的内容 // index 为 0 的模块就是 main.js 对应的文件，也就是执行入口模块 // __webpack_require__.s 的含义是启动模块对应的 index return __webpack_require__(__webpack_require__.s = 0); &#125;)( // 所有的模块都存放在了一个数组里，根据每个模块在数组的 index 来区分和定位模块 [ /* 0 */ (function (module, exports, __webpack_require__) &#123; // 通过 __webpack_require__ 规范导入 show 函数，show.js 对应的模块 index 为 1 const show = __webpack_require__(1); // 执行 show 函数 show('Webpack'); &#125;), /* 1 */ (function (module, exports) &#123; function show(content) &#123; window.document.getElementById('app').innerText = 'Hello,' + content; &#125; // 通过 CommonJS 规范导出 show 函数 module.exports = show; &#125;) ]); 以上看上去复杂的代码其实是一个立即执行函数，可以简写为如下：12345678910(function(modules) &#123; // 模拟 require 语句 function __webpack_require__() &#123; &#125; // 执行存放所有模块数组中的第0个模块 __webpack_require__(0);&#125;)([/*存放所有模块的数组*/]) bundle.js 能直接运行在浏览器中的原因在于输出的文件中通过 __webpack_require__ 函数定义了一个可以在浏览器中执行的加载函数来模拟 Node.js 中的 require 语句。 原来一个个独立的模块文件被合并到了一个单独的 bundle.js 的原因在于浏览器不能像 Node.js 那样快速地去本地加载一个个模块文件，而必须通过网络请求去加载还未得到的文件。如果模块数量很多，加载时间会很长，因此把所有模块都存放在了数组中，执行一次网络加载。 如果仔细分析 __webpack_require__ 函数的实现，还有发现 Webpack 做了缓存优化： 执行加载过的模块不会再执行第二次，执行结果会缓存在内存中，当某个模块第二次被访问时会直接去内存中读取被缓存的返回值。 分割代码时的输出把源码中的 main.js 修改为如下：12345// 异步加载 show.jsimport('./show').then((show) =&gt; &#123; // 执行 show 函数 show('Webpack');&#125;); 重新构建后会输出两个文件，分别是执行入口文件 bundle.js 和 异步加载文件 0.bundle.js。 其中 0.bundle.js 内容如下：12345678910111213141516// 加载在本文件(0.bundle.js)中包含的模块webpackJsonp( // 在其它文件中存放着的模块的 ID [0], // 本文件所包含的模块 [ // show.js 所对应的模块 (function (module, exports) &#123; function show(content) &#123; window.document.getElementById('app').innerText = 'Hello,' + content; &#125; module.exports = show; &#125;) ]); bundle.js 内容如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122(function (modules) &#123; /*** * webpackJsonp 用于从异步加载的文件中安装模块。 * 把 webpackJsonp 挂载到全局是为了方便在其它文件中调用。 * * @param chunkIds 异步加载的文件中存放的需要安装的模块对应的 Chunk ID * @param moreModules 异步加载的文件中存放的需要安装的模块列表 * @param executeModules 在异步加载的文件中存放的需要安装的模块都安装成功后，需要执行的模块对应的 index */ window[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) &#123; // 把 moreModules 添加到 modules 对象中 // 把所有 chunkIds 对应的模块都标记成已经加载成功 var moduleId, chunkId, i = 0, resolves = [], result; for (; i &lt; chunkIds.length; i++) &#123; chunkId = chunkIds[i]; if (installedChunks[chunkId]) &#123; resolves.push(installedChunks[chunkId][0]); &#125; installedChunks[chunkId] = 0; &#125; for (moduleId in moreModules) &#123; if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) &#123; modules[moduleId] = moreModules[moduleId]; &#125; &#125; while (resolves.length) &#123; resolves.shift()(); &#125; &#125;; // 缓存已经安装的模块 var installedModules = &#123;&#125;; // 存储每个 Chunk 的加载状态； // 键为 Chunk 的 ID，值为0代表已经加载成功 var installedChunks = &#123; 1: 0 &#125;; // 模拟 require 语句，和上面介绍的一致 function __webpack_require__(moduleId) &#123; // ... 省略和上面一样的内容 &#125; /** * 用于加载被分割出去的，需要异步加载的 Chunk 对应的文件 * @param chunkId 需要异步加载的 Chunk 对应的 ID * @returns &#123;Promise&#125; */ __webpack_require__.e = function requireEnsure(chunkId) &#123; // 从上面定义的 installedChunks 中获取 chunkId 对应的 Chunk 的加载状态 var installedChunkData = installedChunks[chunkId]; // 如果加载状态为0表示该 Chunk 已经加载成功了，直接返回 resolve Promise if (installedChunkData === 0) &#123; return new Promise(function (resolve) &#123; resolve(); &#125;); &#125; // installedChunkData 不为空且不为0表示该 Chunk 正在网络加载中 if (installedChunkData) &#123; // 返回存放在 installedChunkData 数组中的 Promise 对象 return installedChunkData[2]; &#125; // installedChunkData 为空，表示该 Chunk 还没有加载过，去加载该 Chunk 对应的文件 var promise = new Promise(function (resolve, reject) &#123; installedChunkData = installedChunks[chunkId] = [resolve, reject]; &#125;); installedChunkData[2] = promise; // 通过 DOM 操作，往 HTML head 中插入一个 script 标签去异步加载 Chunk 对应的 JavaScript 文件 var head = document.getElementsByTagName('head')[0]; var script = document.createElement('script'); script.type = 'text/javascript'; script.charset = 'utf-8'; script.async = true; script.timeout = 120000; // 文件的路径为配置的 publicPath、chunkId 拼接而成 script.src = __webpack_require__.p + \"\" + chunkId + \".bundle.js\"; // 设置异步加载的最长超时时间 var timeout = setTimeout(onScriptComplete, 120000); script.onerror = script.onload = onScriptComplete; // 在 script 加载和执行完成时回调 function onScriptComplete() &#123; // 防止内存泄露 script.onerror = script.onload = null; clearTimeout(timeout); // 去检查 chunkId 对应的 Chunk 是否安装成功，安装成功时才会存在于 installedChunks 中 var chunk = installedChunks[chunkId]; if (chunk !== 0) &#123; if (chunk) &#123; chunk[1](new Error('Loading chunk ' + chunkId + ' failed.')); &#125; installedChunks[chunkId] = undefined; &#125; &#125;; head.appendChild(script); return promise; &#125;; // 加载并执行入口模块，和上面介绍的一致 return __webpack_require__(__webpack_require__.s = 0);&#125;)( // 存放所有没有经过异步加载的，随着执行入口文件加载的模块 [ // main.js 对应的模块 (function (module, exports, __webpack_require__) &#123; // 通过 __webpack_require__.e 去异步加载 show.js 对应的 Chunk __webpack_require__.e(0).then(__webpack_require__.bind(null, 1)).then((show) =&gt; &#123; // 执行 show 函数 show('Webpack'); &#125;); &#125;) ]); 这里的 bundle.js 和上面所讲的 bundle.js 非常相似，区别在于：1、多了一个 __webpack_require__.e 用于加载被分割出去的，需要异步加载的 Chunk 对应的文件;2、多了一个 webpackJsonp 函数用于从异步加载的文件中安装模块。 在使用了 CommonsChunkPlugin 去提取公共代码时输出的文件和使用了异步加载时输出的文件是一样的，都会有 webpack_require.e 和 webpackJsonp。 原因在于提取公共代码和异步加载本质上都是代码分割。","categories":[{"name":"构建","slug":"构建","permalink":"http://yoursite.com/categories/构建/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"vue官网阅读","slug":"[Vue] Vue官网","date":"2018-10-19T08:38:36.000Z","updated":"2018-10-29T13:04:42.606Z","comments":true,"path":"2018/10/19/[Vue] Vue官网/","link":"","permalink":"http://yoursite.com/2018/10/19/[Vue] Vue官网/","excerpt":"","text":"一、Vue实例只有当实例被创建时 data 中存在的属性才是响应式的。vm.b = ‘hi’; // 对 b 的改动将不会触发任何视图的更新。1234567891011var data = &#123; a: 1 &#125;;var vm = new Vue(&#123; data: data&#125;);vm.a == data.a // =&gt; true// 设置属性也会影响到原始数据vm.a = 2data.a // =&gt; 2// 反之亦然data.a = 3vm.a // =&gt; 3 Object.freeze()会阻止修改现有的属性，也意味着响应系统无法再追踪变化。 实例提供的属性和方法12345678910111213var data = &#123; a: 1 &#125;var vm = new Vue(&#123; el: '#example', data: data&#125;)vm.$data === data // =&gt; truevm.$el === document.getElementById('example') // =&gt; true// $watch 是一个实例方法vm.$watch('a', function (newValue, oldValue) &#123; // 这个回调将在 `vm.a` 改变后调用&#125;) 二、模板语法 - 修饰符修饰符 (Modifiers) 是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()： … 三、计算属性和侦听器1、计算属性缓存computed vs 方法methods可以将同一函数定义为一个方法methods而不是一个计算属性computed。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的依赖进行缓存的，只在相关依赖发生改变时它们才会重新求值。 2、计算属性computed vs 侦听属性watch计算属性的 setter计算属性默认只有 getter ，不过在需要时也可以提供一个 setter ：12345678910111213141516// ...computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + ' ' + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125;// ... 现在再运行 vm.fullName = &#39;John Doe&#39; 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。 3、侦听器watch当需要在数据变化时执行异步或开销较大的操作时，侦听器最有用的查看官网demo 四、Class与Style绑定1、绑定 HTML Class - 对象语法123456789101112131415161718192021222324252627282930// 方法一&lt;div class=\"static\" v-bind:class=\"&#123; active: isActive, 'text-danger': hasError &#125;\"&gt; &lt;/div&gt;data: &#123; isActive: true, hasError: false&#125;// 方法二&lt;div v-bind:class=\"classObject\"&gt;&lt;/div&gt;data: &#123; classObject: &#123; active: true, 'text-danger': false &#125;&#125;// 方法三data: &#123; isActive: true, error: null&#125;,computed: &#123; classObject: function () &#123; return &#123; active: this.isActive &amp;&amp; !this.error, 'text-danger': this.error &amp;&amp; this.error.type === 'fatal' &#125; &#125;&#125; 2、绑定 HTML Class - 数组语法123456789&lt;div v-bind:class=\"[activeClass, errorClass]\"&gt;&lt;/div&gt;data: &#123; activeClass: 'active', errorClass: 'text-danger'&#125;// 渲染结果为：&lt;div class=\"active text-danger\"&gt;&lt;/div&gt; 3、绑定 HTML Class - 用在组件上当在一个自定义组件上使用 class 属性时，这些类将被添加到该组件的根元素上面。这个元素上已经存在的类不会被覆盖。12345678910// 自定义组件Vue.component('my-component', &#123; template: '&lt;p class=\"foo bar\"&gt;Hi&lt;/p&gt;'&#125;);// 组件的引用&lt;my-component class=\"baz boo\"&gt;&lt;/my-component&gt;// HTML 将被渲染为:&lt;p class=\"foo bar baz boo\"&gt;Hi&lt;/p&gt; 五、条件渲染 - v-if vs v-showv-if 是惰性的：如果在初始渲染时条件为假，则什么也不做，直到条件第一次变为真时，才会开始渲染条件块。v-show 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 六、列表渲染1、v-if/v-show变异方法：会改变被这些方法调用的原始数组。push(), pop(), shift(), unshift(), splice(), sort(), reverse()。非变异方法，例如：filter(), concat() 和 slice() 。这些不会改变原始数组，但总是返回一个新数组。 注意事项：由于 JavaScript 的限制，Vue 不能检测以下变动的数组：1、利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue；2、修改数组的长度时，例如：vm.items.length = newLength；解决第一类问题：1234567// Vue.setVue.set(vm.items, indexOfItem, newValue);// 也可以使用 vm.$set 实例方法，该方法是全局方法 Vue.set 的一个别名：vm.$set(vm.items, indexOfItem, newValue);// Array.prototype.splicevm.items.splice(indexOfItem, 1, newValue);解决第二类问题：1vm.items.splice(newLength)### 2、对象更改检测注意事项由于 JS 的限制，Vue 不能检测对象属性的添加或删除。可以使用 Vue.set(object, key, value) 方法向嵌套对象添加响应式属性。123456789var vm = new Vue(&#123; data: &#123; userProfile: &#123; name: 'Anika' &#125; &#125;&#125;);Vue.set(vm.userProfile, 'age', 27);vm.$set(vm.userProfile, 'age', 27);可能需要为已有对象赋予多个新属性，比如使用 Object.assign() 或 _.extend()。在这种情况下，你应该用两个对象的属性创建一个新的对象。1234vm.userProfile = Object.assign(&#123;&#125;, vm.userProfile, &#123; age: 27, favoriteColor: 'Vue Green'&#125;)### 3、v-for with v-if当它们处于同一节点，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。123&lt;li v-for=\"todo in todos\" v-if=\"!todo.isComplete\"&gt; &#123;&#123; todo &#125;&#125;&lt;/li&gt;### 4、一个组件的 v-foris=”todo-item” 属性。这种做法在使用 DOM 模板时是十分必要的，因为在 &lt;ul&gt; 元素内只有 &lt;li&gt; 元素会被看作有效内容。这样做实现的效果与 &lt;todo-item&gt; 相同，但是可以避开一些潜在的浏览器解析错误。123456789&lt;ul&gt; &lt;li is=\"todo-item\" v-for=\"(todo, index) in todos\" v-bind:key=\"todo.id\" v-bind:title=\"todo.title\" v-on:remove=\"todos.splice(index, 1)\" &gt;&lt;/li&gt;&lt;/ul&gt;## 七、事件处理有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法### 1、事件修饰符.stop、.prevent、.capture、.self、.once、.passive123456789101112131415161718192021222324252627// 阻止单击事件继续传播&lt;a v-on:click.stop=\"doThis\"&gt;&lt;/a&gt;// 提交事件不再重载页面&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt;// 修饰符可以串联&lt;a v-on:click.stop.prevent=\"doThat\"&gt;&lt;/a&gt;// 只有修饰符&lt;form v-on:submit.prevent&gt;&lt;/form&gt;// 添加事件监听器时使用事件捕获模式// 即元素自身触发的事件先在此处理，然后才交由内部元素进行处理&lt;div v-on:click.capture=\"doThis\"&gt;&lt;/div&gt;// 只当在 event.target 是当前元素自身时触发处理函数// 即事件不是从内部元素触发的&lt;div v-on:click.self=\"doThat\"&gt;&lt;/div&gt;// 点击事件将只会触发一次&lt;a v-on:click.once=\"doThis\"&gt;&lt;/a&gt;// 滚动事件的默认行为 (即滚动行为) 将会立即触发// 而不会等待 `onScroll` 完成// 这其中包含 `event.preventDefault()` 的情况&lt;div v-on:scroll.passive=\"onScroll\"&gt;...&lt;/div&gt;使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent只会阻止对元素自身的点击。不要把 .passive 和 .prevent 一起使用，因为 .prevent 将会被忽略，同时浏览器可能会向你展示一个警告。请记住，.passive 会告诉浏览器你不想阻止事件的默认行为。### 2、按键修饰符可以通过全局 config.keyCodes 对象自定义按键修饰符别名123&lt;input @keyup.enter=\"submit\"&gt;// 可以使用 `v-on:keyup.f1`Vue.config.keyCodes.f1 = 112### 3、系统修饰符.exact 修饰符允许你控制由精确的系统修饰符组合触发的事件。12345678// 即使 Alt 或 Shift 被一同按下时也会触发&lt;button @click.ctrl=\"onClick\"&gt;A&lt;/button&gt;// 有且只有 Ctrl 被按下的时候才触发&lt;button @click.ctrl.exact=\"onCtrlClick\"&gt;A&lt;/button&gt;// 没有任何系统修饰符被按下的时候才触发&lt;button @click.exact=\"onClick\"&gt;A&lt;/button&gt;## 八、表单输入绑定可以用 v-model 指令在表单 &lt;input&gt;、&lt;textarea&gt; 及 &lt;select&gt; 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。v-model 会忽略所有表单元素的 value、checked、selected 特性的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JS 在组件的 data 选项中声明初始值。对于需要使用输入法 (如中文、日文、韩文等) 的语言，会发现 v-model 不会在输入法组合文字过程中得到更新。如果你也想处理这个过程，请使用 input 事件。### 1、选择框如果 v-model 表达式的初始值未能匹配任何选项， 元素将被渲染为“未选中”状态。在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 change 事件。因此，更推荐像上面这样提供一个值为空的禁用选项。12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;div id=\"example-5\"&gt; &lt;select v-model=\"selected\"&gt; &lt;option disabled value=\"\"&gt;请选择&lt;/option&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;&lt;/div&gt;new Vue(&#123; el: '...', data: &#123; selected: '' &#125;&#125;);// 用 v-for 渲染的动态选项&lt;select v-model=\"selected\"&gt; &lt;option v-for=\"option in options\" v-bind:value=\"option.value\"&gt; &#123;&#123; option.text &#125;&#125; &lt;/option&gt;&lt;/select&gt;&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;new Vue(&#123; el: '...', data: &#123; selected: 'A', options: [ &#123; text: 'One', value: 'A' &#125;, &#123; text: 'Two', value: 'B' &#125;, &#123; text: 'Three', value: 'C' &#125; ] &#125;&#125;)// 值绑定&lt;select v-model=\"selected\"&gt; // 内联对象字面量 &lt;option v-bind:value=\"&#123; number: 123 &#125;\"&gt;123&lt;/option&gt;&lt;/select&gt;// 当选中时typeof vm.selected // =&gt; 'object'vm.selected.number // =&gt; 123### 2、修饰符.lazy: 在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。你可以添加 lazy 修饰符，从而转变为使用 change 事件进行同步..number: 如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符。如果这个值无法被 parseFloat() 解析，则会返回原始的值。.trim: 如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符。1234567// 在“change”时而非“input”时更新&lt;input v-model.lazy=\"msg\"&gt;// 即使在 type=\"number\" 时，HTML 输入元素的值也总会返回字符串&lt;input v-model.number=\"age\" type=\"number\"&gt;&lt;input v-model.trim=\"msg\"&gt;### 3、解析DOM模版时需要注意有些 HTML 元素，诸如 &lt;ul&gt;、&lt;ol&gt;、&lt;table&gt; 和 &lt;select&gt;，对于哪些元素可以出现在其内部是有严格限制的。而有些元素，诸如 &lt;li&gt;、&lt;tr&gt; 和 &lt;option&gt;，只能出现在其它某些特定的元素内部。123&lt;table&gt; &lt;tr is=\"blog-post-row\"&gt;&lt;/tr&gt;&lt;/table&gt;需要注意的是如果我们从以下来源使用模板的话，这条限制是不存在的：1、字符串 (例如：template: ‘…’)2、单文件组件 (.vue)3、&lt;script type=&quot;text/x-template&quot;&gt;如果使用了 webpack，那么就可以使用 require.context 只全局注册这些非常通用的基础组件。1234567891011121314151617181920212223242526272829303132333435// src/main.jsimport Vue from 'vue'import upperFirst from 'lodash/upperFirst'import camelCase from 'lodash/camelCase'const requireComponent = require.context( // 其组件目录的相对路径 './components', // 是否查询其子目录 false, // 匹配基础组件文件名的正则表达式 /Base[A-Z]\\w+\\.(vue|js)$/)requireComponent.keys().forEach(fileName =&gt; &#123; // 获取组件配置 const componentConfig = requireComponent(fileName) // 获取组件的 PascalCase 命名 const componentName = upperFirst( camelCase( // 剥去文件名开头的 `./` 和结尾的扩展名 fileName.replace(/^\\.\\/(.*)\\.\\w+$/, '$1') ) ) // 全局注册组件 Vue.component( componentName, // 如果这个组件选项是通过 `export default` 导出的， // 那么就会优先使用 `.default`， // 否则回退到使用模块的根。 componentConfig.default || componentConfig )&#125;)全局注册的行为必须在根 Vue 实例 (通过 new Vue) 创建之前发生","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"单页面应用的权限管理","slug":"[Vue] 单页面应用的权限管理","date":"2018-10-19T02:26:43.000Z","updated":"2018-10-29T13:04:42.606Z","comments":true,"path":"2018/10/19/[Vue] 单页面应用的权限管理/","link":"","permalink":"http://yoursite.com/2018/10/19/[Vue] 单页面应用的权限管理/","excerpt":"","text":"Vue 单页面应用的权限管理有两种方法：接口级权限；页面级权限 接口级权限例子：后台好多接口发ajax请求获取数据的时候后端都会需要获取用户是否登录，并在登录的情况反馈到前端，前端跳转到登录页面。这个就可以使用这个拦截器来实现。在请求或响应被 then 或 catch 处理前拦截它们。12345678// 添加响应拦截器axios.interceptors.response.use(response =&gt; &#123; // 对响应数据做点什么 return response;&#125;, error =&gt; &#123; // 对响应错误做点什么 return Promise.reject(error);&#125;); 12345678// 添加请求拦截器axios.interceptors.request.use(config =&gt;&#123; // 在发送请求之前做些什么 return config;&#125;, error =&gt; &#123; // 对请求错误做些什么 return Promise.reject(error);&#125;); 页面级权限页面及权限主要靠vue-router来实现。基本思路是为全局注册一个“前置守卫”钩子函数router.beforeEach。12345const router = new VueRouter(&#123; ... &#125;)router.beforeEach((to, from, next) =&gt; &#123; // 这里检查权限并进行跳转 next()&#125;) 每个守卫方法接收三个参数：1、to:Route 即将要进入的目标2、from: Route 当前导航正要离开的路由3、next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed （确认的）。next(false): 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 from 路由对应的地址。next(&#39;/&#39;)或者 next({ path: &#39;/&#39; }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: ‘home’ 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项。next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"vue数据传递","slug":"[Vue] Vue数据传递","date":"2018-10-18T08:47:41.000Z","updated":"2018-11-01T16:18:59.876Z","comments":true,"path":"2018/10/18/[Vue] Vue数据传递/","link":"","permalink":"http://yoursite.com/2018/10/18/[Vue] Vue数据传递/","excerpt":"","text":"父组件到子组件方法一：Prop方法在父组件调用子组件时通过v-bind(:)绑定动态数据，在子组件，使用Prop方法（单项绑定，防止数据倒流）父：1&lt;edit-dialog :dialogData=\"dialogData\" :rendom=\"new Date().getTime()\"&gt;&lt;/edit-dialog&gt; 子：1234props: &#123; dialogData: Object, rendom: Number&#125; 子组件中通过watch方法来监控数据是否改变，可触发相应的方法。 方法二：provide/injectprovider/inject：在父组件中通过provider来提供变量，在子组件中通过inject来注入变量。不论子组件有多深，只要调用了inject那么就可以注入provider中的数据。而不是局限于只能从当前父组件的prop属性来获取数据，只要在父组件的生命周期内，子组件都可以调用。123456789101112131415161718192021// 父组件export default &#123; name: \"Parent\", provide: &#123; //重要一步，在父组件中注入一个变量 for: \"demo\" &#125;, components:&#123; childOne &#125;&#125;// 子组件export default &#123; name: \"childOne\", inject: ['for'], //子孙组件中使用inject接住变量即可 data() &#123; return &#123; demo: this.for &#125; &#125;,&#125; 子组件到父组件方法一：发送/监听事件在父组件中使用v-on(@)绑定自定义事件接收，在子组件中使用$emit来监控，并传给回掉。父：1&lt;edit-dialog @message=\"recieveMessage\"&gt;&lt;/edit-dialog&gt; 子：this.$emit(‘message’, data) 方法二：$children、$ref或$parent$children: 返回所有子组件的实例，是一个数组。如果能清楚的知道子组件的顺序，也可以使用下标来操作；1234for(let i = 0; i &lt; this.$children.length; i++) &#123; console.log(this.$children[i].children_data); this.$children[i].children_fun();&#125; 1、$ref：给子组件做标记，即可在父组件中调用到子组件的数据和方法首先在子组件做标记： 然后在父组件中，通过this.$refs.one就可以访问该子组件，包括访问子组件的data里面的数据，调用它的函数。2、ref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素;如果用在子组件上，引用就指向组件实例。3、子组件访问根组件$root当前组件树的根 Vue 实例。如果当前实例没有父实例，此实例将会是其自已。4、$parent在子组件中调用父组件的方法或获得其数据。123456789101112131415161718192021222324252627282930313233343536373839// parents.vue&lt;template&gt; &lt;div id='parents'&gt; &lt;p&gt;我是父组件 &lt;button @click=\"click1hanlde\"&gt;获取子组件1的数据与方法&lt;/button&gt; &lt;button @click=\"click2hanlde\"&gt;获取所有子组件的数据和方法&lt;/button&gt;&lt;/p&gt; &lt;children1 ref=\"children1\"&gt;&lt;/children1&gt; &lt;children2 ref=\"children2\"&gt;&lt;/children2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import children1 from './children1.vue' import children2 from './children2.vue' export default &#123; components:&#123; children1, children2 &#125;, data() &#123; return &#123; ParentData:'AAA' &#125;; &#125;, methods:&#123; click1hanlde()&#123; console.log(this.$refs.children1.children_data) this.$refs.children1.children_fun(); &#125;, click2hanlde()&#123; for(let i=0;i&lt;this.$children.length;i++)&#123; console.log(this.$children[i].children_data); this.$children[i].children_fun(); &#125; &#125;, showParentData()&#123; console.log(this.ParentData) &#125; &#125; &#125;;&lt;/script&gt; 非父子组件 eventBus / vuex有时候两个组件也需要通信(非父子关系)。在简单的场景下，可以使用一个空的 Vue 实例作为中央事件总线：12345678910111213// eventBus.jsimport Vue from 'vue'export default new Vue();// 发送事件（发送数据）import bus from '@/bus';bus.$emit('childa-message', this.data); // 方法内执行下面动作// 组件内监听（接收数据组件）import bus from '@/bus';bus.$on('childa-message', function(data) &#123; // 方法内执行下面动作 console.log('I get it');&#125;); 了解整个vue eventBus我们在项目中引入了 vuex ，通常情况下是不需要使用 event bus 的，但是有一种情况下我们需要使用它，那就是在路由钩子函数内部的时，在项目中，我们需要在 beforeEnter 路由钩子里面对外抛出事件，在这个钩子函数中我们无法去到 this 对象。123456789101112beforeEnter: (to, from, next) =&gt; &#123; const userInfo = localStorage.getItem(userFlag); if (isPrivateMode()) &#123; EventBus.$emit('get-localdata-error'); next(false); return; &#125;&#125;);// 在 App.vue 的 mouted 方法中监听这个事件EventBus.$on('get-localdata-error', () =&gt; &#123; this.$alert('请勿使用无痕模式浏览');&#125;);","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"webpack 到应用","slug":"[构建] webpack到应用","date":"2018-10-17T16:39:31.000Z","updated":"2018-10-18T17:01:39.616Z","comments":true,"path":"2018/10/18/[构建] webpack到应用/","link":"","permalink":"http://yoursite.com/2018/10/18/[构建] webpack到应用/","excerpt":"","text":"ES6项目TypeScript项目Flow 检查器SCSSPostCSSVue框架 ES6项目可以使用.bablerc对ES6、ES7进行配置123456789101112131415161718module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.js$/, use: ['babel-loader'], &#125;, ] &#125;, // 输出 source-map 方便直接调试 ES6 源码 devtool: 'source-map'&#125;;// 安装依赖// Webpack 接入 Babel 必须依赖的模块npm i -D babel-core babel-loader // 根据你的需求选择不同的 Plugins 或 Presetsnpm i -D babel-preset-env TypeScript项目Ts 是 Js 的一个超集，主要提供了类型检查系统和对 ES6 语法的支持，但不支持新的 API。方法一：建立配置编译选项的tsconfig.json文件方法二：集成Webpack需要解决以下2个问题：1、通过 Loader 把 Ts 转换成 Js。 推荐 awesome-typescript-loader。 安装：npm i -D typescript awesome-typescript-loader2、Webpack 在寻找模块对应的文件时需要尝试 ts 后缀，解决办法：修改默认的 resolve.extensions 配置项12345678910111213141516171819202122232425262728293031323334// tsconfig.json&#123; \"compilerOptions\": &#123; \"module\": \"commonjs\", // 编译出的代码采用的模块规范 \"target\": \"es5\", // 编译出的代码采用 ES 的哪个版本 \"sourceMap\": true, // 输出 Source Map 方便调试 \"importHelpers\": true // 避免代码冗余 &#125;, \"exclude\": [ // 不编译这些目录里的文件 \"node_modules\" ]&#125;// 集成 Webpackmodule.exports = &#123; // 执行入口文件 entry: './main', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, './dist'), &#125;, resolve: &#123; extensions: ['.ts', '.js'] // 先尝试 ts 后缀的 TypeScript 源码文件 &#125;, module: &#123; rules: [ &#123; test: /\\.ts$/, loader: 'awesome-typescript-loader' &#125; ] &#125;, devtool: 'source-map', // 输出 Source Map 方便在浏览器里调试 TypeScript 代码&#125;; Flow检查器Flow 是一个 Facebook 开源的 JS 静态类型检测器，它是 JS 语言的超集，在需要的地方加上类型检查。采用了 Flow 静态类型语法的 JS 是无法直接在目前已有的 JS 引擎中运行，要让代码可以运行需要把这些静态类型语法去掉。有两种方式可以做到这点：1、flow-remove-types 可单独使用，速度快。2、babel-preset-flow 与 Babel 集成。方法二：采用webpack123456// 修改 .babelrc 配置文件，加入 Flow Preset// 安装 npm i -D babel-preset-flow 依赖到项目\"presets\": [ ...[], \"flow\"] SCSSSCSS 可以让你用更灵活的方式写 CSS。 它是一种 CSS 预处理器，语法和 CSS 相似，但加入了变量、逻辑、等编程元素。好处：可以方便地管理代码，抽离公共的部分，通过逻辑写出更灵活的代码。SCSS 又叫 SASS，区别在于 SASS 语法类似 Ruby，而 SCSS 语法类似 CSS。 方法一：通过 node-sass 编译 .scss 文件 node-sass main.scss main.css 方法二：接入 Webpack：123456789101112module.exports = &#123; module: &#123; rules: [ &#123; // 增加对 SCSS 文件的支持 test: /\\.scss/, // SCSS 文件的处理顺序为先 sass-loader 再 css-loader 再 style-loader use: ['style-loader', 'css-loader', 'sass-loader'], &#125;, ] &#125;,&#125;; 1、通过 sass-loader 把 SCSS 源码转换为 CSS 代码，再把 CSS 代码交给 css-loader 去处理。2、css-loader 会找出 CSS 代码中的 @import 和 url() 这样的导入语句，告诉 Webpack 依赖这些资源。同时还支持 CSS Modules、压缩 CSS 等功能。处理完后再把结果交给 style-loader 去处理。3、style-loader 会把 CSS 代码转换成字符串后，注入到 JS 代码中去，通过 JS 去给 DOM 增加样式。如果你想把 CSS 代码提取到一个单独的文件而不是和 JS 混在一起，可以使用 ExtractTextPlugin。4、注意：sass-loader 依赖 node-sass PostCSSPostCSS 是一个 CSS 处理工具，和 SCSS 不同的地方在于它通过插件机制可以灵活的扩展其支持的特性，而不是像 SCSS 那样语法是固定的。PostCSS 的用处非常多，包括给 CSS 自动加前缀、使用下一代 CSS 语法等 方法一：postcss.config.js123456module.exports = &#123; plugins: [ // 需要使用的插件列表 require('postcss-cssnext') // postcss-cssnext 插件: 使用下一代 CSS 语法编写代码 ]&#125; 方法一：接入 Webpack1234567891011module.exports = &#123; module: &#123; rules: [ &#123; // 使用 PostCSS 处理 CSS 文件 test: /\\.css/, use: ['style-loader', 'css-loader', 'postcss-loader'], &#125;, ] &#125;,&#125;; Vue框架123456789module: &#123; rules: [ &#123; test: /\\.vue$/, use: ['vue-loader'], &#125;, ]&#125;// 安装依赖：npm i -D vue-loader css-loader vue-template-compiler。它们的作用分别是：1、vue-loader：解析和转换 .vue 文件，提取出其中的逻辑代码 script、样式代码 style、以及 HTML 模版 template，再分别把它们交给对应的 Loader 去处理。2、css-loader：加载由 vue-loader 提取出的 CSS 代码。3、vue-template-compiler：把 vue-loader 提取出的 HTML 模版编译成对应的可执行的 JS 代码，这和 React 中的 JSX 语法被编译成 JS 代码类似。预先编译好 HTML 模版相对于在浏览器中再去编译 HTML 模版的好处在于性能更好。","categories":[{"name":"构建","slug":"构建","permalink":"http://yoursite.com/categories/构建/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"ES6基础知识 — 字符串的扩展","slug":"[ES6] ES6基础知识—字符串的扩展","date":"2018-10-17T12:28:31.000Z","updated":"2018-10-29T13:04:42.601Z","comments":true,"path":"2018/10/17/[ES6] ES6基础知识—字符串的扩展/","link":"","permalink":"http://yoursite.com/2018/10/17/[ES6] ES6基础知识—字符串的扩展/","excerpt":"","text":"1、字符的Unicode表示法2、codePointAt3、String.fromCodePoint4、字符串的遍历器接口for…of…5、normalize6、includes(), startsWith(), endsWith()7、repeat8、padStart，padEnd9、matchAll10、模板字符串11、String.raw 1、字符的Unicode表示法JS允许采用\\uxxxx形式表示一个字符，其中xxxx表示字符的Unicode码点， 只限于码点在\\u0000~\\uFFFFJS 共有 6 种方法可以表示一个字符:12345'\\z' === 'z' // true'\\172' === 'z' // true'\\x7A' === 'z' // true'\\u007A' === 'z' // true'\\u&#123;7A&#125;' === 'z' // true ES6的改进 2、codePointAt能够正确说明字符的字节数，返回字符码点的十进制数 3、String.fromCodePointString.fromCharCode从码点返回对应字符，但不能识别 32 位的 UTF-16 字符String.fromCodePoint方法弥补不足，有多个参数，则它们会被合并成一个字符串返回 fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。 4、字符串的遍历器接口for…of…for…of…：字符串可被循环遍历，可以识别大于0xFFFF的码点 5、normalize用来将字符的不同表示方法统一为同样的形式，称为 Unicode 正规化（该方法可传参，具体需要再查） 6、includes, startsWith, endsWithindexOf一个字符串是否包含在另一个字符串中includes(str, n)是否找到了参数字符串，n表示开始搜索的位置：startsWith(str, n)参数字符串是否在原字符串的头部，n表示开始搜索的位置：endsWith(str, n)参数字符串是否在原字符串的尾部，n表示开始搜索的位置： 7、repeat将原字符串重复n次，参数若是小数，会被取整；参数是负数或者Infinity，会报错；参数NaN等同于 0。 8、padStart，padEndpadStart(n, str)：用于字符串在头部补全，n指定字符串的最小长度，arr用来补全的字符串。padEnd(n, str)：字符串在尾部补全，n指定字符串的最小长度，arr用来补全的字符串。如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。如果省略第二个参数，默认使用空格补全长度。 9、matchAll返回一个正则表达式在当前字符串的所有匹配 10、模板字符串${}和引号的使用 11、String.raw模板字符串的处理函数返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串String.rawHi\\n${2+3}!; // 返回 “Hi\\n5!”String.rawHi\\u000A!; // 返回 “Hi\\u000A!” 123456789101112131415161718192021222324252627282930313233343536373839404142// 1、codePointAtvar str = \"𠮷\";str.length; // length为2，无法正确返回，其为4字节的字符str.charAt(0); //'�' 会导致乱码str.charAt(1); //'�' 会导致乱码str.codePointAt(); // 结果:134071// 2、fromCodePointString.fromCodePoint(0x20BB7)// \"𠮷\"String.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\\uD83D\\uDE80y'// true// 3、字符串的遍历器接口for...of...for (let codePoint of 'foo') &#123; console.log(codePoint); // \"f\" // \"o\" // \"o\"&#125;let text = String.fromCodePoint(0x20BB7);for (let i of text) &#123; console.log(i); // \"𠮷\"&#125;// 4、includes(), startsWith(), endsWith()let s = 'Hello world!';s.startsWith('world', 6) // trues.endsWith('Hello', 5) // trues.includes('Hello', 6) // false// 5、repeat'hello'.repeat(2) // \"hellohello\"'na'.repeat(2.9) // \"nana\"'na'.repeat('na') // \"\"'na'.repeat('3') // \"nanana\"'na'.repeat(-0.9) // \"\"'na'.repeat(NaN) // \"\"'xxx'.padStart(2, 'ab') // 'xxx''xxx'.padEnd(2, 'ab') // 'xxx' 'abc'.padStart(10, '0123456789') // '0123456abc''x'.padStart(4) // ' x''x'.padEnd(4) // 'x '","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6基础知识 — let和const命令","slug":"[ES6] ES6基础知识—let和const命令","date":"2018-10-17T12:23:12.000Z","updated":"2018-10-29T13:04:42.601Z","comments":true,"path":"2018/10/17/[ES6] ES6基础知识—let和const命令/","link":"","permalink":"http://yoursite.com/2018/10/17/[ES6] ES6基础知识—let和const命令/","excerpt":"","text":"1、let和const的性质2、块级作用域3、顶层对象的属性4、global 对象 1、let和const的性质1、let、const声明的变量只在声明所在的块级作用域内有效；const 一旦声明变量，就必须立即初始化，不能留到以后赋值。2、不存在变量提升；3、暂时性死区: 在代码块内，只能在声明的位置后面使用；4、不允许在相同作用域内，重复声明同一个变量； 对于简单类型的数据（数值、字符串、布尔值），const等同于常量。对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。如果将对象冻结，可以使用Object.freeze方法。 1234567891011121314151617181920212223242526272829303132333435// 1、变量声明提升// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2;// 2、暂时性死区案例if (true) &#123; // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125;// 3、对象冻结const foo = Object.freeze(&#123;&#125;);// 常规模式时，下面一行不起作用；严格模式时，该行会报错foo.prop = 123;// 4、除了将对象本身冻结，对象的属性也应该冻结。var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach( (key, i) =&gt; &#123; if ( typeof obj[key] === 'object' ) &#123; constantize( obj[key] ); &#125; &#125;);&#125;; 2、块级作用域提出原因：内层变量可能会覆盖外层变量；用来计数的循环变量泄露为全局变量……实现作用：是在块内使用，不影响外面，外面的变量，内部也能定义。 ES6 有 6 种声明变量的方法：var、function、let、const、import、class 3、顶层对象的属性1234window.a = 1;a // 返回 1a = 2;window.a // 返回 2 上述代码的弊端：1、不能在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；2、其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；3、顶层对象的属性是到处可以读写的，这非常不利于模块化编程。4、window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 var命令和function命令声明的全局变量，依旧是顶层对象的属性； let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。1234567var a = 1;// 如果在 Node 的 REPL 环境，可以写成 global.a// 或者采用通用方法，写成 this.awindow.a // 返回 1let b = 1;window.b // 返回 undefined 4、global 对象目的：为了在不同的环境中都能获取到顶层对象。ES5顶层对象的获取：1、浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。2、浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。3、Node 里面，顶层对象是global，但其他环境都不支持。 同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。1、全局环境中，this会返回顶层对象。但Node 模块和 ES6 模块中，this返回的是当前模块。2、函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。3、不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么eval、new Function这些方法都可能无法使用。 提出了垫片库system.global.123456// CommonJS 的写法var global = require('system.global')();// ES6 模块的写法import getGlobal from 'system.global';const global = getGlobal();","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"移动浏览器的四大内核","slug":"[移动端] 移动浏览器的四大内核","date":"2018-10-15T06:20:45.000Z","updated":"2018-10-29T13:04:42.606Z","comments":true,"path":"2018/10/15/[移动端] 移动浏览器的四大内核/","link":"","permalink":"http://yoursite.com/2018/10/15/[移动端] 移动浏览器的四大内核/","excerpt":"","text":"四大浏览器内核优缺点 Trident:因为在早期IE占有大量的市场份额，所以以前有很多网页是根据这个Trident的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好，同时存在许多安全Bug。 Gecko:优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，缺点是消耗很多的资源，比如内存。 Webkit:优点就是Webkit拥有清晰的源码结构、极快的渲染速度，缺点是对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。 Presto：Presto内核被称为公认的浏览网页速度最快的内核，同时也是处理JS脚本最兼容的内核，能在Windows、Mac及Linux操作系统下完美运行。","categories":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/categories/移动端/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/移动端/"}]},{"title":"跨域的实现方法","slug":"[JS] 跨域的实现方法","date":"2018-10-15T03:09:12.000Z","updated":"2018-10-30T12:56:56.451Z","comments":true,"path":"2018/10/15/[JS] 跨域的实现方法/","link":"","permalink":"http://yoursite.com/2018/10/15/[JS] 跨域的实现方法/","excerpt":"","text":"同源： “协议 + 域名 + 端口” 三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。同源策略限制下 cookie、localStorage、IndexedDB、dom、ajax 都是不支持跨域的。但是有三个标签是允许跨域加载资源：&lt;img src=XXX&gt;、&lt;link href=XXX&gt;、&lt;script src=XXX&gt; 方法一、使用 jsonp 跨域jsonp 和 ajax 相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。但 ajax 属于同源策略，jsonp 属于非同源策略（跨域请求）JSONP优点是兼容性好，可用于解决主流浏览器的跨域数据访问的问题。12345678910111213141516171819202122232425// 封装 jsonp 跨域请求的方法function jsonp(&#123; url, params, cb &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; // 创建一个 script 标签帮助我们发送请求 let script = document.createElement(\"script\"); let arr = []; params = &#123; ...params, cb &#125;; // 循环构建键值对形式的参数 for (let key in params) &#123; arr.push(`$&#123;key&#125;=$&#123;params[key]&#125;`); &#125; // 创建全局函数 window[cb] = function(data) &#123; resolve(data); // 在跨域拿到数据以后将 script 标签销毁 document.body.removeChild(script); &#125;; // 拼接发送请求的参数并赋值到 src 属性 script.src = `$&#123;url&#125;?$&#123;arr.join(\"&amp;\")&#125;`; document.body.appendChild(script); &#125;);&#125; 缺点：只能发送 get 请求 不支持 post、put、delete；不安全，容易引发 xss 攻击。 方法二、使用 CORS 跨域整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。CORS要求浏览器(&gt;IE10)和服务器的同时支持，是跨域的根本解决方法，由浏览器自动完成。优点在于功能更加强大支持各种HTTP Method，缺点是兼容性不如JSONP。 使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。使用场景：多用于开发时，前端与后台在不同的 ip 地址下进行数据访问。案例说明：通过访问 http://localhost:3000/index.html（服务器1） 获取 index.html 文件并执行其中的 Ajax 请求 http://localhost:4000/getDate（服务器2） 接口去获取数据。123456789101112131415161718192021222324let xhr = new XMLHttpRequest();// 正常 cookie 是不允许跨域的document.cookie = 'name=hello';// cookie 想要实现跨域必须携带凭证xhr.withCredentials = true;// xhr.open('GET', 'http://localhost:4000/getDate', true);xhr.open('PUT', 'http://localhost:4000/getDate', true);// 设置名为 name 的自定义请求头xhr.setRequestHeader('name', 'hello');xhr.onreadystatechange = function () &#123; if(xhr.readyState === 4) &#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304) &#123; // 打印返回的数据 console.log(xhr.response); // 打印后台设置的自定义头信息 console.log(xhr.getResponseHeader('name')); &#125; &#125;&#125;xhr.send(); 1234567891011121314151617181920212223242526272829303132333435363738394041// 服务器2const express = require(\"express\");let app = express();// 允许访问域的白名单let whiteList = [\"http://localhost:3000\"];app.use(function(req, res, next) &#123; let origin = req.header.origin; if (whiteList.includes(origin)) &#123; // 设置那个源可以访问我，参数为 * 时，允许任何人访问，但是不可以和 cookie 凭证的响应头共同使用 res.setHeader(\"Access-Control-Allow-Origin\", origin); // 想要获取 ajax 的头信息，需设置响应头 res.setHeader(\"Access-Control-Allow-Headers\", \"name\"); // 处理复杂请求的头 res.setHeader(\"Access-Control-Allow-Methods\", \"PUT\"); // 允许发送 cookie 凭证的响应头 res.setHeader(\"Access-Control-Allow-Credentials\", true); // 允许前端获取哪个头信息 res.setHeader(\"Access-Control-Expose-Headers\", \"name\"); // 处理 OPTIONS 预检的存活时间，单位 s res.setHeader(\"Access-Control-Max-Age\", 5); // 发送 PUT 请求会做一个试探性的请求 OPTIONS，其实是请求了两次，当接收的请求为 OPTIONS 时不做任何处理 if (req.method === \"OPTIONS\") &#123; res.end(); &#125; &#125; next();&#125;);app.put(\"/getDate\", function(req, res) &#123; // res.setHeader('name', 'nihao'); // 设置自定义响应头信息 res.end(\"I love you\");&#125;);app.get(\"/getDate\", function(req, res) &#123; res.end(\"I love you\");&#125;);app.use(express.static(__dirname));app.listen(4000); 方法三、使用 postMessage 实现跨域postMessage 是 H5 的新 API，跨文档消息传送（cross-document messaging），有时简称为 XMD，指的是在来自不同域的页面间传递消息。 使用场景：不是使用 Ajax 的数据通信，更多是在两个页面之间的通信，在 A 页面中引入 B 页面，使用iframe 标签, 在 A、B 两个页面之间通信。12345678910111213&lt;!-- a.html --&gt;&lt;body&gt; &lt;iframe src=\"http://localhost:4000/b.html\" id=\"frame\" onload=\"load()\"&gt;&lt;/iframe&gt; &lt;script&gt; function load() &#123; let frame = document.getElementById('frame'); frame.contentWindow.postMessage('I love you', 'http://localhost:4000'); window.onmessage = function (e) &#123; console.log(e.data); &#125; &#125; &lt;/script&gt;&lt;/body&gt; 1234567891011&lt;!-- b.html --&gt;&lt;body&gt; &lt;script&gt; window.onmessage = function (e) &#123; // 打印来自页面 A 的消息 console.log(e.data); // 给页面 A 发送回执 e.source.postMessage('I love you, too', e.origin); &#125; &lt;/script&gt;&lt;/body&gt; 方法四、使用 window.name 实现跨域同样是页面之间的通信，需要借助 iframe 标签案例说明：A 页面和 B 页面是同域的 http://localhost:3000，C 页面在独立的域 http://localhost:4000。在 A 页面中将 iframe 的 src 指向 C 页面，在 C 页面中将属性值存入 window.name 中，再把 iframe 的 src 换成同域的 B 页面，在当前的 iframe 的 window 对象中取出 name 的值，访问 http://localhost:3000/a.html。1234567891011121314151617&lt;!-- a.html --&gt;&lt;body&gt; &lt;iframe src=\"http://localhost:4000/c.html\" id=\"frame\" onload=\"load()\"&gt;&lt;/iframe&gt; &lt;script&gt; // 增加一个标识，第一次触发 load 时更改地址，更改后再次触发直接取值 let isFirst = true; function load() &#123; let frame = document.getElementById('frame'); if(isFirst) &#123; frame.src = 'http://localhost:3000/b.html'; isFirst = false; &#125; else &#123; console.log(frame.contentWindow.name); &#125; &#125; &lt;/script&gt;&lt;/body&gt; 123456&lt;!-- c.html --&gt;&lt;body&gt; &lt;script&gt; window.name = 'I love you'; &lt;/script&gt;&lt;/body&gt; 方法五、使用 location.hash 实现跨域与 window.name 跨域的情况相同，是不同域的页面间的参数传递案例说明：需要借助 iframe 标签，A 页面和 B 页面是同域的 http://localhost:3000，C 页面是独立的域 http://localhost:4000。A 页面通过 iframe 引入 C 页面，并给 C 页面传一个 hash 值，C 页面收到 hash 值后创建 iframe 引入 B 页面，把 hash 值传给 B 页面，B 页面将自己的 hash 值放在 A 页面的 hash 值中，访问 http://localhost:3000/a.html。12345678910&lt;!-- a.html --&gt;&lt;body&gt; &lt;iframe src=\"http://localhost:4000/c.html#Iloveyou\" id=\"frame\"&gt;&lt;/iframe&gt; &lt;script&gt; // 使用 hashchange 事件接收来自 B 页面设置给 A 页面的 hash 值 window.onhashchange = function () &#123; console.log(location.hash); &#125; &lt;/script&gt;&lt;/body&gt; 12345678910&lt;!-- c.html --&gt;&lt;body&gt; &lt;script&gt; // 打印 A 页面引入 C 页面设置的 hash 值 console.log(location.hash); let iframe = document.createElement('iframe'); iframe.src = 'http://localhost:3000/b.html#Iloveyoutoo'; document.body.appendChild(iframe); &lt;/script&gt;&lt;/body&gt; 1234567&lt;!-- b.html --&gt;&lt;body&gt; &lt;script&gt; // 将 C 页面引入 B 页面设置的 hash 值设置给 A页面 window.parent.parent.location.hash = location.hash; &lt;/script&gt;&lt;/body&gt; 方法六、使用 document.domain 实现跨域使用场景：不是万能的跨域方式，大多使用于同一公司不同产品间获取数据，必须是一级域名和二级域名的关系，如 www.baidu.com 与 video.baidu.com 之间。1234567891011&lt;!-- http://www.domainacross.com:3000/a.html。 --&gt;&lt;body&gt; &lt;p&gt;我是页面 A 的内容&lt;/p&gt; &lt;iframe src=\"http://sucess.domainacross.com:3000/b.html\" onload=\"load()\" id=\"frame\"&gt;&lt;/iframe&gt; &lt;script&gt; document.domain = 'domainacross.com'; function load() &#123; console.log(frame.contentWindow.message); &#125; &lt;/script&gt;&lt;/body&gt; 1234567&lt;body&gt; &lt;p&gt;我是 B 页面的内容&lt;/p&gt; &lt;script&gt; document.domain = 'domainacross.com'; var message = 'Hello A'; &lt;/script&gt;&lt;/body&gt; 方法七、使用 WebSocket 实现跨域Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。WebSocket 与 HTTP 内部都是基于 TCP 协议，区别在于 HTTP 是单向的（单双工），WebSocket 是双向的（全双工），协议是 ws:// 和 wss:// 对应 http:// 和 https://，因为没有跨域限制，所以使用 file:// 协议也可以进行通信。 WebSocket 没有跨域限制，高级 API（不兼容），想要兼容低版本浏览器，可以使用 socket.io 的库，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。 1234567891011121314151617181920&lt;div&gt;user input：&lt;input type=\"text\"&gt;&lt;/div&gt;&lt;script src=\"./socket.io.js\"&gt;&lt;/script&gt;&lt;script&gt;var socket = io('http://www.domain2.com:8080');// 连接成功处理socket.on('connect', function() &#123; // 监听服务端消息 socket.on('message', function(msg) &#123; console.log('data from server: ---&gt; ' + msg); &#125;); // 监听服务端关闭 socket.on('disconnect', function() &#123; console.log('Server socket has closed.'); &#125;);&#125;);document.getElementsByTagName('input')[0].onblur = function() &#123; socket.send(this.value);&#125;;&lt;/script&gt; 12345678910111213141516171819202122232425//Nodejs socket后台：var http = require('http');var socket = require('socket.io');// 启http服务var server = http.createServer(function(req, res) &#123; res.writeHead(200, &#123; 'Content-type': 'text/html' &#125;); res.end();&#125;);server.listen('8080');console.log('Server is running at port 8080...');// 监听socket连接socket.listen(server).on('connection', function(client) &#123; // 接收信息 client.on('message', function(msg) &#123; client.send('hello：' + msg); console.log('data from client: ---&gt; ' + msg); &#125;); // 断开处理 client.on('disconnect', function() &#123; console.log('Client socket has closed.'); &#125;);&#125;); 方法八、使用 nginx 实现跨域方法九、使用 http-proxy-middleware 实现跨域NodeJS 中间件 http-proxy-middleware 实现跨域代理，原理大致与 nginx 相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置 cookieDomainRewrite 参数修改响应头中 cookie 中的域名，实现当前域的 cookie 写入，方便接口登录认证。","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"Http协议知识","slug":"[Http] Http协议知识","date":"2018-10-12T07:44:41.000Z","updated":"2018-10-29T13:04:42.602Z","comments":true,"path":"2018/10/12/[Http] Http协议知识/","link":"","permalink":"http://yoursite.com/2018/10/12/[Http] Http协议知识/","excerpt":"","text":"http协议的请求报文组成格式HTTP请求报文组成：请求行（＜request-line＞）、请求头部（＜headers＞）、空行（＜blank line＞）和请求数据（＜request-body＞）。 1. 请求行请求行组成：请求方法、URL和HTTP协议版本字段组成，它们用空格分隔。例如，GET /index.html HTTP/1.1。 HTTP协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。 2.请求头部请求头部通知服务器有关于客户端请求的信息：User-Agent：产生请求的浏览器类型。Accept：客户端可识别的内容类型列表。Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。 3.请求数据请求数据不在GET方法中使用，而是在POST方法中使用。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。 http协议的响应报文组成格式HTTP响应也组成：状态行（＜status-line＞）、消息报头（＜headers＞）、响应正文（＜response-body＞）。 1.状态行状态行（status line）通过提供一个状态码来说明所请求的资源情况。 状态行格式：服务器HTTP协议的版本（HTTP-Version） 服务器发回的响应状态代码（Status-Code） 状态代码的文本描述（Reason-Phrase） CRLF状态代码： 1xx：指示信息–表示请求已接收，继续处理。 2xx：成功–表示请求已被成功接收、理解、接受。 3xx：重定向–要完成请求必须进行更进一步的操作。 4xx：客户端错误–请求有语法错误或请求无法实现。 5xx：服务器端错误–服务器未能实现合法的请求。 200 OK：客户端请求成功。 400 Bad Request：客户端请求有语法错误，不能被服务器所理解。 401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。 403 Forbidden：服务器收到请求，但是拒绝提供服务。 404 Not Found：请求资源不存在，举个例子：输入了错误的URL。 500 Internal Server Error：服务器发生不可预期的错误。 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。 状态码302与301的区别302重定向表示临时性转移(Temporarily Moved )，当一个网页URL需要短期变化时使用。301重定向/跳转一般，表示本网页永久性转移到另一个地址。301是永久性转移(Permanently Moved), SEO常用的招式，会把旧页面的PR等信息转移到新页面301重定向是永久的重定向，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。302重定向是临时的重定向，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"}]},{"title":"Project Display","slug":"Project-Display","date":"2018-10-11T05:10:11.000Z","updated":"2018-10-11T07:35:30.000Z","comments":true,"path":"2018/10/11/Project-Display/","link":"","permalink":"http://yoursite.com/2018/10/11/Project-Display/","excerpt":"","text":"商城首页 红包雨活动图1: 图2: 小程序 红包拼团图1: 图2: 图3: 图4: 小程序 魅客分销 前端异常监控 性能检测图1: 图2: 图3:","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[]},{"title":"Ajax 原理","slug":"[JS] Ajax原理","date":"2018-09-30T09:20:31.000Z","updated":"2018-10-18T14:38:24.563Z","comments":true,"path":"2018/09/30/[JS] Ajax原理/","link":"","permalink":"http://yoursite.com/2018/09/30/[JS] Ajax原理/","excerpt":"","text":"http://jartto.wang/2015/09/01/chattered-about-ajax/ http://jartto.wang/2015/10/01/advantage-and-disadvantages-of-Ajax/ Ajax函数的封装123456789101112131415161718192021222324function ajax(url, fnSucc, fnFailed) &#123; const oAjax; // 1、建立Ajax对象 if (window.XMLHTTPRequest) &#123; oAjax = new XMLHTTPRequest(); &#125; else &#123; oAjax = new ActiveXObjext('Micosoft.XMLHTTP'); &#125; // 2、连接服务器（打开和连接服务器） oAjax.open('GET', url, true); // 3、发送 oAjax.send(); // 4、接收 oAjax.onreadyStateChange = function() &#123; if (oAjax.readyState === 4) &#123; if (oAjax.status === 200) &#123; // fnSucc fnSucc(oAjax.requesText); &#125; else &#123; fnSucc(oAjax.status); &#125; &#125; &#125;&#125;","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"Html5知识积累","slug":"[H5] Html5知识积累","date":"2018-09-30T06:59:31.000Z","updated":"2018-10-15T03:22:44.000Z","comments":true,"path":"2018/09/30/[H5] Html5知识积累/","link":"","permalink":"http://yoursite.com/2018/09/30/[H5] Html5知识积累/","excerpt":"","text":"sessionStorage 和 localStorageWeb Storage包括了两种存储方式：sessionStorage和localStorage。sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁，生命周期为当前窗口或标签页，一旦窗口或标签页被永久关闭了。 因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。 页面及标签页仅指顶级窗口，如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的。localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 web storage和cookie的区别：Web Storage是为了更大容量存储而设计。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。 Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要开发者自己封装setCookie,getCookie。 Cookie优点：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。 html5 web storage的浏览器支持情况:浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持。通过简单的代码封装可以统一到所有的浏览器都支持web storage。12345678910if(window.localStorage)&#123; // 浏览支持localStorage&#125;else&#123; // 浏览暂不支持localStorage&#125;//或者 if(typeof window.localStorage == 'undefined')&#123; // 浏览暂不支持localStorage&#125; setItem存储value 用途，.setItem(key, value)getItem获取value 用途，.getItem(key)removeItem删除key 用途，.removeItem(key)clear清除所有的key/value 用途， .clear()localStorage和sessionStorage的key和length属性实现遍历: sessionStorage和localStorage提供的key()和length可以方便的实现存储的数据遍历. 123456789101112131415161718sessionStorage.setItem(\"key\", \"value\"); localStorage.setItem(\"site\", \"js8.in\");var value = sessionStorage.getItem(\"key\"); var site = localStorage.getItem(\"site\");sessionStorage.removeItem(\"key\"); localStorage.removeItem(\"site\");sessionStorage.clear(); localStorage.clear();var storage = window.localStorage; for (var i=0, len = storage.length; i &lt; len; i++)&#123; var key = storage.key(i); var value = storage.getItem(key); console.log(key + \"=\" + value); &#125; web storage 的离线存储H5 的 Web storage API 采用了离线缓存，会生成一个清单文件（manifest file)，这个清单文件实质就是一系列的URL列表文件，这些URL分别指向页面当中的html,css,javascript,图片等相关内容。当使用离线应用时，应用会引入这一清单文件，浏览器会读取这一文件，下载相应的文件，并将其缓存到本地。使得这些web应用能够脱离网络使用，而用户在离线时的更改也同样会映射到清单文件中，并在重新连线之后将更改返回应用，工作方式与我们现在所使用的网盘有着异曲同工之处。首先，需要在页面头加入manifest属性：1234&lt;!DOCTYPE HTML&gt;&lt;html manifest = \"cache.manifest\"&gt;...&lt;/html&gt; 然后cache.manifest文件的书写方式为：123456789CACHE MANIFEST#v0.11CACHE:js/app.jscss/style.cssNETWORK:resourse/logo.pngFALLBACK:/ /offline.html 离线存储的manifest一般由三个部分组成: CACHE:表示需要离线存储的资源列表，由于包含manifest文件的页面将被自动离线存储，所以不需要把页面自身也列出来。 NETWORK:表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在CACHE和NETWORK中有一个相同的资源，那么这个资源还是会被离线存储，也就是说CACHE的优先级更高。 FALLBACK:表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问offline.html。 http://jartto.wang/2016/07/25/make-an-inventory-of-html5-api/","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"H5","slug":"H5","permalink":"http://yoursite.com/tags/H5/"}]},{"title":"正则表达式","slug":"[JS] 正则表达式","date":"2018-09-29T08:20:42.000Z","updated":"2018-10-08T02:21:34.000Z","comments":true,"path":"2018/09/29/[JS] 正则表达式/","link":"","permalink":"http://yoursite.com/2018/09/29/[JS] 正则表达式/","excerpt":"","text":"正则表达式是匹配模式，要么匹配字符，要么匹配位置。 正则表达式字符匹配攻略 两种模糊匹配：横向模糊和纵向模糊横向模糊指的是，一个正则可匹配的字符串的长度不是固定的。纵向模糊指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符。 字符组[123456abcdefGHIJKLM] 可以写成 [1-6a-fG-M]可以写成如下的方式：[-az]或[az-]或[a\\-z], 即要么放在开头，要么放在结尾，要么转义 排除字符组：例如[^abc]，表示是一个除”a”、”b”、”c”之外的任意一个字符。字符组的第一位放^（脱字符），表示求反。 \\d就是[0-9]。表示是一位数字。记忆方式：其英文是digit（数字） \\D就是[^0-9]。表示除数字外的任意字符。\\w就是[0-9a-zA-Z_]。表示数字、大小写字母和下划线。 \\W是[^0-9a-zA-Z_]。非单词字符。记忆方式：w是word的简写，也称单词字符。 \\s是[ \\t\\v\\n\\r\\f]。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。记忆方式：s是space character的首字母。 \\S是[^ \\t\\v\\n\\r\\f]。 非空白符。 .就是[^\\n\\r\\u2028\\u2029]。通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外。记忆方式：想想省略号…中的每个点，都可以理解成占位符，表示任何类似的东西。 量词： {m,} 表示至少出现m次。 {m} 等价于{m,m}，表示出现m次。 ? 等价于{0,1}，表示出现或者不出现。记忆方式：问号的意思表示，有吗？ + 等价于{1,}，表示出现至少一次。记忆方式：加号是追加的意思，得先有一个，然后才考虑追加。 * 等价于{0,}，表示出现任意次，有可能不出现。记忆方式：看看天上的星星，可能一颗没有，可能零散有几颗，可能数也数不过来。 贪婪匹配: 尽可能多的匹配惰性匹配: 尽可能少的匹配 多选分支(p1|p2|p3)，其中p1、p2和p3是子模式，用|（管道符）分隔，表示其中任何之一。 案例 匹配时间（24小时制）：/^(0?[0-9]|1[0-9]|[2][0-3]):(0?[0-9]|[1-5][0-9])$/ 匹配日期（yyyy-mm-dd格式）： /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/ window操作系统文件路径：/^[a-zA-Z]:\\\\([^\\\\:*&lt;&gt;|&quot;?\\r\\n/]+\\\\)*([^\\\\:*&lt;&gt;|&quot;?\\r\\n/]+)?$/eg：盘符:\\文件夹\\文件夹\\文件夹\\F:\\study\\javascript\\regex\\regular expression.pdfF:\\study\\javascript\\regex\\F:\\study\\javascriptF:\\ 文件名或者文件夹名，不能包含一些特殊字符，排除字符组[^\\\\:*&lt;&gt;|&quot;?\\r\\n/]来表示合法字符路径的最后一部分可以是“文件夹”，没有\\，因此需要添加([^\\\\:*&lt;&gt;|&quot;?\\r\\n/]+)? 正则表达式位置匹配攻略 ^（脱字符）匹配开头，在多行匹配中匹配行开头。 $（美元符号）匹配结尾，在多行匹配中匹配行结尾。 \\b 是单词边界，具体就是\\w和\\W之间的位置，也包括\\w和^之间的位置，也包括\\w和$之间的位置。\\w是字符组[0-9a-zA-Z_]的简写形式， \\B 是\\b的反面的意思，非单词边界 (?=p) 其中p是一个子模式，即p前面的位置。eg：(?=l)，表示’l’字符前面的位置。（positive lookahead） (?!p) 是(?=p)的反面意思。（negative lookahead） 案例 不匹配任何东西的正则: /.^/ 数字的千位分隔符表示法: “12,345,678” 正则为：/(?!^)(?=(\\d{3})+$)/g“12345678 123456789” 替换成”12,345,678 123,456,789” 正则为: /\\B(?=(\\d{3})+\\b)/g，其中 (?!\\b) 为 \\B 必须包含数字: (?=.*[0-9]) 同时包含数字和小写字母: (?=.*[0-9])(?=.*[a-z]) 密码长度6-12位，由数字、小写字符和大写字母组成，但必须至少包括2种字符。/((?=.*[0-9])(?=.*[a-z])|(?=.*[0-9])(?=.*[A-Z])|(?=.*[a-z])(?=.*[A-Z]))^[0-9A-Za-z]{6,12}$/ 正则表达式括号的作用 “2017-06-12”.replace(/(\\d{4})-(\\d{2})-(\\d{2})/, “$2/$3/$1”); // “06/12/2017” 匹配”2016-06-12”、”2016/06/12”、”2016.06.12” 正则为: /\\d{4}(-|\\/|\\.)\\d{2}\\1\\d{2}/注意里面的\\1，表示的引用之前的那个分组(-|\\/|\\.)。不管它匹配到什么（比如-），\\1都匹配那个同样的具体某个字符。 括号嵌套 \\10表示第10个分组 123var regex = /(1)(2)(3)(4)(5)(6)(7)(8)(9)(#) \\10+/;var string = \"123456789# ######\"console.log( regex.test(string) ); // =&gt; true 引用不存在的分组因为反向引用，是引用前面的分组，但我们在正则里引用了不存在的分组时，此时正则不会报错，只是匹配反向引用的字符本身。 [x] 字符串trim方法模拟 1234function trim(str) &#123; return str.replace(/^\\s+|\\s+$/g, '');&#125;console.log( trim(\" foobar \") ); // =&gt; \"foobar\" [x] 将每个单词的首字母转换为大写 123456function titleize(str) &#123; return str.toLowerCase().replace(/(?:^|\\s)\\w/g, function(c) &#123; return c.toUpperCase(); &#125;);&#125;console.log( titleize('my name is epeli') ); // =&gt; \"My Name Is Epeli\" [x] 驼峰化 123456function camelize(str) &#123; return str.replace(/[-_\\s]+(.)?/g, function(match, c) &#123; return c ? c.toUpperCase() : ''; &#125;);&#125;console.log( camelize('-moz-transform') ); // =&gt; \"MozTransform\" [x] 匹配成对标签 /&lt;([^&gt;]+)&gt;[\\d\\D]*&lt;\\/\\1&gt;/开标签: &lt;[^&gt;]+&gt;, 闭标签: &lt;\\/[^&gt;]+&gt;[\\d\\D]的意思是，这个字符是数字或者不是数字，因此，也就是匹配任意字符的意思。 正则表达式回溯法原理正则表达式的拆分正则表达式的构建正则表达式编程正则表达式的一些规则RegExp对象的方法： test：在字符串中测试模式匹配,返回 true 或 false exec：在字符串中执行匹配搜索,返回结果数组 match(pattern)：返回 pattern 中的子串或 null replace(pattern, replacement)：用 replacement 替换 pattern search(pattern)：返回字符串中 pattern 开始位置 split(pattern)：返回字符串按指定 pattern 拆分的数组","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"webpack 优化项目策略","slug":"[构建] webpack优化项目","date":"2018-09-29T02:20:51.000Z","updated":"2018-10-21T14:51:08.024Z","comments":true,"path":"2018/09/29/[构建] webpack优化项目/","link":"","permalink":"http://yoursite.com/2018/09/29/[构建] webpack优化项目/","excerpt":"","text":"优化可以分为优化开发体验和优化输出质量两部分。 优化开发体验优化开发体验的目的是为了提升开发时的效率 1.优化构建速度缩小文件搜索范围使用 DllPlugin使用 HappyPack使用 ParallelUglifyPlugin 2.优化使用体验使用自动刷新开启模块热替换 优化输出质量优化输出质量的目的是为了给用户呈现体验更好的网页，例如减少首屏加载时间、提升性能流畅度等。 1.减少用户能感知到的加载时间(首屏加载时间)区分环境压缩代码CDN 加速使用 Tree Shaking提取公共代码按需加载 2.提升流畅度(提升代码性能)使用 Prepack开启 Scope Hoisting 缩小文件搜索范围 resolveWebpack 启动后会从配置的 Entry 出发，解析出文件中的导入语句，再递归的解析。在遇到导入语句时 Webpack 会做两件事情：1、根据导入语句去寻找对应的要导入的文件。 例如 require(‘react’) 导入语句对应的文件是 ./node_modules/react/react.js， require(‘./util’) 对应的文件是 ./util.js。2、根据找到的要导入文件的后缀，使用配置中的 Loader 去处理文件。 例如使用 ES6 开发的 JavaScript 文件需要使用 babel-loader 去处理。 DllPlugin动态链接库: 可包含给其他模块调用的函数和数据。 要给 Web 项目构建接入动态链接库的思想，需要完成以下事情：1、把网页依赖的基础模块抽离出来，打包到一个个单独的动态链接库中去。一个动态链接库中可以包含多个模块。2、当需要导入的模块存在于某个动态链接库中时，这个模块不能被再次被打包，而是去动态链接库中获取。3、页面依赖的所有动态链接库需要被加载。 Web 项目构建接入动态链接库的思想后，会大大提升构建速度。原因：包含大量复用模块的动态链接库只需要编译一次，在之后的构建过程中被动态链接库包含的模块将不会在重新编译，而是直接使用动态链接库中的代码。由于动态链接库中大多数包含的是常用的第三方模块，例如 react、react-dom，只要不升级这些模块的版本，动态链接库就不用重新编译。 DllPlugin: 用于打包出一个个单独的动态链接库文件。DllReferencePlugin: 将打包好的dll文件传入构建的代码里面12345678910111213141516171819202122232425262728293031323334// webpack_dll.config.jsconst path = require('path');const DllPlugin = require('webpack/lib/DllPlugin');module.exports = &#123; // JS 执行入口文件 entry: &#123; // 把 React 相关模块的放到一个单独的动态链接库 react: ['react', 'react-dom'], // 把项目需要所有的 polyfill 放到一个单独的动态链接库 polyfill: ['core-js/fn/object/assign', 'core-js/fn/promise', 'whatwg-fetch'], &#125;, output: &#123; // 输出的动态链接库的文件名称，[name] 代表当前动态链接库的名称， // 也就是 entry 中配置的 react 和 polyfill filename: '[name].dll.js', // 输出的文件都放到 dist 目录下 path: path.resolve(__dirname, 'dist'), // 存放动态链接库的全局变量名称，例如对应 react 来说就是 _dll_react // 之所以在前面加上 _dll_ 是为了防止全局变量冲突 library: '_dll_[name]', &#125;, plugins: [ // 接入 DllPlugin new DllPlugin(&#123; // 动态链接库的全局变量名称，需要和 output.library 中保持一致 // 该字段的值也就是输出的 manifest.json 文件 中 name 字段的值 // 例如 react.manifest.json 中就有 \"name\": \"_dll_react\" name: '_dll_[name]', // 描述动态链接库的 manifest.json 文件输出时的文件名称 path: path.join(__dirname, 'dist', '[name].manifest.json'), &#125;), ],&#125;; 构建出的动态链接库文件用于给其它地方使用，在这里也就是给执行入口使用。1234567891011121314151617181920212223242526272829303132333435363738// 主 webpack.config.js 文件const path = require('path');const DllReferencePlugin = require('webpack/lib/DllReferencePlugin');module.exports = &#123; entry: &#123; // 定义入口 Chunk main: './main.js' &#125;, output: &#123; // 输出文件的名称 filename: '[name].js', // 输出文件都放到 dist 目录下 path: path.resolve(__dirname, 'dist'), &#125;, module: &#123; rules: [ &#123; // 项目源码使用了 ES6 和 JSX 语法，需要使用 babel-loader 转换 test: /\\.js$/, use: ['babel-loader'], exclude: path.resolve(__dirname, 'node_modules'), &#125;, ] &#125;, plugins: [ // 告诉 Webpack 使用了哪些动态链接库 new DllReferencePlugin(&#123; // 描述 react 动态链接库的文件内容 manifest: require('./dist/react.manifest.json'), &#125;), new DllReferencePlugin(&#123; // 描述 polyfill 动态链接库的文件内容 manifest: require('./dist/polyfill.manifest.json'), &#125;), ], devtool: 'source-map'&#125;; 注意：在 webpack_dll.config.js 文件中，DllPlugin 中的 name 参数必须和 output.library 中保持一致。 原因在于 DllPlugin 中的 name 参数会影响输出的 manifest.json 文件中 name 字段的值， 而在 webpack.config.js 文件中 DllReferencePlugin 会去 manifest.json 文件读取 name 字段的值， 把值的内容作为在从全局变量中获取动态链接库中内容时的全局变量名。 执行构建时流程如下：1、如果动态链接库相关的文件还没有编译出来，就需要先把它们编译出来。方法是执行 webpack –config webpack_dll.config.js 命令。2、在确保动态链接库存在时，才能正常的编译出入口执行文件。方法是执行 webpack 命令。这时你会发现构建速度有了非常大的提升。 AddAssetHtmlPlugin: 在生成的html文件中加入dll文件的script引用imagemin-webpack-plugin: 压缩图片；webpack-spritesmith: 插件制作雪碧图 png: file-loader 可以把 JS 和 CSS 中导入图片的语句替换成正确的地址，并同时把文件输出到对应的位置。url-loader 经 base64 编码后注入到 JS 或者 CSS 中去。svg: raw-loader 可以把文本文件的内容读取出来，注入到 JS 或 CSS 中去。 DllPlugin由于有大量文件需要解析和处理，构建是文件读写和计算密集型的操作，特别是当文件数量变多后，Webpack 构建慢的问题会显得严重。运行在 Node.js 之上的 Webpack 是单线程模型的。 文件读写和计算操作是无法避免的，那能不能让 Webpack 同一时刻处理多个任务，发挥多核 CPU 电脑的威力，以提升构建速度呢？ HappyPack 就能让 Webpack 做到这点，它把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。 总结：侧重优化开发体验的配置文件 webpack.config.js：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394const path = require('path');const CommonsChunkPlugin = require('webpack/lib/optimize/CommonsChunkPlugin');const &#123;AutoWebPlugin&#125; = require('web-webpack-plugin');const HappyPack = require('happypack');// 自动寻找 pages 目录下的所有目录，把每一个目录看成一个单页应用const autoWebPlugin = new AutoWebPlugin('./src/pages', &#123; // HTML 模版文件所在的文件路径 template: './template.html', // 提取出所有页面公共的代码 commonsChunk: &#123; // 提取出公共代码 Chunk 的名称 name: 'common', &#125;,&#125;);module.exports = &#123; // AutoWebPlugin 会找为寻找到的所有单页应用，生成对应的入口配置， // autoWebPlugin.entry 方法可以获取到生成入口配置 entry: autoWebPlugin.entry(&#123; // 这里可以加入你额外需要的 Chunk 入口 base: './src/base.js', &#125;), output: &#123; filename: '[name].js', &#125;, resolve: &#123; // 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤 // 其中 __dirname 表示当前工作目录，也就是项目根目录 modules: [path.resolve(__dirname, 'node_modules')], // 针对 Npm 中的第三方模块优先采用 jsnext:main 中指向的 ES6 模块化语法的文件，使用 Tree Shaking 优化 // 只采用 main 字段作为入口文件描述字段，以减少搜索步骤 mainFields: ['jsnext:main', 'main'], &#125;, module: &#123; rules: [ &#123; // 如果项目源码中只有 js 文件就不要写成 /\\.jsx?$/，提升正则表达式性能 test: /\\.js$/, // 使用 HappyPack 加速构建 use: ['happypack/loader?id=babel'], // 只对项目根目录下的 src 目录中的文件采用 babel-loader include: path.resolve(__dirname, 'src'), &#125;, &#123; test: /\\.js$/, use: ['happypack/loader?id=ui-component'], include: path.resolve(__dirname, 'src'), &#125;, &#123; // 增加对 CSS 文件的支持 test: /\\.css/, use: ['happypack/loader?id=css'], &#125;, ] &#125;, plugins: [ autoWebPlugin, // 使用 HappyPack 加速构建 new HappyPack(&#123; id: 'babel', // babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启 loaders: ['babel-loader?cacheDirectory'], &#125;), new HappyPack(&#123; // UI 组件加载拆分 id: 'ui-component', loaders: [&#123; loader: 'ui-component-loader', options: &#123; lib: 'antd', style: 'style/index.css', camel2: '-' &#125; &#125;], &#125;), new HappyPack(&#123; id: 'css', // 如何处理 .css 文件，用法和 Loader 配置中一样 loaders: ['style-loader', 'css-loader'], &#125;), // 4-11提取公共代码 new CommonsChunkPlugin(&#123; // 从 common 和 base 两个现成的 Chunk 中提取公共的部分 chunks: ['common', 'base'], // 把公共的部分放到 base 中 name: 'base' &#125;), ], watchOptions: &#123; // 4-5使用自动刷新：不监听的 node_modules 目录下的文件 ignored: /node_modules/, &#125;&#125;; 侧重优化输出质量的配置文件 webpack-dist.config.js：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140const path = require('path');const DefinePlugin = require('webpack/lib/DefinePlugin');const ModuleConcatenationPlugin = require('webpack/lib/optimize/ModuleConcatenationPlugin');const CommonsChunkPlugin = require('webpack/lib/optimize/CommonsChunkPlugin');const ExtractTextPlugin = require('extract-text-webpack-plugin');const &#123;AutoWebPlugin&#125; = require('web-webpack-plugin');const HappyPack = require('happypack');const ParallelUglifyPlugin = require('webpack-parallel-uglify-plugin');// 自动寻找 pages 目录下的所有目录，把每一个目录看成一个单页应用const autoWebPlugin = new AutoWebPlugin('./src/pages', &#123; // HTML 模版文件所在的文件路径 template: './template.html', // 提取出所有页面公共的代码 commonsChunk: &#123; // 提取出公共代码 Chunk 的名称 name: 'common', &#125;, // 指定存放 CSS 文件的 CDN 目录 URL stylePublicPath: '//css.cdn.com/id/',&#125;);module.exports = &#123; // AutoWebPlugin 会找为寻找到的所有单页应用，生成对应的入口配置， // autoWebPlugin.entry 方法可以获取到生成入口配置 entry: autoWebPlugin.entry(&#123; // 这里可以加入你额外需要的 Chunk 入口 base: './src/base.js', &#125;), output: &#123; // 给输出的文件名称加上 Hash 值 filename: '[name]_[chunkhash:8].js', path: path.resolve(__dirname, './dist'), // 指定存放 JavaScript 文件的 CDN 目录 URL publicPath: '//js.cdn.com/id/', &#125;, resolve: &#123; // 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤 // 其中 __dirname 表示当前工作目录，也就是项目根目录 modules: [path.resolve(__dirname, 'node_modules')], // 只采用 main 字段作为入口文件描述字段，以减少搜索步骤 mainFields: ['jsnext:main', 'main'], &#125;, module: &#123; rules: [ &#123; // 如果项目源码中只有 js 文件就不要写成 /\\.jsx?$/，提升正则表达式性能 test: /\\.js$/, // 使用 HappyPack 加速构建 use: ['happypack/loader?id=babel'], // 只对项目根目录下的 src 目录中的文件采用 babel-loader include: path.resolve(__dirname, 'src'), &#125;, &#123; test: /\\.js$/, use: ['happypack/loader?id=ui-component'], include: path.resolve(__dirname, 'src'), &#125;, &#123; // 增加对 CSS 文件的支持 test: /\\.css/, // 提取出 Chunk 中的 CSS 代码到单独的文件中 use: ExtractTextPlugin.extract(&#123; use: ['happypack/loader?id=css'], // 指定存放 CSS 中导入的资源（例如图片）的 CDN 目录 URL publicPath: '//img.cdn.com/id/' &#125;), &#125;, ] &#125;, plugins: [ autoWebPlugin, // 4-14开启ScopeHoisting new ModuleConcatenationPlugin(), // 4-3使用HappyPack new HappyPack(&#123; // 用唯一的标识符 id 来代表当前的 HappyPack 是用来处理一类特定的文件 id: 'babel', // babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启 loaders: ['babel-loader?cacheDirectory'], &#125;), new HappyPack(&#123; // UI 组件加载拆分 id: 'ui-component', loaders: [&#123; loader: 'ui-component-loader', options: &#123; lib: 'antd', style: 'style/index.css', camel2: '-' &#125; &#125;], &#125;), new HappyPack(&#123; id: 'css', // 如何处理 .css 文件，用法和 Loader 配置中一样 // 通过 minimize 选项压缩 CSS 代码 loaders: ['css-loader?minimize'], &#125;), new ExtractTextPlugin(&#123; // 给输出的 CSS 文件名称加上 Hash 值 filename: `[name]_[contenthash:8].css`, &#125;), // 4-11提取公共代码 new CommonsChunkPlugin(&#123; // 从 common 和 base 两个现成的 Chunk 中提取公共的部分 chunks: ['common', 'base'], // 把公共的部分放到 base 中 name: 'base' &#125;), new DefinePlugin(&#123; // 定义 NODE_ENV 环境变量为 production 去除 react 代码中的开发时才需要的部分 'process.env': &#123; NODE_ENV: JSON.stringify('production') &#125; &#125;), // 使用 ParallelUglifyPlugin 并行压缩输出的 JS 代码 new ParallelUglifyPlugin(&#123; // 传递给 UglifyJS 的参数 uglifyJS: &#123; output: &#123; // 最紧凑的输出 beautify: false, // 删除所有的注释 comments: false, &#125;, compress: &#123; // 在UglifyJs删除没有用到的代码时不输出警告 warnings: false, // 删除所有的 `console` 语句，可以兼容ie浏览器 drop_console: true, // 内嵌定义了但是只用到一次的变量 collapse_vars: true, // 提取出出现多次但是没有定义成变量去引用的静态值 reduce_vars: true, &#125; &#125;, &#125;), ]&#125;;","categories":[{"name":"构建","slug":"构建","permalink":"http://yoursite.com/categories/构建/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"async、await的介绍","slug":"[ES6] async、await","date":"2018-09-29T02:20:51.000Z","updated":"2018-10-30T11:14:52.703Z","comments":true,"path":"2018/09/29/[ES6] async、await/","link":"","permalink":"http://yoursite.com/2018/09/29/[ES6] async、await/","excerpt":"","text":"1、async/await 是一种编写异步代码的新方法。之前异步代码的方案是回调和 promise。2、async/await 是建立在 promise 的基础上。3、async/await 像 promise 一样，也是非阻塞的。4、async/await 让异步代码看起来、表现起来更像同步代码。 asyncasync 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。12345678910111213// 含有返回值async function testAsync() &#123; return \"hello async\";&#125;const result = testAsync();console.log(result); // Promise &#123;&lt;resolved&gt;: \"hello async\"&#125;// 没有返回值async function testAsync1() &#123; console.log(\"hello async\");&#125;const result = testAsync1(); // hello asyncconsole.log(result); // Promise &#123;&lt;resolved&gt;: undefined&#125; 因为async就有返回 awaitawait 后可以接普通函数调用或者直接量。await 是个运算符，用于组成表达式，await 表达式的运算结果取决于它等的东西。若等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。若等到的是一个 Promise 对象，await 就会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。 1234567891011121314function getSomething() &#123; return \"something\";&#125;async function testAsync() &#123; return Promise.resolve(\"hello async\");&#125;async function test() &#123; const v1 = await getSomething(); const v2 = await testAsync(); console.log(v1, v2); // 'something' 'hello async'&#125;test(); // Promise &#123;&lt;resolved&gt;: undefined&#125; async和await的作用async/await 的优势在于处理 then 链123456789101112131415161718192021// 案例1function takeLongTime() &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(\"long_time_value\"), 1000); &#125;);&#125;takeLongTime().then(v =&gt; &#123; console.log(\"got\", v);&#125;);// 案例1 改用 async/awaitfunction takeLongTime() &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(\"long_time_value\"), 1000); &#125;);&#125;async function test() &#123; const v = await takeLongTime(); console.log(v);&#125;test(); 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 案例2function takeLongTime(n) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(n + 200), n); &#125;);&#125;function step1(n) &#123; console.log(`step1 with $&#123;n&#125;`); return takeLongTime(n);&#125;function step2(n) &#123; console.log(`step2 with $&#123;n&#125;`); return takeLongTime(n);&#125;function step3(n) &#123; console.log(`step3 with $&#123;n&#125;`); return takeLongTime(n);&#125;// 用 Promise 方式来实现这三个步骤的处理function doIt() &#123; console.time(\"doIt\"); const time1 = 300; step1(time1) .then(time2 =&gt; step2(time2)) .then(time3 =&gt; step3(time3)) .then(result =&gt; &#123; console.log(`result is $&#123;result&#125;`); console.timeEnd(\"doIt\"); &#125;);&#125;// 用 async/await 来实现async function doIt() &#123; console.time(\"doIt\"); const time1 = 300; const time2 = await step1(time1); const time3 = await step2(time2); const result = await step3(time3); console.log(`result is $&#123;result&#125;`); console.timeEnd(\"doIt\");&#125;// step1 with 300// step2 with 500// step3 with 700// result is 900// doIt: 1507.251ms 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 案例3function step1(n) &#123; console.log(`step1 with $&#123;n&#125;`); return takeLongTime(n);&#125;function step2(m, n) &#123; console.log(`step2 with $&#123;m&#125; and $&#123;n&#125;`); return takeLongTime(m + n);&#125;function step3(k, m, n) &#123; console.log(`step3 with $&#123;k&#125;, $&#123;m&#125; and $&#123;n&#125;`); return takeLongTime(k + m + n);&#125;// 用 async/await 来写async function doIt() &#123; console.time(\"doIt\"); const time1 = 300; const time2 = await step1(time1); const time3 = await step2(time1, time2); const result = await step3(time1, time2, time3); console.log(`result is $&#123;result&#125;`); console.timeEnd(\"doIt\");&#125;// 用 Promise 方式来实现function doIt() &#123; console.time(\"doIt\"); const time1 = 300; step1(time1) .then(time2 =&gt; &#123; return step2(time1, time2) .then(time3 =&gt; [time1, time2, time3]); &#125;) .then(times =&gt; &#123; const [time1, time2, time3] = times; return step3(time1, time2, time3); &#125;) .then(result =&gt; &#123; console.log(`result is $&#123;result&#125;`); console.timeEnd(\"doIt\"); &#125;);&#125;// step1 with 300// step2 with 800 = 300 + 500// step3 with 1800 = 300 + 500 + 1000// result is 2000// doIt: 2907.387ms","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"前端工程化","slug":"前端工程化","date":"2018-09-28T06:29:31.000Z","updated":"2018-10-08T02:21:03.000Z","comments":true,"path":"2018/09/28/前端工程化/","link":"","permalink":"http://yoursite.com/2018/09/28/前端工程化/","excerpt":"","text":"前端工程化：开发需求、共享需求、性能需求、部署需求。为了简化前端工程化的配置，出现了很多优秀的工具比如：1、前端工作流工具：Gulp，Grunt，Broccoli2、前端 JS 模块编译工具：Babel，Browserify，Webpack3、前端开发系列工具： livereload，数据 mock，代码监控，代码检查 开发需求在开始一个前端项目时，通常需要进行技术选型，定义代码规范以及配合后端和业务进行项目的目录规划 代码规范：jslint、SASSLint、ESLint/TSLint…. JS 预处理：（编译过程） 编程语言：Coffeescript、Livescript、Typescript、React Jsx、Dart、Elm…. ES6 CommonJS Typescript 中提供静态语法的一些强类型特性。Coffeescript, Livescript 提供现代化语言的语法糖特性，专门针对 xml 优化的 JSX。 CSS 预处理：less、sass…预处理工具：Autoprefixer、Compass 文件处理： src 放置源码，dist 放置编译后的代码 开发效率：webpack的Hot Module Replacement， livereload 自动刷新浏览器 数据 mock：可构建mock平台 域名代理 共享需求设计前端项目架构时，一定要考虑业务的组件化和可共享性： Base 基础代码共享 通用工具方法共享 基础交互组件共享 业务组件共享 性能需求优化源码的体积是提升首屏加载时间的关键： Javascript, Css 代码压缩 Javascript, Css 代码合并 图片压缩 Css 图片精灵或雪碧图（css sprit） 可以在前端工程的 build 过程中实现。 部署需求 多人分支协作流程：用 git flow 来管理代码分支 代码自动发布：git hookgit hook实现代码自动部署 前端工作流工具 Grunt: 基于配置的工作流模式，定义一个配置文件，声明工作流各个环节的相关配置，调用 grunt 就能完成打包编译. Broccoli: 以 tree 的基础结构，提供极其高效稳定的工作流。 Gulp: 基于内存的流的方式，提供高效的性能，极简的 API，定义不同的 task，然后将 task 串联起来。 前端 Javascript 编译工具 Babel Browserify: 是最先出现的 CommonJs 编译工具，使得我们可以像写 Node 模块一样写前端代码，Browserify 可以 build 使用 npm 中的所有模块。 Webpack: 是支持 CommonJs 和 AMD 的模块编译工具，逐渐替代 Browserify, 基于 AMD 的好处就是代码可以异步话，这是 Browserify 无法做到的。","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"}]},{"title":"parceljs & webpack","slug":"[构建] parceljs & webpack","date":"2018-09-28T06:29:31.000Z","updated":"2018-10-08T02:21:31.000Z","comments":true,"path":"2018/09/28/[构建] parceljs & webpack/","link":"","permalink":"http://yoursite.com/2018/09/28/[构建] parceljs & webpack/","excerpt":"","text":"","categories":[{"name":"构建","slug":"构建","permalink":"http://yoursite.com/categories/构建/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack 进阶","slug":"[构建] webpack进阶","date":"2018-09-28T06:09:21.000Z","updated":"2018-10-23T13:18:01.858Z","comments":true,"path":"2018/09/28/[构建] webpack进阶/","link":"","permalink":"http://yoursite.com/2018/09/28/[构建] webpack进阶/","excerpt":"","text":"在使用 webpack 构建的典型应用程序或站点中，有三种主要的代码类型：1、团队编写的源码。2、源码会依赖的任何第三方的 library 或 “vendor” 代码。3、webpack 的 runtime 和 manifest，管理所有模块的交互。runtime 包含：在模块交互时，连接模块所需的加载和解析逻辑。包括浏览器中的已加载模块的连接，以及懒加载模块的执行逻辑。通过使用 manifest 中的数据，runtime 将能够查询模块标识符，检索出背后对应的模块。import 或 require 语句现在都已经转换为 __webpack_require__ 方法，此方法指向模块标识符(module identifier) 配置分离在大型项目中，webpack.config.js 会变得越来越臃肿，因此可以利用 webpack-merge 插件。将配置定义在一个目录下面的不同文件中，然后通过 webpack-merge 来合并成最终的配置。 code splitting 异步加载","categories":[{"name":"构建","slug":"构建","permalink":"http://yoursite.com/categories/构建/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack 入门","slug":"[构建] webpack入门","date":"2018-09-28T03:42:48.000Z","updated":"2018-10-17T17:09:38.655Z","comments":true,"path":"2018/09/28/[构建] webpack入门/","link":"","permalink":"http://yoursite.com/2018/09/28/[构建] webpack入门/","excerpt":"","text":"论述CommonJS 是一种使用广泛的 JavaScript 模块化规范，核心思想是通过 require 方法来同步地加载依赖的其他模块，通过 module.exports 导出需要暴露的接口。CommonJS 的优点在于： 代码可复用于 Node.js 环境下并运行，例如做同构应用； 通过 NPM 发布的很多第三方模块都采用了 CommonJS 规范。 CommonJS 的缺点在于这样的代码无法直接运行在浏览器环境下，必须通过工具转换成标准的 ES5。 AMD 也是一种 JavaScript 模块化规范，与 CommonJS 最大的不同在于它采用异步的方式去加载依赖的模块。 AMD 规范主要是为了解决针对浏览器环境的模块化问题，最具代表性的实现是 requirejs。AMD 的优点在于： 可在不转换代码的情况下直接在浏览器中运行； 可异步加载依赖； 可并行加载多个依赖； 代码可运行在浏览器环境和 Node.js 环境下。 AMD 的缺点在于JavaScript 运行环境没有原生支持 AMD，需要先导入实现了 AMD 的库后才能正常使用。 TypeScript 的缺点在于语法相对于 JavaScript 更加啰嗦，并且无法直接运行在浏览器或 Node.js 环境下。Flow 也是 JavaScript 的一个超集，它的主要特点是为 JavaScript 提供静态类型检查，和 TypeScript 相似但更灵活，可以让你只在需要的地方加上类型检查。 构建工具构建就是做这件事情，把源代码转换成发布到线上的可执行 JavaScrip、CSS、HTML 代码，包括如下内容。 代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等。 文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。 代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。 模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。 自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。 代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。 自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。 webpack配置webpack官方提供的配置方法是通过module.exports返回一个json，但是这种场景不灵活，不能适配多种场景。最佳方式：1、两份配置文件webpack.config.production.js/webpack.config.development.js，然后不同场景下，使用不同的配置文件。2、通过module.exports返回函数，该函数能接受参数。 1234567891011121314151617181920212223module.exports = function(env) &#123; return &#123; context: config.context, entry: config.src, output: &#123; path: path.join(config.jsDest, project), filename: '[name].js', chunkFilename: '[name].[chunkhash:8].js', publicPath: '/assets/' + project + '/' &#125;, devtool: \"eval\", watch: false, profile: true, cache: true, module: &#123; loaders: getLoaders(env) &#125;, resolve: &#123; alias: getAlias(env) &#125;, plugins: getPlugins(env) &#125;;&#125; context：上下文。entry：入口文件，是所有依赖关系的入口，webpack从这个入口开始静态解析，分析模块之间的依赖关系。output：打包输出的配置。devtools：SourceMap选项，便于开发模式下调试。watch：监听模式，增量更新，开发必备！profile：优化。cache：webpack构建的过程中会生成很多临时的文件，打开cache可以让这些临时的文件缓存起来，从而更快的构建。module.loaders：loaders用来对文件做预处理。这样webpack就可以打包任何静态文件。resolve.alias：模块别名，这样可以更方便的引用模块。plugins：webpack的一些内置功能均是以插件的形式提供。 webpack 使用1、命令行调用webpack可以在终端中使用： {extry file}填写入口文件的路径 {destination for bundled file}处填写打包文件的存放路径 填写路径的时候不用添加{}webpack {entry file} {destination for bundled file} （全局模式）node_modules/.bin/webpack app/main.js public/bundle.js （非全局安装的情况） 2、入口与输出模板123456789&#123; entry: [String | Array | Object], // 入口模块 output: &#123; path: String, // 输出路径 filename: String // 输出名称或名称 pattern publicPath: String // 指定静态资源的位置 ... // 其他配置 &#125;&#125; 多个入口文件：eg: entry: [&#39;./src/index.js&#39;, &#39;./vendor/bootstrap.min.js&#39;] 一个入口，多个文件最终 bootstrap 会被追加到打包好的 index.js 中，数组中的最后一个会被 export。 多个打包目标 12345678910&#123; entry: &#123; index: './src/index.js', a: './src/a.js' &#125;, output: &#123; path: './dist/', filename: '[name].js' &#125;&#125; 3、生成Source Maps（使调试更容易）—— devtoolwebpack就可以在打包时为我们生成的source maps，提供了一种对应编译文件和源文件的方法，使得编译后的代码可读性更高，也更容易调试。在webpack的配置文件中配置source maps，需要配置devtool，有四种不同的配置选项： source-map：在一个单独的文件中产生一个完整且功能完全的文件，但它会减慢打包速度 cheap-module-source-map：在一个单独的文件中生成一个不带列映射的map，不带列映射提高了打包速度，但不能对应到具体的列（符号），会对调试造成不便； eval-source-map：使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。其可以在不影响构建速度的前提下生成完整的sourcemap，但对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定不要启用这个选项； cheap-module-eval-source-map：在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点。（cheap-module-eval-source-map方法构建速度更快，但是不利于调试，推荐在大型项目考虑时间成本时使用。） 12345678module.exports = &#123; entry: __dirname + '/app/index.js', output: &#123; path: __dirname + '/public', filename: 'bundle-[hash:7].js' &#125;, devtool: 'eval-source-map'&#125; 4、使用webpack构建本地服务器（webpack-dev-server）—— devServer背景：浏览器监听代码的修改，并自动刷新显示修改后的结果Webpack提供一个可选的本地开发服务器，该本地服务器基于node.js构建先安装：npm install –save-dev webpack-dev-server再配置: devserver contentBase：默认webpack-dev-server会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录 port：设置默认监听端口，默认“8080”； inline：设置为true，当源文件改变时会自动刷新页面； historyApiFallback：若设置true，所有的跳转将指向index.html，在单页应用时有用，它依赖于HTML5 history API 12345678910111213module.exports = &#123; entry: __dirname + '/app/index.js', output: &#123; path: __dirname + '/public', filename: 'bundle-[hash:7].js' &#125;, devtool: 'eval-source-map', devServer: &#123; contentBase: './public', // 本地服务器所加载的页面所在的目录 historyApiFallback: true, // 不跳转 inline: true // 实时刷新 &#125;&#125; 5、loader使用不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理在 webpack 中，通过 loader 可以实现 JSX 、Es6、CoffeeScript 等的转换. 分析转换scss为css 把下一代的JS文件（ES6，ES7)转换为现代浏览器兼容的JS文件 把React的中用到的JSX文件转换为JS文件 ……Loader需要单独安装，并在config.js 中的 modules关键字中进行配置Loader 的配置说明： test：一个用以匹配loaders所处理文件的拓展名的正则表达式（必须） loader：loader的名称（必须） include/exclude:手动添加必须处理的文件/文件夹或屏蔽不需要处理的文件/文件夹（可选） query：为loaders提供额外的设置选项（可选） loader 除了做文件转换以外，还可以创建额外的文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950module: &#123; rules: [ // template loaders &#123; test: /\\.(tpl|html)$/, use: 'html-loader', &#125;, &#123; test: /\\.art$/, use: 'art-template-loader', &#125;, &#123; test: /\\.(hbs|handlebars)$/, use: 'handlebars-loader', &#125;, // picture loader &#123; test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, use: &#123; loader: 'url-loader', query: &#123; limit: 8192, name: 'img/[name].[ext]', &#125;, &#125;, &#125;, // font loader &#123; test: /(\\.(woff2?|eot|ttf|otf)|font.*\\.svg)(\\?.*)?$/, use: &#123; loader: 'url-loader', query: &#123; limit: 8192, name: 'fonts/[name].[ext]', &#125;, &#125;, &#125;, // media file loader &#123; test: /\\.(mp4|3gp|avi|mkv|wmv|mpg|vob|flv|swf|mov|rmvb|mp3|wma|wav|aac|ogg|flac|ape|m4a)$/, use: &#123; loader: 'url-loader', query: &#123; limit: 8192, name: 'media/[name].[ext]', &#125;, &#125;, &#125;, ],&#125; 6、Babel作用：是一个编译 JS 的平台： 使用下一代的 JS 代码（ES6，ES7…），即使这些标准目前并未被当前的浏览器完全的支持； 使用基于 JS 进行了拓展的语言，比如React的JSX；安装：npm install --save-dev babel-core babel-loader babel-preset-es2015 babel-preset-reactBabel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，webpack可以把其不同的包整合在一起使用，对于每一个需要的功能或拓展，你都需要安装单独的包（用得最多的是解析ES6的babel-preset-es2015包和解析JSX的babel-preset-react包）。 7、Babel的配置Babel 可以完全在webpack.config.js中进行配置，但复杂度增加时会单独有.babelrc的配置文件webpack会自动调用.babelrc里的babel配置选项 123456789101112131415161718192021222324252627module.exports = &#123; entry: __dirname + '/app/index.js', output: &#123; path: __dirname + '/public', filename: 'bundle-[hash:7].js' &#125;, devtool: 'eval-source-map', devServer: &#123; contentBase: './public', // 本地服务器所加载的页面所在的目录 historyApiFallback: true, // 不跳转 inline: true // 实时刷新 &#125;, module: &#123; rules: [&#123; test: /(\\.jsx|\\.js)/, use: &#123; loader: 'babel-loader', &#125;, exclude: /node-module/ &#125;] &#125;&#125;// .babelrc&#123; persets: ['es2015', 'react', 'stage-0']&#125; 8、CSS moduleCSS modules 的技术：把JS的模块化思想带入CSS中来，通过CSS模块，所有的类名，动画名默认都只作用于当前模块。Webpack从一开始就对CSS模块化提供了支持，在CSS loader中进行配置后。首先把”modules“传递到所需要的地方然后就可以直接把CSS的类名传递到组件的代码中好处：这样做只对当前组件有效，不必担心在不同的模块中使用相同的类名造成冲突。 9、CSS预处理器 / PostCSS / autoprefixerSass 和 Less 之类的预处理器是对原生CSS的拓展，它们允许使用类似于variables, nesting, mixins, inheritance等不存在于CSS中的特性来写CSS。在webpack里使用loader进行配置：less-loader、sass-loader、style-loader PostCSS 是一个允许使用 JS 插件转换样式的工具。 这些插件可以检查（lint）你的 CSS，支持 CSS Variables 和 Mixins，CSS 自动加前缀、使用下一代 CSS 语法等. 123456789101112131415161718192021222324252627282930313233module.exports = &#123; entry: __dirname + '/app/index.js', output: &#123; path: __dirname + '/public', filename: 'bundle-[hash:7].js' &#125;, devtool: 'eval-source-map', devServer: &#123; contentBase: './public', // 本地服务器所加载的页面所在的目录 historyApiFallback: true, // 不跳转 inline: true // 实时刷新 &#125;, module: &#123; rules: [&#123; test: /(\\.jsx|\\.js)/, use: &#123; loader: 'babel-loader', &#125;, exclude: /node-module/ &#125;, &#123; test: /\\.css$/, use: ['style-loader', 'css-loader', 'postcss-loader'] &#125;] &#125;&#125;// postcss.config.jsmodule.exports = &#123; plugins: [ // 需要使用的插件列表 require('postcss-cssnext') // 使用下一代 CSS 语法编写代码 ]&#125; 10、插件（Plugins）— banner-plugins / HtmlWebpackPlugin / Hot Module Replacement插件（Plugins）是用来拓展Webpack功能，会在整个构建过程中生效，执行相关的任务。loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。 1.banner-plugins: 添加版权声明2.HtmlWebpackPlugin（动态生成入口 html）依据一个简单的index.html模板，生成一个自动引用你打包后的JS文件的新index.html 3.Hot Module Replacement: 允许修改组件代码后，自动刷新实时预览修改后的效果。Hot Module Replacement（HMR）允许修改组件代码后，自动刷新实时预览修改后的效果。配置：1、在webpack配置文件中添加HMR插件；2、在Webpack Dev Server中添加“hot”参数；不过配置完后，JS模块其实还是不能自动热加载的，还需要在JS模块中执行一个Webpack提供的API才能实现热加载。虽然这个API不难使用，但是如果是React模块，使用Babel可以更方便的实现功能热加载。思路： HMR是一个webpack插件，它能在浏览器中实时观察模块修改后的效果，但如果想让它工作，需要对模块进行额外的配置； Babel 有一个叫做react-transform-hrm 的插件，可以在不对React模块进行额外的配置的前提下让HMR正常工作； 11、优化插件 OccurenceOrderPlugin:为组件分配ID，通过这个插件webpack可以分析和优先考虑使用最多的模块，并为它们分配最小的ID（内置插件） UglifyJsPlugin：压缩JS代码；（内置插件） ExtractTextPlugin：分离CSS和JS文件安装ExtractTextPlugin：npm install --save-dev extract-text-webpack-plugin 1234567891011121314151617181920212223242526272829303132333435363738394041424344module.exports = &#123; entry: __dirname + '/app/index.js', output: &#123; path: __dirname + '/public', filename: 'bundle-[hash:7].js' &#125;, devtool: 'eval-source-map', devServer: &#123;&#125;, module: &#123;&#125;, plugins: [ new webpack.BannerPlugins('版权所有，翻版必究'), new HtmlWebpackPlugin(&#123; template: __dirname + '/app/index.tmpl.html', &#125;), new webpack.HotModuleReplacementPlugin(), // 热加载插件 new webpack.optimize.OccurenceOrderPlugin, new webpack.optimize.UglifyJsPlugin, new ExtractTextPlugin('style.css') ]&#125;// .babelrc&#123; 'persets': ['react', 'es2015', 'stage-0'] 'env': &#123; 'devlopment': &#123; 'plugins': [['react-transform', &#123; transform: [&#123; transform:: 'react-transform-hmr', imports: ['react'], locals: ['module'] &#125;] &#125;]] &#125; &#125;&#125;// package.json 'script': &#123; \"test\"': \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"start\": \"webpack\", \"server\": \"webpack-dev-server --open\", \"build\": \"NODE_ENV=production webpack --config ./webpack.config.js --progress\"&#125; HtmlWebpackPlugin 参数说明：123456789101112131415161718new HtmlWebpackPlugin(&#123; template: __dirname + '/app/index.tmpl.html', title: 'Test', filename: 'index.html', inject: 'body', favicon: './images/favico.ico', minify: true, hash: true, cache: false, showErrors: false, xhtml: false, chunks: &#123; head: &#123; entry: 'assets/head_bundle.js', css: ['main.css'] &#125; &#125;&#125;), title: 设置title的名字 filename: 设置这个html的文件名 template:要使用的模块的路径 inject: 把模板注入到哪个标签后， ‘body’, favicon: 给html添加一个favicon， ‘./images/favico.ico’, minify:是否压缩 {…} | false （最新api变动，原来是ture|false) hash:是否hash化 true，false , cache:是否缓存, showErrors:是否显示错误, xhtml:是否自动毕业标签 默认false 12、缓存缓存无处不在，使用缓存的最好方法是保证你的文件名和文件内容是匹配的（内容改变，名称相应改变）解决办法：带hash值 配置说明：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177const path = require('path');module.exports = &#123; // entry 表示 入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。 // 类型可以是 string | object | array entry: './app/entry', // 只有1个入口，入口只有1个文件 entry: ['./app/entry1', './app/entry2'], // 只有1个入口，入口有2个文件 entry: &#123; // 有2个入口 a: './app/entry-a', b: ['./app/entry-b1', './app/entry-b2'] &#125;, // 如何输出结果：在 Webpack 经过一系列处理后，如何输出最终想要的代码。 output: &#123; // 输出文件存放的目录，必须是 string 类型的绝对路径。 path: path.resolve(__dirname, 'dist'), // 输出文件的名称 filename: 'bundle.js', // 完整的名称 filename: '[name].js', // 当配置了多个 entry 时，通过名称模版为不同的 entry 生成不同的文件名称 filename: '[chunkhash].js', // 根据文件内容 hash 值生成文件名称，用于浏览器长时间缓存文件 // 发布到线上的所有资源的 URL 前缀，string 类型 publicPath: '/assets/', // 放到指定目录下 publicPath: '', // 放到根目录下 publicPath: 'https://cdn.example.com/', // 放到 CDN 上去 // 导出库的名称，string 类型 // 不填它时，默认输出格式是匿名的立即执行函数 library: 'MyLibrary', // 导出库的类型，枚举类型，默认是 var // 可以是 umd | umd2 | commonjs2 | commonjs | amd | this | var | assign | window | global | jsonp ， libraryTarget: 'umd', // 是否包含有用的文件路径信息到生成的代码里去，boolean 类型 pathinfo: true, // 附加 Chunk 的文件名称 chunkFilename: '[id].js', chunkFilename: '[chunkhash].js', // JSONP 异步加载资源时的回调函数名称，需要和服务端搭配使用 jsonpFunction: 'myWebpackJsonp', // 生成的 Source Map 文件名称 sourceMapFilename: '[file].map', // 浏览器开发者工具里显示的源码模块名称 devtoolModuleFilenameTemplate: 'webpack:///[resource-path]', // 异步加载跨域的资源时使用的方式 crossOriginLoading: 'use-credentials', crossOriginLoading: 'anonymous', crossOriginLoading: false, &#125;, // 配置模块相关 module: &#123; rules: [ // 配置 Loader &#123; test: /\\.jsx?$/, // 正则匹配命中要使用 Loader 的文件 include: [ // 只会命中这里面的文件 path.resolve(__dirname, 'app') ], exclude: [ // 忽略这里面的文件 path.resolve(__dirname, 'app/demo-files') ], use: [ // 使用那些 Loader，有先后次序，从后往前执行 'style-loader', // 直接使用 Loader 的名称 &#123; loader: 'css-loader', options: &#123; // 给 html-loader 传一些参数 &#125; &#125; ] &#125;, ], noParse: [ // 不用解析和处理的模块 /special-library\\.js$/ // 用正则匹配 ], &#125;, // 配置插件 plugins: [], // 配置寻找模块的规则 resolve: &#123; modules: [ // 寻找模块的根目录，array 类型，默认以 node_modules 为根目录 'node_modules', path.resolve(__dirname, 'app') ], extensions: ['.js', '.json', '.jsx', '.css'], // 模块的后缀名 alias: &#123; // 模块别名配置，用于映射模块 // 把 'module' 映射 'new-module'，同样的 'module/path/file' 也会被映射成 'new-module/path/file' 'module': 'new-module', // 使用结尾符号 $ 后，把 'only-module' 映射成 'new-module'， // 但是不像上面的，'module/path/file' 不会被映射成 'new-module/path/file' 'only-module$': 'new-module', &#125;, alias: [ // alias 还支持使用数组来更详细的配置 &#123; name: 'module', // 老的模块 alias: 'new-module', // 新的模块 // 是否是只映射模块，如果是 true 只有 'module' 会被映射，如果是 false 'module/inner/path' 也会被映射 onlyModule: true, &#125; ], symlinks: true, // 是否跟随文件软链接去搜寻模块的路径 descriptionFiles: ['package.json'], // 模块的描述文件 mainFields: ['main'], // 模块的描述文件里的描述入口的文件的字段名称 enforceExtension: false, // 是否强制导入语句必须要写明文件后缀 &#125;, // 输出文件性能检查配置 performance: &#123; hints: 'warning', // 有性能问题时输出警告 hints: 'error', // 有性能问题时输出错误 hints: false, // 关闭性能检查 maxAssetSize: 200000, // 最大文件大小 (单位 bytes) maxEntrypointSize: 400000, // 最大入口文件大小 (单位 bytes) assetFilter: function(assetFilename) &#123; // 过滤要检查的文件 return assetFilename.endsWith('.css') || assetFilename.endsWith('.js'); &#125; &#125;, devtool: 'source-map', // 配置 source-map 类型 context: __dirname, // Webpack 使用的根目录，string 类型必须是绝对路径 // 配置输出代码的运行环境 target: 'web', // 浏览器，默认 target: 'webworker', // WebWorker target: 'node', // Node.js，使用 `require` 语句加载 Chunk 代码 target: 'async-node', // Node.js，异步加载 Chunk 代码 target: 'node-webkit', // nw.js target: 'electron-main', // electron, 主线程 target: 'electron-renderer', // electron, 渲染线程 externals: &#123; // 使用来自 JavaScript 运行环境提供的全局变量 jquery: 'jQuery' &#125;, stats: &#123; // 控制台输出日志控制 assets: true, colors: true, errors: true, errorDetails: true, hash: true, &#125;, devServer: &#123; // DevServer 相关的配置 proxy: &#123; // 代理到后端服务接口 '/api': 'http://localhost:3000' &#125;, contentBase: path.join(__dirname, 'public'), // 配置 DevServer HTTP 服务器的文件根目录 compress: true, // 是否开启 gzip 压缩 historyApiFallback: true, // 是否开发 HTML5 History API 网页 hot: true, // 是否开启模块热替换功能 https: false, // 是否开启 HTTPS 模式 &#125;, profile: true, // 是否捕捉 Webpack 构建的性能信息，用于分析什么原因导致构建性能不佳 cache: false, // 是否启用缓存提升构建速度 watch: true, // 是否开始 watchOptions: &#123; // 监听模式选项 // 不监听的文件或文件夹，支持正则匹配。默认为空 ignored: /node_modules/, // 监听到变化发生后会等300ms再去执行动作，防止文件更新太快导致重新编译频率太高 // 默认为300ms aggregateTimeout: 300, // 判断文件是否发生变化是不停的去询问系统指定文件有没有变化，默认每秒问 1000 次 poll: 1000 &#125;,&#125;","categories":[{"name":"构建","slug":"构建","permalink":"http://yoursite.com/categories/构建/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"Object 创建/修改/获取属性的方法","slug":"[JS] 创建、修改、获取属性的方法","date":"2018-09-26T10:08:12.000Z","updated":"2018-10-08T02:21:39.000Z","comments":true,"path":"2018/09/26/[JS] 创建、修改、获取属性的方法/","link":"","permalink":"http://yoursite.com/2018/09/26/[JS] 创建、修改、获取属性的方法/","excerpt":"","text":"Object.defineProperty(obj, prop, descriptor)会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。若不指定configurable, writable, enumerable ，则这些属性默认值为false；若不指定value, get, set，则这些属性默认值为undefined。 obj: 需要被操作的目标对象 prop: 目标对象需要定义或修改的属性的名称 descriptor: 将被定义或修改的属性的描述符 12345678var obj = new Object();Object.defineProperty(obj, 'name', &#123; configurable: false, writable: true, enumerable: true, value: '张三'&#125;)console.log(obj.name) //张三 Object.defineProperties(obj, props)直接在一个对象上定义一个或多个新的属性或修改现有属性，并返回该对象。 props: 该对象的一个或多个键值对定义了将要为对象添加或修改的属性的具体配置。 1234567891011121314var obj = new Object();Object.defineProperties(obj, &#123; name: &#123; value: '张三', configurable: false, writable: true, enumerable: true &#125;, age: &#123; value: 18, configurable: true &#125;&#125;);console.log(obj.name, obj.age) // 张三, 18 在不支持 Object.defineProperties() 方法的浏览器中不能修改[[configurable]]和[[enumerable]]。 Object.getOwnPropertyDescriptor(obj, prop)返回指定对象上一个自有属性对应的属性描述符。 prop: 目标对象内属性名称。 123456789101112var person = &#123; name: '张三', age: 18&#125;;var desc = Object.getOwnPropertyDescriptor(person, 'name'); console.log(desc);// &#123;// configurable: true,// enumerable: true,// writable: true,// value: \"张三\"// &#125; Object.getOwnPropertyDescriptors(obj, prop)所指定对象的所有自身属性的描述符，如果没有任何自身属性，则返回空对象。返回值是一个对象，若是访问器属性，该对象有Configurable、Enumberable、Get和set；若是数据属性，该对象有Configurable、Enumberable、Writable和Value； 123456789101112131415161718192021222324252627282930var book = &#123;&#125;;Object.defineProperties(book, &#123; _year: &#123; value: 2004 &#125;, edition: &#123; value: 1 &#125;, year: &#123; get: function() &#123; return this._year; &#125;, set: function(newValue) &#123; if(newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125; &#125;&#125;);var descriptor = Object.getOwnPropertyDescriptors(book, '_year');descriptor.value; // 2004descriptor.configurable; // falsetypeof descriptor.get; // undefinedvar desc = Object.getOwnPropertyDescriptors(book, 'year');descriptor.value; // undefineddescriptor.enumberable; // falsetypeof descriptor.get; // function 补充说明在调用 Object.defineProperty() 方法时，如果不指定，configrubale、enumerable和writable 默认都为false。 configrubale设置configrubale属性为false，则不可使用delete操作符(在严格模式下抛出错误), 修改所有内部属性值会抛出错误。 enumerablewritableget 和 set","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JS基础总结","slug":"[JS] JS基础总结","date":"2018-09-26T06:48:21.000Z","updated":"2018-11-01T14:13:05.190Z","comments":true,"path":"2018/09/26/[JS] JS基础总结/","link":"","permalink":"http://yoursite.com/2018/09/26/[JS] JS基础总结/","excerpt":"","text":"目录：一、JS 中的数据类型二、JS 中类型检测三、$.extend()和$.fn.extend()四、jquery的事件绑定on、bind、dele五、defer和async六、module.exports和export的区别七、Promise八、JS中正则表达式的使用九、数组十、前端的各种排序十一、列举HTML5新特性十二、列举Css3新特性十三、页面渲染机制十四、原生JS中forEach和Map区别十五、arguments十六、decodeURI、decodeURIComponent、encodeURI、encodeURIComponent十七、JS中宽高各属性介绍十八、Navigator对象十九、从浏览器地址栏输入url到显示页面的步骤(以HTTP为例))二十、什么闭包,闭包有什么用二十一、jquery中链式调用原理 一、JS 中的数据类型JavaScript 有 5 种简单数据类型：Undefined、Null、Boolean、Number、String 和 1 种复杂数据类型 Object 。基本类型（值类型）：Undefined、Null、Boolean、Number、String复杂类型（引用类型）：Object、Array、Date、RegExp、Function、基本包装类型（Boolean | Number | String）、单体内置对象（Global | Math）。类型检测：typeof、instanceof、Object.prototype.toString.call()； 值类型与引用类型的差别: 基本类型在内存中占据固定大小的空间，因此被保存在栈内存中; 从一个变量向另一个变量复制基本类型的值，复制的是值的副本; 引用类型的值是对象，保存在堆内存; 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针; 从一个变量向另一个变量复制引用类型的值的时候，复制是引用指针，因此两个变量最终都指向同一个对象。 二、JS中类型检测在JavaScript里使用typeof判断数据类型，只能区分基本类型，即：number、string、undefined、boolean、object。对于null、array、function、object来说，使用typeof都会统一返回object字符串。 要想区分对象、数组、函数、单纯使用typeof是不行的。在JS中，可以通过Object.prototype.toString方法，判断某个对象之属于哪种内置类型。分为null、string、boolean、number、undefined、RegExp、array、function、object、date、math。 判断原生JSON对象: window.JSON &amp;&amp; Object.prototype.toString.call(JSON) 输出结果为”[object JSON]”说明JSON是原生的，否则不是。注意：Object.prototpye.toString()本身也可能会被修改 对于自定义的函数，可以使用 instanceof判断，判断一个实例是否属于某种类型。console.log(person instanceof Person); 三、$.extend和$.fn.extend extend(dest,src1,src2,src3...): 将src1,src2,src3…合并到dest中,返回值为合并后的dest,修改了dest的结构。 $.extend({},src1,src2,src3...) // 也就是将”{}”作为dest参数，不修改dest的结构。 12// 后面的参数如果和前面的参数存在相同的名称，那么后面的会覆盖前面的参数值。$.extend(&#123;&#125;,&#123;name:\"Tom\",age:21&#125;,&#123;name:\"Jerry\",sex:\"Boy\"&#125;); // &#123;name:\"Jerry\",age:21,sex:\"Boy\"&#125; 省略 dest 参数$.extend(src): 将src合并到jquery的全局对象中去。 123456// 将hello方法合并到jquery的全局对象中$.extend(&#123; hello: function() &#123; alert('hello'); &#125;&#125;); $.fn.extend(src): 将src合并到jquery的实例对象中去 ($.fn=jquery.prototype) 1234567// 这是在jquery全局对象中扩展一个net命名空间。$.extend(&#123;net:&#123;&#125;&#125;); // 这是将hello方法扩展到之前扩展的Jquery的net命名空间中去$.extend($.net, &#123; hello:function()&#123;alert('hello');&#125;&#125;); extend方法还有一个重载原型：extend(boolean,dest,src1,src2,src3...): boolean代表是否进行深度拷贝。 12345678var result=$.extend( true, &#123;&#125;, &#123; name:\"John\", location: &#123;city: \"Boston\",county:\"USA\"&#125; &#125;, &#123; last:\"Resig\", location: &#123;state: \"MA\",county:\"China\"&#125; &#125; );// result = &#123;name:\"John\",last:\"Resig\",location:&#123;city:\"Boston\",state:\"MA\",county:\"China\"&#125;&#125;var result=$.extend( false, &#123;&#125;, &#123; name:\"John\", location:&#123;city: \"Boston\",county:\"USA\"&#125; &#125;, &#123; last:\"Resig\", location: &#123;state: \"MA\",county:\"China\"&#125; &#125;);// result = &#123;name:\"John\",last:\"Resig\",location:&#123;state:\"MA\",county:\"China\"&#125;&#125; 四、jquery的事件绑定on、bind、dele sdas 五、defer和asyncdefer可以让脚本在文档完全呈现之后再执行，延迟脚本总是按照指定它们的顺序执行。async可表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚本按照它们在页面中出现的顺序执行。 六、module.exports和export的区别模块化：公共代码抽离成为一个单独的js文件，作为一个模块，模块只有通过module.exports 和 exports 才能对外暴露接口。区别： exports 是指向的module.exports 的引用； module.exports 初始值为一个空对象{}，所以exports 初始值也是{}； require() 返回的是module.exports 而不是exports。 七、PromisePromise代表了某个未来才会知道结果的事件（通常是一个异步操作），可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。Promise对象有三种状态：pending状态（ 等待中），fulfilled状态（操作完成的状态），rejected状态（操作失败的状态），状态不受外界影响，一旦状态改变，就不会再变。 基本的API有： Promise.resolve() Promise.reject() Promise.prototype.then() Promise.prototype.catch() Promise.all() Promise.race() 常见使用场景：ajax请求，定时器，数据验证，动画结束回调，多重回调解耦等。 八、JS中正则表达式的使用 String.prototype.search方法。eg：”abchello”.search(/hello/); // 3 String.prototype.replace方法。eg：”abchello”.replace(/hello/,”hi”); // “abchi” String.prototype.split方法。 eg: “abchelloasdasdhelloasd”.split(/hello/); //[“abc”, “asdasd”, “asd”] String.prototype.match方法。 eg:用来捕获字符串中的子字符串到一个数组中。默认情况下只捕获一个结果到数组中。eg： “abchelloasdasdhelloasd”.match(/hello/); //[“hello”] “abchelloasdasdhelloasd”.match(/hello/g); //[“hello”,”hello”] RegExp.prototype.exec方法。1、exec方法一次只能捕获一份子字符串到数组中，无论正则表达式是否有全局属性eg: /hello/g.exec(&quot;abchelloasdasdhelloasd&quot;); // [“hello”]2、正则表达式对象有一个lastIndex属性，用来表示下一次从哪个位置开始捕获，每一次执行exec方法后，lastIndex就会往后推，直到找不到匹配的字符返回null，然后又从头开始捕获。 这个属性可以用来遍历捕获字符串中的子串。 12345678var reg=/hello/g;reg.lastIndex; //0reg.exec(\"abchelloasdasdhelloasd\"); // [\"hello\"]reg.lastIndex; //8reg.exec(\"abchelloasdasdhelloasd\"); // [\"hello\"]reg.lastIndex; //19reg.exec(\"abchelloasdasdhelloasd\"); // nullreg.lastIndex; //0 RegExp.prototype.test方法: 用来测试字符串中是否含有子字符串eg: /hello/.test(“abchello”); // true 九、数组 Array.prototype.flat(depth)（扁平化数组）会递归到指定深度将所有子数组连接，并返回一个新数组。depth 指定嵌套数组中的结构深度，默认值为11234567891011var arr1 = [1, 2, [3, 4]];arr1.flat(); // [1, 2, 3, 4]var arr2 = [1, 2, [3, 4, [5, 6]]];arr2.flat(); // [1, 2, 3, 4, [5, 6]]var arr3 = [1, 2, [3, 4, [5, 6]]];arr3.flat(2); // [1, 2, 3, 4, 5, 6]var arr4 = [1, 2, , 4, 5];arr4.flat(); // [1, 2, 4, 5] 会移除数组中的空项 十、前端的各种排序 快速排序思想： 1、找基准（一般是以中间项为基准）；2、遍历数组，小于基准的放在left，大于基准的放在right；3、递归 12345678910111213141516171819202122232425var times = 0;function quickSort(arr) &#123; //如果数组&lt;=1,则直接返回 if(arr.length &lt;= 1)&#123; return arr; &#125; var pivotIndex = Math.floor(arr.length/2); //找基准，并把基准从原数组删除 var pivot = arr.splice(pivotIndex,1)[0]; //定义左右数组 var left = []; var right = []; //比基准小的放在left，比基准大的放在right for(var i=0; i&lt;arr.length; i++) &#123; if(arr[i] &lt;= pivot) &#123; left.push(arr[i]); &#125; else&#123; right.push(arr[i]); &#125; console.log(\"第\"+(++times)+\"次排序后：\"+arr); &#125; //递归 return quickSort(left).concat([pivot],quickSort(right));&#125;// 数组长度10，排序次数22次。 冒牌排序思想： 每一次对比相邻两个数据的大小，小的排在前面，如果前面的数据比后面的大就交换这两个数的位置 12345678910111213141516var times=0;function(arr)&#123; for(var i = 0;i &lt; arr.length-1; i++) &#123; for(var j = i + 1;j &lt; arr.length; j++) &#123; if(arr[i] &gt; arr[j]) &#123; //如果前面的数据比后面的大就交换 var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; console.log(\"第\"+(++times)+\"次排序后：\"+arr); &#125; &#125; return arr;&#125;// 数组长度10，排序次数45次。 选择排序思想：每次选择最小的数，将最小的数记录下来，然后排到最前面 十一、列举HTML5新特性 语意化标签(nav、aside、dialog、header、footer等) canvas 拖放相关api Audio、Video 获取地理位置 更好的input校验 web存储(localStorage、sessionStorage) webWorkers(类似于多线程并发) webSocket 十二、列举Css3新特性 选择器 边框(border-image、border-radius、box-shadow) 背景(background-clip、background-origin、background-size) 渐变(linear-gradients、radial-gradents) 字体(@font-face) 转换、形变(transform) 过度(transition) 动画(animation) 弹性盒模型(flex-box) 媒体查询(@media) 十三、页面渲染机制1.CSS加载会阻塞DOM树吗？1234567891011121314151617181920&lt;head&gt; &lt;title&gt;css阻塞&lt;/title&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;style&gt; h1 &#123; color: red !important &#125; &lt;/style&gt; &lt;script&gt; function h () &#123; console.log(document.querySelectorAll('h1')) &#125; setTimeout(h, 0) &lt;/script&gt; &lt;link href=\"https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css\" rel=\"stylesheet\"&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;这是红色的&lt;/h1&gt;&lt;/body&gt; 由上图可以看出，控制台已打出console.log，说明此时的h1已经被解析，但是并没有显示。 解释：是浏览器的一种优化机制。因为加载css时，可能会修改下面DOM节点的样式，如果css加载不阻塞DOM树渲染的话，那么当css加载完之后，DOM树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。所以就先把DOM树的结构先解析完，把可以做的工作做完，然后等css加载完之后，在根据最终的样式来渲染DOM树。 css加载不会阻塞DOM树解析，但是会阻塞DOM树渲染 2.css加载会阻塞js运行吗？123456789101112131415161718&lt;head&gt; &lt;title&gt;css阻塞&lt;/title&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;script&gt; console.log('before css') var startDate = new Date() &lt;/script&gt; &lt;link href=\"https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css\" rel=\"stylesheet\"&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;这是红色的&lt;/h1&gt; &lt;script&gt; var endDate = new Date() console.log('after css') console.log('经过了' + (endDate -startDate) + 'ms') &lt;/script&gt;&lt;/body&gt; 可以看出，css之前的js代码已经解析完毕，但是css之后的js等到css加载完才执行。 css加载会阻塞后面的js语句的执行css会阻塞Dom渲染和js执行，而js会阻塞Dom解析 提高css加载速度的方法： 使用CDN(因为CDN会根据你的网络状况，替你挑选最近的一个具有缓存内容的节点为你提供资源，因此可以减少加载时间) 对css进行压缩(可以用很多打包工具，比如webpack,gulp等，也可以通过开启gzip压缩) 合理的使用缓存(设置cache-control,expires,以及E-tag都是不错的，不过要注意一个问题，就是文件更新后，你要避免缓存而带来的影响。其中一个解决防范是在文件名字后面加一个版本号) 减少http请求数，将多个css文件合并，或者是干脆直接写成内联样式(内联样式的一个缺点就是不能缓存) 3. 说明上述的原因不用浏览器使用的内核不同，目前主要有两个：webkit渲染过程Gecko渲染过程 从上面两个流程图我们可以看出来，浏览器渲染的流程如下： HTML解析文件，生成DOM Tree，解析CSS文件生成CSSOM Tree 将Dom Tree和CSSOM Tree结合，生成Render Tree(渲染树) 根据Render Tree渲染绘制，将像素渲染到屏幕上。 因此： 1. DOM解析和CSS解析是两个并行的进程，所以这也解释了为什么CSS加载不会阻塞DOM的解析。2. 然而，由于Render Tree是依赖于DOM Tree和CSSOM Tree的，所以他必须等待到CSSOM Tree构建完成，也就是CSS资源加载完成(或者CSS资源加载失败)后，才能开始渲染。因此，CSS加载是会阻塞Dom的渲染的。3. 由于js可能会操作之前的Dom节点和css样式，因此浏览器会维持html中css和js的顺序。因此，样式表会在后面的js执行前先加载执行完毕。所以css会阻塞后面js的执行。 4.DOMContentLoaded对于浏览器来说，页面加载主要有两个事件，一个是 DOMContentLoaded ，另一个是 onLoad 。onLoad: 等待页面的所有资源都加载完成才会触发，css、js、图片视频DOMContentLoaded: 当页面的内容解析完成后，则触发该事件 十四、原生JS中forEach和Map区别 十五、argumentsarguments 是一个类数组对象。代表传给一个function的参数列表。1、其包含一个 length 属性，可以用 arguments.length 来获得传入函数的参数个数；2、arguments 转数组的方法 Array.prototype.slice.call(arguments); [].slice.call(arguments);slice 方法得到的结果是一个数组，参数便是 arguments。事实上，满足一定条件的对象都能被 slice 方法转换成数组。条件就是： 1)、属性为 0，1，2…； 2）、具有 length 属性； 十六、decodeURI、decodeURIComponent、encodeURI、encodeURIComponent12345var test1=\"http://www.wljcz.com/My first/\";encodeURI(test1); // http://www.wljcz.com/My%20first/encodeURIComponent(test1); // http%3A%2F%2Fwww.wljcz.com%2FMy%20first%2FdecodeURI(encodeURI(test1));decodeURIComponent(encodeURIComponent(test1)); 十七、JS中宽高各属性介绍网页可见区域宽： document.body.clientWidth;网页可见区域高： document.body.clientHeight;网页可见区域宽： document.body.offsetWidth (包括边线的宽);网页可见区域高： document.body.offsetHeight (包括边线的宽);网页正文全文宽： document.body.scrollWidth;网页正文全文高： document.body.scrollHeight;网页被卷去的高： document.body.scrollTop;网页被卷去的左： document.body.scrollLeft;网页正文部分上： window.screenTop;网页正文部分左： window.screenLeft;屏幕分辨率的高： window.screen.height;屏幕分辨率的宽： window.screen.width;屏幕可用工作区高度： window.screen.availHeight; 十八、Navigator对象appCodeName: 返回浏览器的代码名。appMinorVersion: 返回浏览器的次级版本。appName: 返回浏览器的名称。appVersion: 返回浏览器的平台和版本信息。browserLanguage: 返回当前浏览器的语言。cookieEnabled: 返回指明浏览器中是否启用 cookie 的布尔值。cpuClass: 返回浏览器系统的 CPU 等级。onLine: 返回指明系统是否处于脱机模式的布尔值。platform: 返回运行浏览器的操作系统平台。systemLanguage: 返回 OS 使用的默认语言。userAgent: 返回由客户机发送服务器的 user-agent 头部的值。(使用的比较多: PC还是移动端；安卓还是IOS；浏览器的类型)userLanguage: 返回 OS 的自然语言设置。12345678910111213141516171819202122var browser=&#123; versions:function()&#123; var u = navigator.userAgent, app = navigator.appVersion; return &#123; // 移动终端浏览器版本信息 trident: u.indexOf('Trident') &gt; -1, // IE内核 presto: u.indexOf('Presto') &gt; -1, // opera内核 webKit: u.indexOf('AppleWebKit') &gt; -1, // 苹果、谷歌内核 gecko: u.indexOf('Gecko') &gt; -1 &amp;&amp; u.indexOf('KHTML') == -1, // 火狐内核 mobile: !!u.match(/AppleWebKit.*Mobile.*/), // 是否为移动终端 ios: !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/), // ios终端 android: u.indexOf('Android') &gt; -1 || u.indexOf('Linux') &gt; -1, // android终端或uc浏览器 iPhone: u.indexOf('iPhone') &gt; -1, // 是否为iPhone或者QQHD浏览器 iPad: u.indexOf('iPad') &gt; -1, // 是否iPad webApp: u.indexOf('Safari') == -1 // 是否web应该程序，没有头部与底部 &#125;; &#125;(), language:(navigator.browserLanguage || navigator.language).toLowerCase()&#125;if(browser.versions.mobile)&#123; console.log('我是移动端'); &#125; 123456789const ua = navigator.userAgent;const isWindowsPhone = /(?:Windows Phone)/.test(ua);const isSymbian = /(?:SymbianOS)/.test(ua) || isWindowsPhone;const isAndroid = /(?:Android)/.test(ua);const isFireFox = /(?:Firefox)/.test(ua);// const isChrome = /(?:Chrome|CriOS)/.test(ua);const isTablet = /(?:iPad|PlayBook)/.test(ua) || (isAndroid &amp;&amp; !/(?:Mobile)/.test(ua)) || (isFireFox &amp;&amp; /(?:Tablet)/.test(ua));const isPhone = /(?:iPhone)/.test(ua) &amp;&amp; !isTablet;const isPc = !isPhone &amp;&amp; !isAndroid &amp;&amp; !isSymbian; 十九、从浏览器地址栏输入url到显示页面的步骤(以HTTP为例) 在浏览器地址栏输入URL; 浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤如果资源未缓存，发起新请求;如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。检验新鲜通常有两个HTTP头进行控制Expires和Cache-Control： HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期; HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间. 浏览器解析URL获取协议，主机，端口，path 浏览器组装一个HTTP（GET）请求报文 浏览器获取主机ip地址，过程如下：浏览器缓存、本机缓存、hosts文件、路由器缓存、ISP DNS缓存、DNS递归查询（可能存在负载均衡导致每次IP不一样） 打开一个socket与目标IP地址，端口建立TCP链接，三次握手如下：1、客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口；2、服务器发回SYN=1， ACK=X+1， Seq=Y的响应包；3、客户端发送ACK=Y+1， Seq=Z。 TCP链接建立后发送HTTP请求 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序 服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码 处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作 服务器将响应报文通过TCP连接发送回浏览器 浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下：1、主动方发送Fin=1， Ack=Z， Seq= X报文；2、被动方发送ACK=X+1， Seq=Z报文； 3、被动方发送Fin=1， ACK=X， Seq=Y报文； 4、主动方发送ACK=Y， Seq=X报文 浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同 如果资源可缓存，进行缓存 对响应进行解码（例如gzip压缩） 根据资源类型决定如何处理（假设资源为HTML文档） 解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本，这些操作没有严格的先后顺序，以下分别解释 构建DOM树：1、Tokenizing：根据HTML规范将字符流解析为标记；2、Lexing：词法分析将标记转换为对象并定义属性和规则；3、DOM construction：根据HTML标记关系将对象组成DOM树。 解析过程中遇到图片、样式表、js文件，启动下载 构建CSSOM树：1、Tokenizing：字符流转换为标记流；2、Node：根据标记创建节点；3、CSSOM：节点创建CSSOM树 根据DOM树和CSSOM树构建渲染树:1、从DOM树的根节点遍历所有可见节点，不可见节点包括：1）script,meta这样本身不可见的标签。2)被css隐藏的节点，如display: none；2、对每一个可见节点，找到恰当的CSSOM规则并应用；3、发布可视节点的内容和计算样式 js解析如下：1、浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading；2、HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容；3、当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素；4、当文档完成解析，document.readState变成interactive；5、所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用document.write()；6、浏览器在Document对象上触发DOMContentLoaded事件；7、此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete,window触发load事件。 显示页面（HTML解析过程中会逐步显示页面） 二十、什么闭包,闭包有什么用闭包是在某个作用域内定义的函数，它可以访问这个作用域内的所有变量。闭包作用域链通常包括三个部分：1、函数本身作用域。2、闭包定义时的作用域。3、全局作用域。 闭包常见用途：1、创建特权方法用于访问控制2、事件处理程序及回调 二十一、jquery中链式调用原理二十二、this的指向1、普通函数指向函数的调用者:有个简便的方法就是看函数前面有没有点,如果有点,那么就指向点前面的那个值;2、箭头函数指向函数所在的所用域: 注意理解作用域,只有函数的{}构成作用域,对象的{}以及 if(){}都不构成作用域;1234567891011const obj = &#123; name: 'objName', say() &#123; console.log(this.name); &#125;, read: () =&gt; &#123; console.log(this.name); &#125;&#125;obj.say(); // objNameobj.read(); // undefined 浏览器默认的this为window; node.js中全局环境默认this为{},普通函数中默认this为global","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JS高级程序设计","slug":"[JS] JS高级程序设计","date":"2018-09-26T06:48:21.000Z","updated":"2018-10-31T16:04:24.442Z","comments":true,"path":"2018/09/26/[JS] JS高级程序设计/","link":"","permalink":"http://yoursite.com/2018/09/26/[JS] JS高级程序设计/","excerpt":"","text":"目录：chap5、引用类型chap6、面向对象 chap5、引用类型引用类型是一种数据结构，用于将数据和功能组织在一起。 Object类型可以使用.点和[]进行访问对象属性，没有任何去边，但方括号的主要优点：可以通过变量来访问属性。若属性名中包含关键字或保留字或导致语法错误的字符，可以使用方括号表示法。除非必须使用变量来访问属性，否则建议使用点表示法 Array类型Array构造函数时可以省略new操作符，const color = new Array(3); const color = Array(3);数组的length并不是只读的，可以被设置。 123456const color = ['red', 'green', 'blue'];color.length = 2;console.log(color[2]); // undefined，会被删除color.length = 4;console.log(color[3]); // undefined，会被添加 Array类型方法 转换方法：所有对象都具有toLocaleString()、toString()和valueod()方法。valueOf()函数用于返回指定对象的原始值；toString()函数用于返回指定对象的字符串； 对象 valueOf() 返回值 toString() 返回值 Number 数字值(number) 数字值(string) String 字符串值 字符串值 Boolean 布尔值 字符串值 Object 对象本身 字符串值 Function 函数本身 字符串值 Date 以毫秒数存储的时间值(number) 标准时间输出(string) 若数组中的某一项的值是null或undefined，在join()、toLocaleString()、toString()、valueof()方法返回的结果中以空字符串表示。 队列方法(数组：先进后出)：shift(): 取出（删除）数组的第一项，最开始的头部unshift()：添加一项至数组的第一项头部push()：添加一项至数组的第一项尾部pop()：取出（删除）数组的最后一项目，尾部 操作方法：concat()：无参数时，复制当前数组并返回；参数为一个或多个数组，将数组汇总的每一项都添加到结果数组中。slice()：返回项的起始和结束位置。该函数不影响原是数组。若slice的参数为负数，则用长度去减，若结束位置小于起始位置，则返回空数组。eg：slice(-2, -1)的长度为5的数组调用后为 slice(3,4);splice()：向数组的中部插入项，实现删除、插入和替换。 删除：splice(起始位置，项数); 插入：splice(起始位置，0，要插入的项，要插入的项，要插入的项，…); 替换：splice(起始位置，项数，要插入的项，要插入的项，要插入的项，…);删除后再添加 位置方法：indexOf(查找项，查找起点位置的索引)从数组的开头开始（位置0）向后查找。lastIndexOf(查找项，查找起点位置的索引)从数组的末尾开始向前查找。 迭代方法：every()：数组中的每一项都必须满足条件，才返回truefilter()：过滤forEach()：遍历循环map()：遍历循环some()：数组中的只要有满足条件的，就返回true1234567891011121314151617181920const numbers = [1,2,3,4,5,4,3,2,1];const everyResult = numbers.every((item, index, array) =&gt; &#123; return (item &gt; 2);&#125;);// everyResult 结果为： falseconst someResult = numbers.every((item, index, array) =&gt; &#123; return (item &gt; 2);&#125;);// someResult 结果为： trueconst filterResult = numbers.every((item, index, array) =&gt; &#123; return (item &gt; 2);&#125;);// filterResult 结果为： [3,4,5,4,3]const mapResult = numbers.every((item, index, array) =&gt; &#123; return (item &gt; 2);&#125;);// mapResult 结果为： [2,4,6,8,10,8,6,4,2] 缩小方法：reduce(函数，缩小基础的初始值)和reduceRight(函数，缩小基础的初始值)都会迭代数组的所有项，reduceRight是从最后一项开始。123const val = [1,2,3,4,5];// 前一个值、当前值、项的索引和数组对象val.reduce((prev, cur, index, array) =&gt; &#123;&#125;); Function类型arguments（保存函数参数）为类数组对象，包含着传入函数中的所有参数。callee 为一个指针，指向拥有这个arguments对象的函数。this 函数据以执行的环境对象。 12345// 阶乘函数的递归算法function factorial(num) &#123; return num &lt;= 1 ? 1 : num * arguments.callee(num-1);&#125;// 利用callee 松散耦合 apply和 call 都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。能够扩充函数赖以运行的作用域apply(运行函数的作用域，参数数组Array / arguments))call(运行函数的作用域，参数1，参数2，....)123456789101112131415161718192021222324252627282930function sum(num1, num2) &#123; return num1 + num2;&#125;function applySum(num1, num2) &#123; return sum.apply(this, arguments);&#125;// 因为在非严格的全局调用，this指向window，严格模式下，this为undefined。// 除非明确把函数添加到某个对象或者调用者console.log(applySum(10,10)); // 20function callSum(num1, num2) &#123; return sum.call(this, ...arguments);&#125;console.log(callSum(10,10)); // 20window.color = 'red';const o = &#123; color: 'blue' &#125;;function sayColor() &#123; console.log(this.color);&#125;sayColor(); // redsayColor.call(this); // redsayColor.call(window); // redsayColor.call(o); // blue 此时this指向对象o// this值会被绑定到传给bind() 函数的值const objSaycolor = sayColor.bind(o);objSaycolor(); // blue 基本包装类型toFixed() 返回字符串类型；toExponential() 指数表示法表示的数值的字符串形式；charAt(0开始的字符位置)：该位置对应的字符；charCodeAt(0开始的字符位置)：该位置对应的字符编码；concat()：将一或多个字符串拼接起来，返回新的；slice()、substr()和substring()：裁剪字符串； 12345678// 负数时，存在差异const stringVal = 'hello world';console.log(stringVal.slice(-3)); // 'rld'console.log(stringVal.substring(-3)); // 'hello world'console.log(stringVal.substr(-3)); // 'rld'console.log(stringVal.slice(3, -4)); // 'lo w'console.log(stringVal.substring(3, -4)); // 'hel'console.log(stringVal.substr(3, -4)); // '' trim() 创建一个字符串副本，删除前置及后缀的所有空格。match()：模式匹配方法，类似于RegExp和 exec()12345678const text = 'cat, bat, sat, fat';const pattern = /.at/;const result = text.match(pattern); // [\"cat\", index: 0, input: \"cat, bat, sat, fat\", groups: undefined]const result = pattern.exec(text) // [\"cat\", index: 0, input: \"cat, bat, sat, fat\", groups: undefined]const result = text.search(/at/); // 1const result = text.replace('at', 'ond'); // \"cond, bat, sat, fat\"const result = text.replace(/at/g, 'ond'); // \"cond, bond, sond, fond\"const result = text.replace(/(.at)/g, 'word($1)'); // \"word(cat), word(bat), word(sat), word(fat)\" split() 基于指定的分隔符将一个字符串分割成多个子字符串；localeCompare()比较两个字符串，返回与字符串在字母表中的排序有关，靠前，返回1，否则-1，相同为0；const stringVal = ‘yellow’;stringVal.localeCompare(‘brick’); // 1fromCharCode()：接收一或多个字符编码，并转换成字符串；String.fromCharCode(104, 101, 108, 108, 111); // hello chap6、面向对象 对象的属性类型ECMAScript中有两种属性：数据属性和访问器属性。数据属性包含一个数据值的位置，可以读取和写入值。数据属性有4个描述其行为的特性：[[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。默认值为true；[[Enumberable]]：表示能否通过 for-in 循环返回属性。默认值为true；[[Writable]]：表示能否修改属性的值。[[Value]]：包含这个属性的数据值，读取属性值时，从这个位置读，写入属性值时，把新值保存在这个位置。 123const person = &#123; name: 'ruby'&#125; 要修改属性默认的特性，需要使用 Object.defineProperty()（见“Object 创建/修改/获取属性的方法”）。 访问器属性不包含数据值，包含 getter 和 setter 函数。访问器属性有4个特性：[[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。默认值为true；[[Enumberable]]：表示能否通过 for-in 循环返回属性。默认值为true；[[Get]]：在读取属性时调用的函数，默认为undefined。[[Set]]：在写入属性时调用的函数，默认为undefined。 访问器属性不能直接定义，必须使用Object.defineProperties()来定义。 工厂模式：一个方法，1、显示化创建一个对象；2、方法和属性都定义在这个对象上；3、return解决了：创建多个相似对象的问题问题：没有解决对象相识问题（怎么知道一个对象的类型） 构造函数模式：属性和方法都在构造函数中问题：每个方法都要在每个实例上重新创建一遍（函数定义在构造函数的内部），这种方法创建函数，会导致不同的作用域链和标识符解析。采用方法：将方法写到全局中，构造函数内部只需要调用一次。（内部由this辨别不同的对象，将方法提出到公共中定义）问题：在全局作用域中定义的函数实际上只能被某个对象调用，让全局作用域失去意义，并且当定义很多方法时，会失去封装的意义。解决办法：原型模式补充：每个实例化的对象，都有constructor（构造函数）属性指向对象。 原型模式每个函数都有一个prototype原型属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。Prototype就是通过调用构造函数而创建的那个对象实例的原型对象。优点：可以让所有对象实例共享它所包含的属性和方法。不必在构造函数中定义对象实例信息，而是可以将这些信息直接添加到原型对象中。 1234567891011function Person()&#123;&#125;Person.prototype.name= \"Test\";Person.prototype.age= 12;Person.prototype.job= \"Software Engineer\";Person.prototype.sayName = function() &#123;console.log(this.name);&#125;const person1 = new Person();const person2 = new Person();person1.sayName(); // Testperson1.sayName == Person2.sayName // true// person1和person2访问的都是同一组属性和函数 原型最初只包含 constructor 属性，而该属性也是共享的，因此可以通过对象实例访问.访问顺序：先查找实例属性和方法，若没有，再查找原型中的。实例中属性可以通过delete删除，取消掉覆盖性 isPrototypeOf() 确定对象与实例之间的关系Person.prototype.isPrototypeOf(person1); // true Object.getPrototypeOf() 取得一个对象的原型Object.getPrototypeOf(person1) == Person.prototypeObject.getPrototypeOf(person1).name; hasOwnPrototype()检测属性存在实例中，还是原型中。原型中返回false，实例中返回true。in操作符：使用情况：单独使用以及 for…in…中使用1、单独使用：判断属性是否存在，无论实例还是原型。eg:’name’ in person1 注意：hasOwnPrototype()和in操作符同时使用可确定一个属性是存在于对象中还是原型中123function hasPrototypePer(object, name) &#123; return !object.hasOwnPrototype(name) &amp;&amp; (name in object);&#125; 2、for…in…循环：返回能否通过对象访问的、可枚举的属性，包括存在实例和原型中的属性 Object.keys() 取得对象上所有可枚举的实例属性；接受一个对象做为参数，返回所有可枚举属性的字符串数组Object.getOwnPrototypeNames() 得到所有实例属性，无论可枚举，包括 constructor 更简单的原型写法：用一个包含属性和方法的对象重写整个原型对象12345678var friend = new Person();Person.prototype = &#123; constructor: Person name: 'Test', age: 12, job: 'Software Engineer', sayName: function() &#123;console.log(this.name);&#125;&#125; 没有constructor: Person，这种写法，constructor 不再指向Person，指向Object 构造函数，虽然instanceof还能用。存在constructor: Person，但会导致它的 [[Enumerable]] 特性被设置为true。默认情况，原生的constructor 属性是不可枚举的。 原型的动态性：实例创建在原型上添加方法之前时，创建的实例仍然可以访问这个新添加的方法，原因：实例与原型之间的松散连接关系。可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来。但此时若重写整个原型对象，实例将访问不到。原因：实例中指针指向原型，重写将会切断连接。 原型对象的问题：省略了构造函数传递初始化参数的功能，结果所有的实例在默认的情况下将取得相同的属性值。对于属性和方法，其都是共享的，可以通过在实例中定义相同的属性名和方法对其进行覆盖，对于包含引用类型值的属性，对其操作将会污染整个实例的该属性。 12345678910Person.prototype = &#123; constructor: Person name: ‘Test’, age: 12, friend: ['test1', 'test2' ] job: \"Software Engineer\", sayName: function() &#123;console.log(this.name);&#125;&#125; Person1.friend.push('test3'); person1.friend === person2.friend ; // 污染 person2 了 解决办法：组合使用构造函数模式和原型模式（同时支持向构造函数传递参数）构造函数模式定义实例属性，原型模式定义方法和共享属性。1234567891011121314151617181920function Person(name, age) &#123; this.name = name; this.age = age; this.friends = ['f1', 'f2']&#125;Person.prototype = &#123; construction: Person, sayName: function() &#123; console.log(this.name); &#125;&#125;Const person1 = new Person('test1', 12);Const person2 = new Person('test2', 22);Person1.friends.push(‘f3’);Person1.friends; // f1,f2,f3Person2.friends; // f1,f2Person1.sayName === person2.sayName; // true 动态原型模式利用if判断，在方法不存在时再添加到原型1234567function Person(name, age) &#123; this.name = name; this.age = age; if (typeof this.sayName !== 'function') &#123; Person.prototype.sayname = function() &#123;&#125; &#125;;&#125; 弊端：不能使用对象字面量重写原型，如果在已经创建实例的情况下重写原型，将会切断实例与新原型之间的连接。 寄生构造函数模式（其他模式能用的情况下，不要使用这种方法）1234567891011function Person(name, age) &#123; var o = new Object(); o.name = name; o.age = age; o.sayName = function()&#123; console.log(this.name); &#125; return o;&#125;var friend = new Person('hello', 12);friend. sayName(); 基本思想：创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象1234567891011// 由于不能直接修改Array构造函数，可以使用以下方法funciton specialArray() &#123; var values = new Array(); values.push.apply(values, arguments); // 添加值 values.toPipedString = function() &#123; return this.join(‘|’); &#125; return values;&#125;Var colors = new specialArray(['red', 'blue', 'green']);colors.toPipedString(); // red|blue|green 返回的对象与构造函数或者与构造函数的原型属性之间没有关系。构造函数返回的对象与在构造函数外部创建的对象没有什么不同。不能依赖instanceof操作符来确定对象类型。 稳妥构造函数模式稳妥对象：没有公共属性，而且其方法也不引用this的对象。稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用this和new），或者在防止数据被其他应用程序改动时使用。稳妥构造函数和寄生构造函数的区别：1、新创建的对象实例方法不引用this；2、不实用new操作符调用构造函数。1234567891011function Person(name, age) &#123; var o = new Object(); o.name = name; o.age = age; o.sayName = function()&#123; console.log(name); &#125; return o;&#125;var friend = Person('hello', 12);friend. sayName(); 与寄生构造函数模式类似，使用稳妥构造函数创建的对象与构造函数之间也没有任何关系，因此instanceof操作符对这种对象也没有意义。 继承继承分为两种：接口继承和实现继承接口继承：只继承方法签名实现继承：继承实际的方法 原型链：利用原型链实现继承：利用原型让一个引用类型继承另一个引用类型的属性和方法。 方法：将父级的实例重写子级的原型，这样子级就继承了父级实例上属性和方法父级的实例属性位于子级的原型中，父级的实例方法依旧存储于父级的实例原型中，但存在一种指针关系。实际上，不是子级的原型的constructor属性被重写了，而是子级的原型指向了另一个对象——父级原型，而这个原型对象的constructor指向父级。 1、确定原型和实例的关系：instanceof和isPrototypeOfeg: child instanceof parentparent.prototype.isPrototypeOf(child);注意：通过原型链实现继承时，不能使用对象字面量创建原型。 2、原型链的问题问题一、包含引用类型值的原型属性会被所有实例共享。问题二、在创建子类型的实例时，没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。 1234567891011121314function SuperType() &#123; this.color = ['red', 'blue'];&#125;function SubType() &#123;&#125;// 继承了superTypeSubType.prototype = new SuperType();var instance1 = new SubType();instance1.color.push('black');console.log(instance1.color); // red blue blackvar instance2 = new SubType();console.log(instance2.color); // red blue black 借用构造函数/伪造对象/经典继承（解决原型中包含引用类型值的问题）思想：在子类构造函数的内部调用超类型构造函数，可以使用apply 和 call。 123456789101112131415function SuperType(name) &#123; this.color = ['red', 'blue']; this.name = name&#125;function SubType() &#123; SuperType.call(this, 'Hello'); this.age = 19;&#125;var instance1 = new SubType();instance1.color.push('black');console.log(instance1.color); // red blue blackconsole.log(instance1.name); // Hellovar instance2 = new SubType();console.log(instance2.color); // red blue 缺点：方法都在构造函数中定义，因此函数复用就无从谈起。并且在超类型的原型中定义的方法，对子类型而言也是看不见的。 组合继承/伪经典继承思想：使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承。调用了两次超类型的构造函数：1、创建子类型的原型时；2、子类型构造函数的内部。1234567891011121314151617181920212223function SuperType(name) &#123; this.name = name; this.color = ['red', 'blue'];&#125;SuperType.prototype.sayName = function() &#123;console.log(this.name);&#125;function SubType(name, age) &#123; SuperType.call(this, name); // 第二次调用 this.age = age;&#125;SubType.prototype = new SuperType(); // 第一次调用SubType.sayAge = function() &#123;console.log(this.age);&#125;var instance1 = new SubType('Hello', 19);instance1.color.push('black');console.log(instance1.color); // red blue blackconsole.log(instance1.name); // Helloconsole.log(instance1.age); // 19var instance2 = new SubType('Hello1', 17);console.log(instance2.color); // red blueconsole.log(instance2.name); // Hello1console.log(instance2.age); // 17 Instance 和 isPrototypeof()也能够用于识别基于组合继承创建的对象。组合继承最大的问题：会调用两次超类型构造函数：第一次调用SuperType构造函数时，SubType.prototype会得到name 和 color的属性，现位于 SubType的原型中。当调用SubType构造函数时，又会调用一次SuperType构造函数，这时又在新对象上创建了实例属性name 和 color，因此此时屏蔽了原型中的两个属性。 原型式继承：Object.create(用作新对象原型的对象，需要修改的属性值对象)其中Object.create的原理为：12345function object(o) &#123; function F() &#123;&#125;; F.prototype = o; return new F();&#125; 1234567891011121314var person = &#123; name: 'Hello', friends: ['red', 'blue']&#125;var anotherPerson = Object.create(person);anotherPerson.name = 'Gery';anotherPerson.name.friends.push('green');var yetAnotherPerson = Object.create(person);yetAnotherPerson.name = 'Linda';yetAnotherPerson.name.friends.push('pink');Console.log(person.friends); // red blue green pink 想让一个对象与另一个对象保持类似的情况时，可以使用，但是依旧存在引用类型值的属性被共享的情况 寄生式继承寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数。1234567891011121314function createAnother(original) &#123; var clone = object(original); // 通过调用函数创建一个新对象 clone.sayHi = function() &#123; // 以某种方式来增强这个对象 console.log('hi'); &#125;; return clone; // 返回这个对象&#125;var person = &#123; name: 'Hello', friends: ['red', 'blue']&#125;;var anotherPerson = createAnother(person);anotherPerson.sayHi(); // hi 前面示范继承时使用的object() 函数不是必需的，任何能够返回新对象的函数都使用于此模式。使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率；这一点与构造函数模式类似。 寄生组合式继承通过构造函数来继承属性，通过原型链的混成模式来继承方法。使用寄生式继承来继承超类型的原型，然后再将结果指定给自类型的原型。思想：不必为了指定子类型的原型而调用超类型的构造函数，需要超类型原型的副本。1234567891011121314151617181920212223function inheritPrototype(subType, superType) &#123; var prototype = object(superType.prototype); // 创建对象 prototype.constructor = subType; // 增强对象 subType.prototype = prototype; // 指定对象&#125;function SuperType (name) &#123; this.name = name; this.colors = ['red', 'blue']&#125; SuperType.prototype.sayName = function() &#123; console.log(this.name);&#125;function SubType(name, age) &#123; SuperType.call(this, name); this.age = age;&#125;inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function() &#123; console.log(this.age);&#125; 只调用了一次 SuperType 构造函数，避免了在 SuperType.prototype 上创建不必要的、多余的属性；原型链还能保持不变；能够正常使用 instanceof 和 isPropertyOf() 总结工厂模式，使用简单的函数创建对象，为对象添加属性和方法，然后返回对象。构造函数模式，可以创建自定义引用类型，可以像创建内置对象实例一样使用new操作符。不过，缺点：它的每个成员都无法得到复用，包括函数。由于函数可以不局限于任何对象，因此没有理由不在多个对象间共享函数。原型模式，使用构造函数的prototype属性来指定共享的属性和方法。组合使用构造函数模式和原型模式时，使用构造函数定义实例属性，使用原型定义共享的属性和方法。 JS主要通过原型链实现继承。原型链的构建是通过将一个类型的实例赋值给另一个构造函数的原型实现的。这样，子类型就能访问超类型的所有属性和方法。原型链的问题：对象实例共享所有继承的属性和方法，因此不适合单独使用。解决办法需要利用构造函数，即在子类型构造函数的内部调用超类型构造函数。组合继承：使用原型链模式继承共享的属性和方法，借用构造函数继承实例属性。 原型式继承：可以在不必预先定义构造函数的情况下实现继承，本质是执行对给定对象的浅复制。寄生式继承：基于某个对象或某些信息创建一个对象，然后增强对象，最后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式与组合继承一起使用——寄生组合式继承","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"CSS3 单位汇总","slug":"[CSS] CSS3 单位","date":"2018-09-12T08:31:38.000Z","updated":"2018-10-08T02:22:00.000Z","comments":true,"path":"2018/09/12/[CSS] CSS3 单位/","link":"","permalink":"http://yoursite.com/2018/09/12/[CSS] CSS3 单位/","excerpt":"","text":"px：绝对单位，页面按精确像素展示。 em：相对单位，基准点为父节点字体的大小。如果自身定义了font-size按自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值。 rem：相对单位，可理解为”root em”, 相对根节点html的字体大小来计算，CSS3新加属性，chrome/firefox/IE9+支持。(另外需注意chrome强制最小字体为12号，即使设置成 10px 最终都会显示成 12px，当把html的font-size设置成10px,子节点rem的计算还是以12px为基准)。 vw：viewpoint width，视窗宽度，1vw等于视窗宽度的1%。 vh：viewpoint height，视窗高度，1vh等于视窗高度的1%。 vmin：vw和vh中较小的那个。 vmax：vw和vh中较大的那个。vw, vh, vmin, vmax：IE9+局部支持，chrome/firefox/safari/opera支持，ios safari 8+支持，android browser4.4+支持，chrome for android39支持 ex：取当前作用效果的字体的x的高度，在无法确定x高度的情况下以0.5em计算(IE11及以下均不支持 firefox/chrome/safari/opera/ios safari/android browser4.4+等均需属性加么有前缀) ch:以节点所使用字体中的“0”字符为基准，找不到时为0.5em(ie10+,chrome31+,safair7.1+,opera26+,ios safari 7.1+,android browser4.4+支持)","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"}]},{"title":"JS 函数式编程指南","slug":"[JS] JS 函数式编程指南","date":"2018-09-06T02:30:23.000Z","updated":"2018-10-08T02:21:50.000Z","comments":true,"path":"2018/09/06/[JS] JS 函数式编程指南/","link":"","permalink":"http://yoursite.com/2018/09/06/[JS] JS 函数式编程指南/","excerpt":"","text":"","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"Vue知识点总结","slug":"[Vue] Vue知识点总结","date":"2018-09-06T02:30:23.000Z","updated":"2018-11-01T16:23:36.736Z","comments":true,"path":"2018/09/06/[Vue] Vue知识点总结/","link":"","permalink":"http://yoursite.com/2018/09/06/[Vue] Vue知识点总结/","excerpt":"","text":"1、nextTick使用原因2、Vue实现数据双向绑定的原理3、Vue中v-for为啥必须含有key4、mutation-type的作用5、自定义指令6、Vue中data为function原因7、dispatch和commit的区别 1、Vue nextTick使用原因nextTick是全局vue的一个函数，在vue系统中，用于处理dom更新的操作。vue里面有一个watcher，用于观察数据的变化，然后更新dom，vue里面并不是每次数据改变都会触发更新dom，而是将这些操作都缓存在一个队列，在一个事件循环结束之后，刷新队列，统一执行dom更新操作。在vue生命周期的created()钩子函数进行的DOM操作要放在Vue.nextTick()的回调函数中，因为created()钩子函数执行的时候DOM并未进行任何渲染，而此时进行DOM操作是徒劳的，所以此处一定要将DOM操作的JS代码放进Vue.nextTick()的回调函数中。而与之对应的mounted钩子函数，该钩子函数执行时所有的DOM挂载和渲染都已完成，此时该钩子函数进行任何DOM操作都不会有个问题。Vue.nextTick(callback)，当数据发生变化，更新后执行回调。Vue.$nextTick(callback)，当dom发生变化，更新后执行的回调。 使用了nextTick异步更新视图的好处1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;div&gt;&#123;&#123; test &#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;export default &#123; data () &#123; return &#123; test: 0 &#125;; &#125;, created () &#123; for(let i = 0; i &lt; 1000; i++) &#123; this.test++; &#125; &#125;&#125; 现在有这样的一种情况，created的时候test的值会被++循环执行1000次。每次++时，都会根据响应式触发setter-&gt;Dep-&gt;Watcher-&gt;update-&gt;patch。如果这时候没有异步更新视图，那么每次++都会直接操作DOM更新视图，这是非常消耗性能的。所以Vue.js实现了一个queue队列，在下一个tick的时候会统一执行queue中Watcher的run。同时，拥有相同id的Watcher不会被重复加入到该queue中去，所以不会执行1000次Watcher的run。最终更新视图只会直接将test对应的DOM的0变成1000。保证更新视图操作DOM的动作是在当前栈执行完以后下一个tick的时候调用，大大优化了性能。 Vue批量挂起DOM更新并异步应用它们以防止由多个数据突变导致的不必要的重新呈现。在实践中我们经常不得不Vue.nextTick等待Vue在我们触发某些状态更改之后执行实际的DOM更新。 整理自：https://juejin.im/post/5bc970e9f265da0af50355d6 2、Vue实现数据双向绑定的原理实现数据绑定的做法有大致如下几种： 1、发布者-订阅者模式（backbone.js） 发布者-订阅者模式: 一般通过sub, pub的方式实现数据和视图的绑定监听，更新数据方式通常做法是 vm.set(‘property’, value)， 2、脏值检查（angular.js）angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下： DOM事件，譬如用户输入文本，点击按钮等。( ng-click ) XHR响应事件 ( $http ) 浏览器Location变更事件 ( $location ) Timer事件( $timeout , $interval )* 执行 $digest() 或 $apply()3、数据劫持（vue.js）vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。vue是通过数据劫持的方式来做数据绑定的，其中最核心的方法便是通过Object.defineProperty()来实现对属性的劫持，达到监听数据变动的目的。整理了一下，要实现mvvm的双向绑定，就必须要实现以下几点：1、实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者2、实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数3、实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图4、mvvm入口函数，整合以上三者#### a、数据监听器Observer我们知道可以利用Obeject.defineProperty()来监听属性变动那么将需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。123456789101112131415161718192021222324function observe(data) &#123; if (!data || typeof data !== 'object') &#123; return; &#125; // 取出所有属性遍历 Object.keys(data).forEach(function(key) &#123; defineReactive(data, key, data[key]); &#125;);&#125;;function defineReactive(data, key, val) &#123; observe(val); // 监听子属性 Object.defineProperty(data, key, &#123; enumerable: true, // 可枚举 configurable: false, // 不能再define get: function() &#123; return val; &#125;, set: function(newVal) &#123; console.log('监听到值变化了 ', val, ' --&gt; ', newVal); val = newVal; &#125; &#125;);&#125;这样我们已经可以监听每个数据的变化了，那么监听到变化之后就是怎么通知订阅者了，所以接下来我们需要实现一个消息订阅器，很简单，维护一个数组，用来收集订阅者，数据变动触发notify，再调用订阅者的update方法.1234567891011121314151617181920212223242526272829// ... 省略function defineReactive(data, key, val) &#123; var dep = new Dep(); observe(val); // 监听子属性 Object.defineProperty(data, key, &#123; // ... 省略 set: function(newVal) &#123; if (val === newVal) return; console.log('监听到值变化了 ', val, ' --&gt; ', newVal); val = newVal; dep.notify(); // 通知所有订阅者 &#125; &#125;);&#125;function Dep() &#123; this.subs = [];&#125;Dep.prototype = &#123; addSub: function(sub) &#123; this.subs.push(sub); &#125;, notify: function() &#123; this.subs.forEach(function(sub) &#123; sub.update(); &#125;); &#125;&#125;;通过dep添加订阅者，就必须要在闭包内操作 b.指令解析器compilecompile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图。因为遍历解析的过程有多次操作dom节点，为提高性能和效率，会先将根节点el转换成文档碎片fragment进行解析编译操作，解析完成，再将fragment添加回原来的真实dom节点中。通过递归遍历保证了每个节点及子节点都会解析编译到，包括“双花括号”表达式声明的文本节点。指令的声明规定是通过特定前缀的节点属性来标记，如&lt;span v-text=&quot;content&quot; other-attr&gt;中v-text便是指令，而other-attr不是指令，只是普通的属性。 c、订阅者WatcherWatcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是:1、在自身实例化时往属性订阅器(dep)里面添加自己2、自身必须有一个update()方法3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。123456789101112131415161718192021222324252627282930313233343536373839404142function Watcher(vm, exp, cb) &#123; this.cb = cb; this.vm = vm; this.exp = exp; // 此处为了触发属性的getter，从而在dep添加自己，结合Observer更易理解 this.value = this.get(); &#125;Watcher.prototype = &#123; update: function() &#123; this.run(); // 属性值变化收到通知 &#125;, run: function() &#123; var value = this.get(); // 取到最新值 var oldVal = this.value; if (value !== oldVal) &#123; this.value = value; this.cb.call(this.vm, value, oldVal); // 执行Compile中绑定的回调，更新视图 &#125; &#125;, get: function() &#123; Dep.target = this; // 将当前订阅者指向自己 var value = this.vm[exp]; // 触发getter，添加自己到属性订阅器中 Dep.target = null; // 添加完毕，重置 return value; &#125;&#125;;// 这里再次列出Observer和Dep，方便理解Object.defineProperty(data, key, &#123; get: function() &#123; // 由于需要在闭包内添加watcher，所以可以在Dep定义一个全局target属性，暂存watcher, 添加完移除 Dep.target &amp;&amp; dep.addDep(Dep.target); return val; &#125; // ... 省略&#125;);Dep.prototype = &#123; notify: function() &#123; this.subs.forEach(function(sub) &#123; sub.update(); // 调用订阅者的update方法，通知变化 &#125;); &#125;&#125;; 实例化Watcher的时候，调用get()方法，通过Dep.target = watcherInstance标记订阅者是当前watcher实例，强行触发属性定义的getter方法，getter方法执行的时候，就会在属性的订阅器dep添加当前watcher实例，从而在属性值有变化的时候，watcherInstance就能收到更新通知。 d、MVVMMVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。一个简单的MVVM构造器是这样子：123456function MVVM(options) &#123; this.$options = options; var data = this._data = this.$options.data; observe(data, this); this.$compile = new Compile(options.el || document.body, this)&#125; 但是这里有个问题，从代码中可看出监听的数据对象是options.data，每次需要更新视图，则必须通过var vm = new MVVM({data:{name: &#39;kindeng&#39;}); vm._data.name = &#39;dmq&#39;; 这样的方式来改变数据。显然不符合我们一开始的期望，我们所期望的调用方式应该是这样的：var vm = new MVVM({data: {name: &#39;kindeng&#39;}); vm.name = &#39;dmq&#39;;所以这里需要给MVVM实例添加一个属性代理的方法，使访问vm的属性代理为访问vm._data的属性，1234567891011121314151617181920212223242526function MVVM(options) &#123; this.$options = options; var data = this._data = this.$options.data, me = this; // 属性代理，实现 vm.xxx -&gt; vm._data.xxx Object.keys(data).forEach(function(key) &#123; me._proxy(key); &#125;); observe(data, this); this.$compile = new Compile(options.el || document.body, this)&#125;MVVM.prototype = &#123; _proxy: function(key) &#123; var me = this; Object.defineProperty(me, key, &#123; configurable: false, enumerable: true, get: function proxyGetter() &#123; return me._data[key]; &#125;, set: function proxySetter(newVal) &#123; me._data[key] = newVal; &#125; &#125;); &#125;&#125;; 这里主要还是利用了Object.defineProperty()这个方法来劫持了vm实例对象的属性的读写权，使读写vm实例的属性转成读写了vm._data的属性值 3、Vue中v-for为啥必须含有keykey的作用主要是为了高效的更新虚拟DOM。使用v-for更新已渲染的元素列表时,默认用就地复用策略;列表数据修改的时候,他会根据key值去判断某个值是否修改,如果修改,则重新渲染这一项,否则复用之前的元素;我们在使用的使用经常会使用index(即数组的下标)来作为key,但其实这是不推荐的一种使用方法;最好的办法是使用数组中不会变化的那一项作为key值,### 4、mutation-type的作用使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然。用不用常量取决于你——在需要多人协作的大型项目中，这会很有帮助。但如果你不喜欢，你完全可以不这样做。Mutation 必须是同步函数 5、自定义指令12345678910// 注册一个全局自定义指令 `v-focus`Vue.directive('focus', &#123; // 当被绑定的元素插入到 DOM 中时…… inserted: function (el) &#123; // 聚焦元素 el.focus() &#125;&#125;);// &lt;input v-focus&gt; 如果想注册局部指令，组件中也接受一个 directives 的选项：12345678directives: &#123; focus: &#123; // 指令的定义 inserted: function (el) &#123; el.focus() &#125; &#125;&#125; a、钩子函数一个指令定义对象可以提供如下几个钩子函数 (均为可选)：bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新。componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。unbind：只调用一次，指令与元素解绑时调用。 b、钩子函数参数指令钩子函数会被传入以下参数：el：指令所绑定的元素，可以用来直接操作 DOM 。binding：一个对象，包含以下属性： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1”。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。 123456789101112131415161718192021222324252627// &lt;div id=\"hook-arguments-example\" v-demo:foo.a.b=\"message\"&gt;&lt;/div&gt;Vue.directive('demo', &#123; bind: function (el, binding, vnode) &#123; var s = JSON.stringify el.innerHTML = 'name: ' + s(binding.name) + '&lt;br&gt;' + 'value: ' + s(binding.value) + '&lt;br&gt;' + 'expression: ' + s(binding.expression) + '&lt;br&gt;' + 'argument: ' + s(binding.arg) + '&lt;br&gt;' + 'modifiers: ' + s(binding.modifiers) + '&lt;br&gt;' + 'vnode keys: ' + Object.keys(vnode).join(', ') &#125;&#125;)new Vue(&#123; el: '#hook-arguments-example', data: &#123; message: 'hello!' &#125;&#125;);// name: \"demo\"// value: \"hello!\"// expression: \"message\"// argument: \"foo\"// modifiers: &#123;\"a\":true,\"b\":true&#125;// vnode keys: tag, data, children, text, elm, ns, context, fnContext, fnOptions, fnScopeId, key, componentOptions, componentInstance, parent, raw, isStatic, isRootInsert, isComment, isCloned, isOnce, asyncFactory, asyncMeta, isAsyncPlaceholder c、函数简写在很多时候，你可能想在 bind 和 update 时触发相同行为，而不关心其它的钩子。比如这样写:123Vue.directive('color-swatch', function (el, binding) &#123; el.style.backgroundColor = binding.value&#125;) d、对象字面量如果指令需要多个值，可以传入一个 JavaScript 对象字面量。记住，指令函数能够接受所有合法的 JavaScript 表达式。12345// &lt;div v-demo=\"&#123; color: 'white', text: 'hello!' &#125;\"&gt;&lt;/div&gt;Vue.directive('demo', function (el, binding) &#123; console.log(binding.value.color) // =&gt; \"white\" console.log(binding.value.text) // =&gt; \"hello!\"&#125;) 6、Vue中data为function原因怕重复创建实例造成多实例共享一个数据对象当一个组件被定义，data 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！通过提供 data 函数，每次创建一个新实例后，我们能够调用 data 函数，从而返回初始数据的一个全新副本数据对象。 7、dispatch和commit的区别Action 类似于 mutation，不同在于：1、Action 提交的是 mutation，而不是直接变更状态。2、Action 可以包含任意异步操作。3、dispatch 推送一个action。更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。commit 推送一个mutation。dispatch：含有异步操作，例如向后台提交数据，写法： this.$store.dispatch(&#39;mutations方法名&#39;, 值)commit：同步操作，写法：this.$store.commit(&#39;mutations方法名&#39;, 值)","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"git 命令","slug":"git 命令","date":"2018-09-06T02:30:23.000Z","updated":"2018-10-19T15:30:11.259Z","comments":true,"path":"2018/09/06/git 命令/","link":"","permalink":"http://yoursite.com/2018/09/06/git 命令/","excerpt":"","text":"删除分支【git 删除本地分支】：git branch -D br【git 删除远程分支】：git push origin :br (origin 后面有空格)【恢复删除掉的分支】：git branch 分支名 hash_val 其中 hash_val 为散列值，如果不知，可利用 reflog。 reflog命令：显示整个本地仓储的commit，包括所有branch的commit，甚至包括已经撤销的commit。 eg: git branch 分支名 HEAD@{4} 【将远程的某个分支，拉取到本地】： 方法一： git checkout -b 本地分支名x origin/远程分支名x 方法二： git fetch origin 远程分支名x:本地分支名x 回退回滚取消提交返回上一版本【没有push】：git reset [ --soft || --hard || --mixed ] commitIdeg：git reset –hard 139dcfaa558e3276b30b6b2e5cbbb9c00bbdca96 (ID) –soft 保留源码（work），回退到 commit 信息到某个版本，不涉及index的回退 如果还需要提交，直接commit commit 回退，index和work不会 –hard 源码也会回退到某个版本，commit和index 都回退到某个版本。 commit、index和work都会改变 push之后千万不要使用，因为线上代码没变，包括commit和index； 但把本地代码修改完提交时会发生权限冲突 加 force 把修改推到远程： git push -f -u origin master –mixed 会保留源码，只会将 git commit 和index 回退 commit和index会回退，work保留 【已经push】git revert commintIdgit revert 反转提交（工作树必须干净 三个区域的状态、git status干净）用一个新提交来消除一个历史提交所做的任何修改。revert 本地代码回退，再git push 更新线上代码 子模块","categories":[{"name":"编码规范","slug":"编码规范","permalink":"http://yoursite.com/categories/编码规范/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"懒加载的实现","slug":"[JS] 懒加载","date":"2018-09-06T02:10:13.000Z","updated":"2018-10-08T02:21:36.000Z","comments":true,"path":"2018/09/06/[JS] 懒加载/","link":"","permalink":"http://yoursite.com/2018/09/06/[JS] 懒加载/","excerpt":"","text":"方法一：IntersectionObserver方法二：","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"node制作命令行","slug":"[Command] node制作命令行","date":"2018-08-25T02:55:51.000Z","updated":"2018-10-08T02:22:10.000Z","comments":true,"path":"2018/08/25/[Command] node制作命令行/","link":"","permalink":"http://yoursite.com/2018/08/25/[Command] node制作命令行/","excerpt":"","text":"目标：利用自制的命令行实现输出自己的简历；增加常用的命令：ls、 ls -a、打开当前目录 怎么制作命令行1、配置基础框架2、新建bin/qqResume.js目录，并如下:1234567891011121314151617181920212223242526#!/usr/bin/env node// 被成为 shebang ，表示用后面的路径所示的程序来执行当前文件夹const fs = require('fs');const path = process.cwd();const run = (obj) =&gt; &#123; if (obj[0] === '-v') &#123; console.log('verson is 1.0.0.0'); &#125; else if (obj[0] === '-h')&#123; console.log('Useage:'); console.log(' -v --version [show version]'); &#125; else &#123; fs.readdir(path, (err, files) =&gt; &#123; if (err) &#123; return console.log(err); &#125; for(var i = 0; i &lt; files.length; i += 1)&#123; console.log(files[i]); &#125; &#125;) &#125;&#125;//获取除第一个命令以后的参数，使用空格拆分run(process.argv.slice(2)); 运行可使用 node，在 package.json文件中配置 &quot;bin&quot;: { &quot;qqResume&quot;: &quot;bin/qqResume.js&quot; };3、全局运营命令 sudo npm install . -g npm link4、发布安装发布到npm中，首先需要 npm、github 账号：npm publish发布完成后可和平时的命令一样，全局安装: sudo npm i -g qqResume commanderCommander 是一款重量轻，表现力和强大的命令行框架。提供了用户命令行输入和参数解析强大功能。Commander的优势：自记录代码、自动生成帮助、合并短参数（“ABC”==“-A-B-C”）、默认选项、强制选项​​、命令解析、提示符 APIOption(): 初始化自定义参数对象，设置“关键字”和“描述”Command(): 初始化命令行参数对象，直接获得命令行输入Command#command(): 定义一个命令名字Command#action(): 注册一个callback函数Command#option(): 定义参数，需要设置“关键字”和“描述”，关键字包括“简写”和“全写”两部分，以”,”,”|”,”空格”做分隔。Command#parse(): 解析命令行参数argvCommand#description(): 设置description值Command#usage(): 设置usage值","categories":[{"name":"Command","slug":"Command","permalink":"http://yoursite.com/categories/Command/"}],"tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"},{"name":"commander","slug":"commander","permalink":"http://yoursite.com/tags/commander/"}]},{"title":"小细节小技巧","slug":"[CSS] 小细节小技巧","date":"2018-08-08T09:59:12.000Z","updated":"2018-10-31T16:38:24.031Z","comments":true,"path":"2018/08/08/[CSS] 小细节小技巧/","link":"","permalink":"http://yoursite.com/2018/08/08/[CSS] 小细节小技巧/","excerpt":"","text":"1、overflow的奇葩事件2、BFC块级格式化上下文3、font-size4、position:sticky5、清除浮动&emsp;&emsp;这篇文章专门用于记录在开发过程中遇到的奇葩现象，平时经常更新，用于自己的一个记录。 1、overflow的奇葩事件&emsp;&emsp;背景：这次遇到一个很奇怪的样子，其实应用的场景很简单，就是一个轮播，采用hidden处理周边的待滚动的li，但又接到hover上有动画的需求，此时设置overflow-x: hidden; overflow-y: visible;不能实现。没办法，看到网上好多人说增加父级，并对父级分别设置overflow来处理，不靠谱，实现不了。&emsp;&emsp;原因：这块和overflow非visible值会使一个块级元素形成一个BFC（块级格式化上下文）有关。overflow-x和overflow-y的计算值跟给定的值相同，除了某些跟’visible’值的不合理组合：如果一个其中一个属性的值被赋为’visible’，而另一个被赋值为’scroll’或’auto’，那么’visible’会被重置为’auto’。overflow的计算值与overflow-x相等（如果overflow-y相同的话）；否则就是一对overflow-x和overflow-y的计算值。 其实另一个值设置为hidden的时候，visible也会被重置为auto。&emsp;&emsp;处理方法：增加外围父级的高度，用于hover时的阴影用，然后margin点位置，用于hover时的上移。其他依旧正常设置，只是不让动画局限在撑起的高度内。 2、BFC块级格式化上下文3、font-size&emsp;&emsp;很简单的div模型，设置宽高后，同样可以利用font-size来扩大div的宽度，其原因可由 line-height 解释 4、position:sticky&emsp;&emsp;sticky原意为黏糊的，但在css中更多的表现为吸顶、吸底(移动端网站的头部返回栏,底部切换栏之类)的效果用这个属性非常适合。导航的效果像是在页面打开时是 relative 的,向下滑动的时候 fixed 并且 top:0 为零。 position:sticky可以认为是 position:relative 和 position:fixed 两种定位功能于一体的特殊定位。12345.sticky &#123; position: sticky; position: -webkit-sticky; top: 0; &#125; 注意：可以放心在ios上使用，可以使用polyfill进行处理注意坑 1、sticky 不会触发 BFC。 2、z-index 无效。 3、sticky 是容器相关的,也就说 sticky 的特性只会在他所处的容器里生效。碰到 body 设置 height:100% 的时候 sticky 元素停在某一个位置不动了。 5、清除浮动方法一：12345/* 在容器内添加一个CSS伪元素， */.clear::before &#123; content: ''; clear: both;&#125; 方法二：清除浮动的另一个方法是在容器内创建BFC，一个BFC元素完全包裹住了它内部的所有元素，包括内部的浮动元素，保证浮动元素不会超出其底部。清除浮动的方式是为元素设置除visible（默认）之外的overflow属性值。123.container &#123; overflow: auto;&#125; 然而，在某些情况下，这可能会带来一些阴影的截断或是非预期的滚动条。同时它也使你的CSS变得不那么直观. 方法三：display: flow-root123.container &#123; display: flow-root;&#125; display: flow-root做的唯一的一件事就是去创建一个BFC，因此可以避免其他创建BFC方法带来的问题。 6、css容易不注意的块元素和行内元素块元素：会独自占据一整行或多整行，可以对其设置宽高 &lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;li&gt;、&lt;ol&gt;行内元素：靠自身的字体大小和版本尺寸来支撑结构&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;a&gt;、&lt;span&gt; 选择优先级行内 &gt; id &gt; 类 &gt; 标签 &gt; 通配符选择器 &gt; 继承样式 &gt; 浏览器默认的样式 7、link与@import的区别1、link是HTML方式， @import是CSS方式2、link最大限度支持并行下载，@import过多嵌套导致串行下载，出现FOUC3、link可以通过rel=”alternate stylesheet”指定候选样式4、浏览器对link支持早于@import，可以使用@import对老浏览器隐藏样式5、@import必须在样式规则之前，可以在css文件中引用其他文件6、总体来说：link优于@import 8、CSS有哪些继承属性 关于文字排版的属性如：font、word-break、letter-spacing、text-align、text-rendering、word-spacing、white-space、text-indent、text-transform、text-shadow line-height color visibility cursor","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"commander开发命令行工具","slug":"[Command] commander开发命令行工具","date":"2018-07-27T06:28:31.000Z","updated":"2018-10-08T02:22:06.000Z","comments":true,"path":"2018/07/27/[Command] commander开发命令行工具/","link":"","permalink":"http://yoursite.com/2018/07/27/[Command] commander开发命令行工具/","excerpt":"","text":"在学习开发的时候，遇到了commander的使用，实现对数据","categories":[{"name":"Command","slug":"Command","permalink":"http://yoursite.com/categories/Command/"}],"tags":[{"name":"cli","slug":"cli","permalink":"http://yoursite.com/tags/cli/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"git commit 规范","slug":"[编码规范] git commit规范","date":"2018-07-19T01:55:12.000Z","updated":"2018-10-08T02:21:13.000Z","comments":true,"path":"2018/07/19/[编码规范] git commit规范/","link":"","permalink":"http://yoursite.com/2018/07/19/[编码规范] git commit规范/","excerpt":"","text":"&emsp;&emsp;前段时间组内规范了工作流，设定了commit message 规范，开始时甚是痛苦，但是习惯了发现好处颇多。现在社区中有很多 Commit message的写法规范，个人认为 Angular 规范 是目前使用最广的写法。 commit message 的作用 提供更多的历史信息，方便快速浏览。 可以过滤某些commit（比如文档改动），便于快速查找信息。 可以直接从commit生成Change log。 可读性好，清晰，不必深入看代码即可了解当前commit的作用。 为 Code Reviewing做准备 方便跟踪工程历史 让其他的开发者在运行 git blame 的时候想跪谢 提高项目的整体质量，提高个人工程素质 commit message 的格式&emsp;&emsp;Commit message 包括三个部分：header(必需)、body(可省)和footer(可省).任何一行都不得超过72个字符（或100个字符），这是为了避免自动换行影响美观。 HeaderHeader 部分只有一行，包括三个字段 type（必需）、scope（可选）和subject（必需）。 type ：用于说明 commit 的类别，只允许使用下面7个标识。 feat：新功能（feature） fix：修补bug docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改bug的代码变动） test：增加测试 chore：构建过程或辅助工具的变动 一般情况下，type为feat和fix，则该 commit 将肯定出现在 Change log 之中，其他的自己可以设置。 scope: 用于说明 commit 影响的范围，比如数据层、控制层、视图层等等。例如在Angular，可以是$location, $browser, $compile, $rootScope, ngHref, ngClick, ngView等。 subject: 是 commit 目的的简短描述，开头需要使用第一人称现在时的动词开头。 BodyBody 部分是对本次 commit 的详细描述，可以分成多行1、使用第一人称现在时，比如使用change而不是changed或changes。2、永远别忘了第2行是空行。3、应该说明代码变动的动机，以及与以前行为的对比。 FooterFooter 部分只用于以下两种情况：1、不兼容变动&emsp;&emsp;&emsp;&emsp;若当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法。12345678910111213BREAKING CHANGE: isolate scope bindings definition has changed. To migrate the code follow the example below: Before: scope: &#123; myAttr: 'attribute', &#125; After: scope: &#123; myAttr: '@', &#125;The removed `inject` wasn't generaly useful for directives so there should be no code using it. 2、关闭issue&emsp;&emsp;&emsp;&emsp;若当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。Closes #234 补充 Revrt若当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header。12revert: feat(pencil): add &apos;graphiteWidth&apos; optionThis reverts commit 667ecc1654a317a13331b17617d973392f415f02. Body部分的格式是固定的，必须写成This reverts commit &amp;lt;hash&gt;，其中的hash是被撤销 commit 的 SHA 标识符。若当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的Reverts小标题下面。 Commitizen可以使用典型的git工作流程或通过使用CLI向导Commitizen来添加提交消息格式。 安装 npm i -g commitizen然后，在项目目录里，运行下面的命令，使其支持 Angular 的 Commit message 格式。commitizen init cz-conventional-changelog --save --save-exact以后，凡是用到git commit命令，一律改为使用git cz。这时，就会出现选项，用来生成符合格式的 Commit message。 validate-commit-msgvalidate-commit-msg 用于检查项目的 Commit message 是否符合Angular规范。该包提供了使用githooks来校验commit message的一些二进制文件。推荐使用husky，只需要添加 “commitmsg”: “validate-commit-msg” 到package.json中的nam scripts即可. 当然，还可以通过定义配置文件.vcmrc来自定义校验格式。详细使用请见文档 validate-commit-msg 生成Change log如果commit都符合规则，则发布新版本时，Change log 就可以用脚本自动生成。生成的文档主要包括：New feature、Bug fixed、Breaking changes。每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。 conventional-changelog 就是生成 Change log 的工具，运行下面的命令即可。123$ npm install -g conventional-changelog$ cd my-project$ conventional-changelog -p angular -i CHANGELOG.md -w","categories":[{"name":"编码规范","slug":"编码规范","permalink":"http://yoursite.com/categories/编码规范/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"代码规范","slug":"代码规范","permalink":"http://yoursite.com/tags/代码规范/"}]},{"title":".eslintrc的解释","slug":"[编码规范] eslintrc的解释","date":"2018-07-18T10:08:12.000Z","updated":"2018-10-08T02:21:18.000Z","comments":true,"path":"2018/07/18/[编码规范] eslintrc的解释/","link":"","permalink":"http://yoursite.com/2018/07/18/[编码规范] eslintrc的解释/","excerpt":"","text":"可以通过三种方式配置ESLint:1、 使用 .eslintrc 文件(支持 JSON 和 YAML 两种语法)；2、 在 package.json 中添加 eslintConfig 配置块；3、 直接在代码文件中定义。 对 .eslintrc 的研究摘录如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514&#123; // 环境定义了预定义的全局变量。 \"env\": &#123; //环境定义了预定义的全局变量。更多在官网查看 \"browser\": true, \"node\": true, \"commonjs\": true, \"amd\": true, \"es6\":true, \"mocha\":true &#125;, // JavaScript 语言选项 \"parserOptions\": &#123; // ECMAScript 版本 \"ecmaVersion\": 6, \"sourceType\": \"script\",//module // 想使用的额外的语言特性: \"ecmaFeatures\": &#123; // 允许在全局作用域下使用 return 语句 \"globalReturn\":true, // impliedStric \"impliedStrict\":true, // 启用 JSX \"jsx\":true &#125; &#125;, /** * \"off\" 或 0 - 关闭规则 * \"warn\" 或 1 - 开启规则，使用警告级别的错误：warn (不会导致程序退出), * \"error\" 或 2 - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出) */ \"rules\": &#123; //////////////// // 可能的错误 // //////////////// // 禁止条件表达式中出现赋值操作符 \"no-cond-assign\": 2, // 禁用 console \"no-console\": 0, // 禁止在条件中使用常量表达式 // if (false) &#123; // doSomethingUnfinished(); // &#125; //cuowu \"no-constant-condition\": 2, // 禁止在正则表达式中使用控制字符 ：new RegExp(\"\\x1f\") \"no-control-regex\": 2, // 数组和对象键值对最后一个逗号， never参数：不能带末尾的逗号, always参数：必须带末尾的逗号， // always-multiline：多行模式必须带逗号，单行模式不能带逗号 \"comma-dangle\": [1, \"always-multiline\"], // 禁用 debugger \"no-debugger\": 2, // 禁止 function 定义中出现重名参数 \"no-dupe-args\": 2, // 禁止对象字面量中出现重复的 key \"no-dupe-keys\": 2, // 禁止重复的 case 标签 \"no-duplicate-case\": 2, // 禁止空语句块 \"no-empty\": 2, // 禁止在正则表达式中使用空字符集 (/^abc[]/) \"no-empty-character-class\": 2, // 禁止对 catch 子句的参数重新赋值 \"no-ex-assign\": 2, // 禁止不必要的布尔转换 \"no-extra-boolean-cast\": 2, // 禁止不必要的括号 //(a * b) + c;//报错 \"no-extra-parens\": 0, // 禁止不必要的分号 \"no-extra-semi\": 2, // 禁止对 function 声明重新赋值 \"no-func-assign\": 2, // 禁止在嵌套的块中出现 function 或 var 声明 \"no-inner-declarations\": [2, \"functions\"], // 禁止 RegExp 构造函数中无效的正则表达式字符串 \"no-invalid-regexp\": 2, // 禁止在字符串和注释之外不规则的空白 \"no-irregular-whitespace\": 2, // 禁止在 in 表达式中出现否定的左操作数 \"no-negated-in-lhs\": 2, // 禁止把全局对象 (Math 和 JSON) 作为函数调用 错误：var math = Math(); \"no-obj-calls\": 2, // 禁止直接使用 Object.prototypes 的内置属性 \"no-prototype-builtins\":0, // 禁止正则表达式字面量中出现多个空格 \"no-regex-spaces\": 2, // 禁用稀疏数组 \"no-sparse-arrays\": 2, // 禁止出现令人困惑的多行表达式 \"no-unexpected-multiline\": 2, // 禁止在return、throw、continue 和 break语句之后出现不可达代码 /* function foo() &#123; return true; console.log(\"done\"); &#125;//错误 */ \"no-unreachable\": 2, // 要求使用 isNaN() 检查 NaN \"use-isnan\": 2, // 强制使用有效的 JSDoc 注释 \"valid-jsdoc\": 1, // 强制 typeof 表达式与有效的字符串进行比较 // typeof foo === \"undefimed\" 错误 \"valid-typeof\": 2, ////////////// // 最佳实践 // ////////////// // 定义对象的set存取器属性时，强制定义get \"accessor-pairs\": 2, // 强制数组方法的回调函数中有 return 语句 \"array-callback-return\":0, // 强制把变量的使用限制在其定义的作用域范围内 \"block-scoped-var\": 0, // 限制圈复杂度，也就是类似if else能连续接多少个 \"complexity\": [2, 9], // 要求 return 语句要么总是指定返回的值，要么不指定 \"consistent-return\": 0, // 强制所有控制语句使用一致的括号风格 \"curly\": [2, \"all\"], // switch 语句强制 default 分支，也可添加 // no default 注释取消此次警告 \"default-case\": 2, // 强制object.key 中 . 的位置，参数: // property，'.'号应与属性在同一行 // object, '.' 号应与对象名在同一行 \"dot-location\": [2, \"property\"], // 强制使用.号取属性 // 参数： allowKeywords：true 使用保留字做属性名时，只能使用.方式取属性 // false 使用保留字做属性名时, 只能使用[]方式取属性 e.g [2, &#123;\"allowKeywords\": false&#125;] // allowPattern: 当属性名匹配提供的正则表达式时，允许使用[]方式取值,否则只能用.号取值 e.g [2, &#123;\"allowPattern\": \"^[a-z]+(_[a-z]+)+$\"&#125;] \"dot-notation\": [2, &#123; \"allowKeywords\": false &#125;], // 使用 === 替代 == allow-null允许null和undefined== \"eqeqeq\": [2, \"allow-null\"], // 要求 for-in 循环中有一个 if 语句 \"guard-for-in\": 2, // 禁用 alert、confirm 和 prompt \"no-alert\": 0, // 禁用 arguments.caller 或 arguments.callee \"no-caller\": 2, // 不允许在 case 子句中使用词法声明 \"no-case-declarations\":2, // 禁止除法操作符显式的出现在正则表达式开始的位置 \"no-div-regex\": 2, // 禁止 if 语句中有 return 之后有 else \"no-else-return\": 0, // 禁止出现空函数.如果一个函数包含了一条注释，它将不会被认为有问题。 \"no-empty-function\":2, // 禁止使用空解构模式no-empty-pattern \"no-empty-pattern\":2, // 禁止在没有类型检查操作符的情况下与 null 进行比较 \"no-eq-null\": 1, // 禁用 eval() \"no-eval\": 2, // 禁止扩展原生类型 \"no-extend-native\": 2, // 禁止不必要的 .bind() 调用 \"no-extra-bind\": 2, // 禁用不必要的标签 \"no-extra-label:\":0, // 禁止 case 语句落空 \"no-fallthrough\": 2, // 禁止数字字面量中使用前导和末尾小数点 \"no-floating-decimal\": 2, // 禁止使用短符号进行类型转换(!!fOO) \"no-implicit-coercion\":0, // 禁止在全局范围内使用 var 和命名的 function 声明 \"no-implicit-globals\":1, // 禁止使用类似 eval() 的方法 \"no-implied-eval\": 2, // 禁止 this 关键字出现在类和类对象之外 \"no-invalid-this\":0, // 禁用 __iterator__ 属性 \"no-iterator\": 2, // 禁用标签语句 \"no-labels\": 2, // 禁用不必要的嵌套块 \"no-lone-blocks\": 2, // 禁止在循环中出现 function 声明和表达式 \"no-loop-func\":1, // 禁用魔术数字(3.14什么的用常量代替) \"no-magic-numbers\":[1,&#123; \"ignore\": [0,-1,1] &#125;], // 禁止使用多个空格 \"no-multi-spaces\": 2, // 禁止使用多行字符串，在 JavaScript 中，可以在新行之前使用斜线创建多行字符串 \"no-multi-str\": 2, // 禁止对原生对象赋值 \"no-native-reassign\": 2, // 禁止在非赋值或条件语句中使用 new 操作符 \"no-new\": 2, // 禁止对 Function 对象使用 new 操作符 \"no-new-func\": 0, // 禁止对 String，Number 和 Boolean 使用 new 操作符 \"no-new-wrappers\": 2, // 禁用八进制字面量 \"no-octal\": 2, // 禁止在字符串中使用八进制转义序列 \"no-octal-escape\": 2, // 不允许对 function 的参数进行重新赋值 \"no-param-reassign\": 0, // 禁用 __proto__ 属性 \"no-proto\": 2, // 禁止使用 var 多次声明同一变量 \"no-redeclare\": 2, // 禁用指定的通过 require 加载的模块 \"no-return-assign\": 0, // 禁止使用 javascript: url \"no-script-url\": 0, // 禁止自我赋值 \"no-self-assign\":2, // 禁止自身比较 \"no-self-compare\": 2, // 禁用逗号操作符 \"no-sequences\": 2, // 禁止抛出非异常字面量 \"no-throw-literal\": 2, // 禁用一成不变的循环条件 \"no-unmodified-loop-condition\":2, // 禁止出现未使用过的表达式 \"no-unused-expressions\": 0, // 禁用未使用过的标签 \"no-unused-labels\":2, // 禁止不必要的 .call() 和 .apply() \"no-useless-call\":2, // 禁止不必要的字符串字面量或模板字面量的连接 \"no-useless-concat\":2, // 禁用不必要的转义字符 \"no-useless-escape\":0, // 禁用 void 操作符 \"no-void\": 0, // 禁止在注释中使用特定的警告术语 \"no-warning-comments\": 0, // 禁用 with 语句 \"no-with\": 2, // 强制在parseInt()使用基数参数 \"radix\": 2, // 要求所有的 var 声明出现在它们所在的作用域顶部 \"vars-on-top\": 0, // 要求 IIFE 使用括号括起来 \"wrap-iife\": [2, \"any\"], // 要求或禁止 “Yoda” 条件 \"yoda\": [2, \"never\"], // 要求或禁止使用严格模式指令 \"strict\": 0, ////////////// // 变量声明 // ////////////// // 要求或禁止 var 声明中的初始化(初值) \"init-declarations\":0, // 不允许 catch 子句的参数与外层作用域中的变量同名 \"no-catch-shadow\": 0, // 禁止删除变量 \"no-delete-var\": 2, // 不允许标签与变量同名 \"no-label-var\": 2, // 禁用特定的全局变量 \"no-restricted-globals\":0, // 禁止 var 声明 与外层作用域的变量同名 \"no-shadow\": 0, // 禁止覆盖受限制的标识符 \"no-shadow-restricted-names\": 2, // 禁用未声明的变量，除非它们在 /*global */ 注释中被提到 \"no-undef\": 2, // 禁止将变量初始化为 undefined \"no-undef-init\": 2, // 禁止将 undefined 作为标识符 \"no-undefined\": 0, // 禁止出现未使用过的变量 \"no-unused-vars\": [2, &#123; \"vars\": \"all\", \"args\": \"none\" &#125;], // 不允许在变量定义之前使用它们 \"no-use-before-define\": 0, ////////////////////////// // Node.js and CommonJS // ////////////////////////// // require return statements after callbacks \"callback-return\":0, // 要求 require() 出现在顶层模块作用域中 \"global-require\": 1, // 要求回调函数中有容错处理 \"handle-callback-err\": [2, \"^(err|error)$\"], // 禁止混合常规 var 声明和 require 调用 \"no-mixed-requires\": 0, // 禁止调用 require 时使用 new 操作符 \"no-new-require\": 2, // 禁止对 __dirname 和 __filename进行字符串连接 \"no-path-concat\": 0, // 禁用 process.env \"no-process-env\": 0, // 禁用 process.exit() \"no-process-exit\": 0, // 禁用同步方法 \"no-sync\": 0, ////////////// // 风格指南 // ////////////// // 指定数组的元素之间要以空格隔开(, 后面)， never参数：[ 之前和 ] 之后不能带空格，always参数：[ 之前和 ] 之后必须带空格 \"array-bracket-spacing\": [2, \"never\"], // 禁止或强制在单行代码块中使用空格(禁用) \"block-spacing\":[1,\"never\"], //强制使用一致的缩进 第二个参数为 \"tab\" 时，会使用tab， // if while function 后面的&#123;必须与if在同一行，java风格。 \"brace-style\": [2, \"1tbs\", &#123; \"allowSingleLine\": true &#125;], // 双峰驼命名格式 \"camelcase\": 2, // 控制逗号前后的空格 \"comma-spacing\": [2, &#123; \"before\": false, \"after\": true &#125;], // 控制逗号在行尾出现还是在行首出现 (默认行尾) // http://eslint.org/docs/rules/comma-style \"comma-style\": [2, \"last\"], //\"SwitchCase\" (默认：0) 强制 switch 语句中的 case 子句的缩进水平 // 以方括号取对象属性时，[ 后面和 ] 前面是否需要空格, 可选参数 never, always \"computed-property-spacing\": [2, \"never\"], // 用于指统一在回调函数中指向this的变量名，箭头函数中的this已经可以指向外层调用者，应该没卵用了 // e.g [0,\"that\"] 指定只能 var that = this. that不能指向其他任何值，this也不能赋值给that以外的其他值 \"consistent-this\": [1,\"that\"], // 强制使用命名的 function 表达式 \"func-names\": 0, // 文件末尾强制换行 \"eol-last\": 2, \"indent\": [2, 4, &#123; \"SwitchCase\": 1 &#125;], // 强制在对象字面量的属性中键和值之间使用一致的间距 \"key-spacing\": [2, &#123; \"beforeColon\": false, \"afterColon\": true &#125;], // 强制使用一致的换行风格 \"linebreak-style\": [1,\"unix\"], // 要求在注释周围有空行 ( 要求在块级注释之前有一空行) \"lines-around-comment\": [1,&#123;\"beforeBlockComment\":true&#125;], // 强制一致地使用函数声明或函数表达式，方法定义风格，参数： // declaration: 强制使用方法声明的方式，function f()&#123;&#125; e.g [2, \"declaration\"] // expression：强制使用方法表达式的方式，var f = function() &#123;&#125; e.g [2, \"expression\"] // allowArrowFunctions: declaration风格中允许箭头函数。 e.g [2, \"declaration\", &#123; \"allowArrowFunctions\": true &#125;] \"func-style\": 0, // 强制回调函数最大嵌套深度 5层 \"max-nested-callbacks\": [1,5], // 禁止使用指定的标识符 \"id-blacklist\":0, // 强制标识符的最新和最大长度 \"id-length\":0, // 要求标识符匹配一个指定的正则表达式 \"id-match\":0, // 强制在 JSX 属性中一致地使用双引号或单引号 \"jsx-quotes\":0, // 强制在关键字前后使用一致的空格 (前后腰需要) \"keyword-spacing\":2, // 强制一行的最大长度 \"max-len\":[1,200], // 强制最大行数 \"max-lines\":0, // 强制 function 定义中最多允许的参数数量 \"max-params\":[1,7], // 强制 function 块最多允许的的语句数量 \"max-statements\":[1,200], // 强制每一行中所允许的最大语句数量 \"max-statements-per-line\":0, // 要求构造函数首字母大写 （要求调用 new 操作符时有首字母大小的函数，允许调用首字母大写的函数时没有 new 操作符。） \"new-cap\": [2, &#123; \"newIsCap\": true, \"capIsNew\": false &#125;], // 要求调用无参构造函数时有圆括号 \"new-parens\": 2, // 要求或禁止 var 声明语句后有一行空行 \"newline-after-var\": 0, // 禁止使用 Array 构造函数 \"no-array-constructor\": 2, // 禁用按位运算符 \"no-bitwise\":0, // 要求 return 语句之前有一空行 \"newline-before-return\":0, // 要求方法链中每个调用都有一个换行符 \"newline-per-chained-call\":1, // 禁用 continue 语句 \"no-continue\": 0, // 禁止在代码行后使用内联注释 \"no-inline-comments\": 0, // 禁止 if 作为唯一的语句出现在 else 语句中 \"no-lonely-if\": 0, // 禁止混合使用不同的操作符 \"no-mixed-operators\":0, // 不允许空格和 tab 混合缩进 \"no-mixed-spaces-and-tabs\": 2, // 不允许多个空行 \"no-multiple-empty-lines\": [2, &#123; \"max\": 2 &#125;], // 不允许否定的表达式 \"no-negated-condition\":0, // 不允许使用嵌套的三元表达式 \"no-nested-ternary\": 0, // 禁止使用 Object 的构造函数 \"no-new-object\": 2, // 禁止使用一元操作符 ++ 和 -- \"no-plusplus\":0, // 禁止使用特定的语法 \"no-restricted-syntax\":0, // 禁止 function 标识符和括号之间出现空格 \"no-spaced-func\": 2, // 不允许使用三元操作符 \"no-ternary\": 0, // 禁用行尾空格 \"no-trailing-spaces\": 2, // 禁止标识符中有悬空下划线_bar \"no-underscore-dangle\": 0, // 禁止可以在有更简单的可替代的表达式时使用三元操作符 \"no-unneeded-ternary\": 2, // 禁止属性前有空白 \"no-whitespace-before-property\":0, // 强制花括号内换行符的一致性 \"object-curly-newline\":0, // 强制在花括号中使用一致的空格 \"object-curly-spacing\": 0, // 强制将对象的属性放在不同的行上 \"object-property-newline\":0, // 强制函数中的变量要么一起声明要么分开声明 \"one-var\": [2, &#123; \"initialized\": \"never\" &#125;], // 要求或禁止在 var 声明周围换行 \"one-var-declaration-per-line\":0, // 要求或禁止在可能的情况下要求使用简化的赋值操作符 \"operator-assignment\": 0, // 强制操作符使用一致的换行符 \"operator-linebreak\": [2, \"after\", &#123; \"overrides\": &#123; \"?\": \"before\", \":\": \"before\" &#125; &#125;], // 要求或禁止块内填充 \"padded-blocks\": 0, // 要求对象字面量属性名称用引号括起来 \"quote-props\": 0, // 强制使用一致的反勾号、双引号或单引号 \"quotes\": [2, \"single\", \"avoid-escape\"], // 要求使用 JSDoc 注释 \"require-jsdoc\":1, // 要求或禁止使用分号而不是 ASI（这个才是控制行尾部分号的，） \"semi\": [2, \"always\"], // 强制分号之前和之后使用一致的空格 \"semi-spacing\": 0, // 要求同一个声明块中的变量按顺序排列 \"sort-vars\": 0, // 强制在块之前使用一致的空格 \"space-before-blocks\": [2, \"always\"], // 强制在 function的左括号之前使用一致的空格 \"space-before-function-paren\": [2, \"always\"], // 强制在圆括号内使用一致的空格 \"space-in-parens\": [2, \"never\"], // 要求操作符周围有空格 \"space-infix-ops\": 2, // 强制在一元操作符前后使用一致的空格 \"space-unary-ops\": [2, &#123; \"words\": true, \"nonwords\": false &#125;], // 强制在注释中 // 或 /* 使用一致的空格 \"spaced-comment\": [2, \"always\", &#123; \"markers\": [\"global\", \"globals\", \"eslint\", \"eslint-disable\", \"*package\", \"!\"] &#125;], // 要求或禁止 Unicode BOM \"unicode-bom\": 0, // 要求正则表达式被括号括起来 \"wrap-regex\": 0, ////////////// // ES6.相关 // ////////////// // 要求箭头函数体使用大括号 \"arrow-body-style\": 2, // 要求箭头函数的参数使用圆括号 \"arrow-parens\": 2, \"arrow-spacing\":[2,&#123; \"before\": true, \"after\": true &#125;], // 强制在子类构造函数中用super()调用父类构造函数，TypeScrip的编译器也会提示 \"constructor-super\": 0, // 强制 generator 函数中 * 号周围使用一致的空格 \"generator-star-spacing\": [2, &#123; \"before\": true, \"after\": true &#125;], // 禁止修改类声明的变量 \"no-class-assign\":2, // 不允许箭头功能，在那里他们可以混淆的比较 \"no-confusing-arrow\":0, // 禁止修改 const 声明的变量 \"no-const-assign\":2, // 禁止类成员中出现重复的名称 \"no-dupe-class-members\":2, // 不允许复制模块的进口 \"no-duplicate-imports\":0, // 禁止 Symbol 的构造函数 \"no-new-symbol\":2, // 允许指定模块加载时的进口 \"no-restricted-imports\":0, // 禁止在构造函数中，在调用 super() 之前使用 this 或 super \"no-this-before-super\": 2, // 禁止不必要的计算性能键对象的文字 \"no-useless-computed-key\":0, // 要求使用 let 或 const 而不是 var \"no-var\": 0, // 要求或禁止对象字面量中方法和属性使用简写语法 \"object-shorthand\": 0, // 要求使用箭头函数作为回调 \"prefer-arrow-callback\":0, // 要求使用 const 声明那些声明后不再被修改的变量 \"prefer-const\": 0, // 要求在合适的地方使用 Reflect 方法 \"prefer-reflect\":0, // 要求使用扩展运算符而非 .apply() \"prefer-spread\":0, // 要求使用模板字面量而非字符串连接 \"prefer-template\":0, // Suggest using the rest parameters instead of arguments \"prefer-rest-params\":0, // 要求generator 函数内有 yield \"require-yield\":0, // enforce spacing between rest and spread operators and their expressions \"rest-spread-spacing\":0, // 强制模块内的 import 排序 \"sort-imports\":0, // 要求或禁止模板字符串中的嵌入表达式周围空格的使用 \"template-curly-spacing\":1, // 强制在 yield* 表达式中 * 周围使用空格 \"yield-star-spacing\":2 &#125;&#125;","categories":[{"name":"编码规范","slug":"编码规范","permalink":"http://yoursite.com/categories/编码规范/"}],"tags":[{"name":"代码规范","slug":"代码规范","permalink":"http://yoursite.com/tags/代码规范/"},{"name":"eslint","slug":"eslint","permalink":"http://yoursite.com/tags/eslint/"}]},{"title":"学习cli","slug":"[Command] 学习cli","date":"2018-07-18T10:08:12.000Z","updated":"2018-10-15T09:33:59.000Z","comments":true,"path":"2018/07/18/[Command] 学习cli/","link":"","permalink":"http://yoursite.com/2018/07/18/[Command] 学习cli/","excerpt":"","text":"&emsp;在这之前一直想做一个cli的脚手架，近期公司团队中有一位大牛开发完成，想自己学习，做了这篇学习记录，他的cli工具支持ValillaJS、VueJS、React、Angular等四大主流框架，我就学习Vue的即可，等之后有了自己的需求，自己再加。&emsp;Cli有三个模块组成：初始化、开发和构建 co、co-prompt的方法类似于 inquirer 1、项目的初始化目录 .gitignore.editorconfigindex.jsLINCESEpackage.jsonREADME.md 2、安装eslint以及配置lint、eslintConfig 在package.json中对 lint和eslint进行配置，对eslint中的rules进行约束 comma-dangle、no-console等3、利用husky设置git hooksprecommit 结合2 中的lint 规范代码4、利用commitlint lint commit 信息commitmsg、commitlint 提交信息的lint 规范，可参考 git commit 规范5、增加基础的cli信息，commander的使用init|server|build command -&gt; bin/cli.js commander 命令行自制 init | server | build6、i18n（国际化）的支持 增加i18n 英中文 对init|server|build 的说明，并修改bin/cli.js 的描述7、在lib中增加 logger.js 增加 logger util，用于 commander 命令的处理并作出不同的运行结果显示，比如：安装完毕，服务开启完毕，报错提示等。 补充：1、chalk 是一个颜色的插件123456const chalk = require('chalk');// Use RGB colors in terminal emulators that support it.console.log(chalk.blue('Hello') + 'World' + chalk.red('!'));console.log(chalk.keyword('orange')('Yay for orange colored text!'));console.log(chalk.rgb(123, 45, 67).underline('Underlined reddish color'));console.log(chalk.hex('#DEADED').bold('Bold gray!')); 2、readline 处理日志文本很方便，逐行读取 可参考node中文网查看API Node.js里实现标准输入输出的封装好的模块，通过这个模块我们可以以逐行的方式读取数据流。 3、nodejs的知识点：process.cwd() 是当前执行node命令时候的文件夹地址 ——工作目录（当前Node.js进程执行时的工作目录）dirname 是被执行的js 文件的地址 ——文件所在目录（当前模块的目录名） node.js进程当前工作的目录有可能不是该文件所在目录的完整目录 filename 获取当前模块文件的带有完整绝对路径的文件名 eg:process.cwd() /Users/meizu/myfile/programFile/cli-learn/lib__dirname /Users/meizu/myfile/programFile/cli-learn/lib__filename /Users/meizu/myfile/programFile/cli-learn/lib/config.js 4、node child_process 子进程 4、rimraf：以包的形式包装rm -rf命令，用来删除文件和文件夹的，不管文件夹是否为空，都可删除。5、extend：","categories":[{"name":"Command","slug":"Command","permalink":"http://yoursite.com/categories/Command/"}],"tags":[{"name":"cli","slug":"cli","permalink":"http://yoursite.com/tags/cli/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"flex遇到的那些坑","slug":"[CSS] flex遇到的那些坑","date":"2018-07-17T14:26:08.000Z","updated":"2018-10-08T02:21:58.000Z","comments":true,"path":"2018/07/17/[CSS] flex遇到的那些坑/","link":"","permalink":"http://yoursite.com/2018/07/17/[CSS] flex遇到的那些坑/","excerpt":"","text":"&emsp;在一次H5的项目开发中，由于是典型的左中右的布局，就使用了flex，但是遇到了一些坑，在记录之前，先简单的说下flex吧，想兼容PC IE10之前的，就不要用了，还是老实的使用float吧。 flex基础&emsp; flex布局主要设计12个属性（父容器和子容器各6个），但实际常用的只有4个（各2个） 作用于父容器的属性：flex-direction：决定主轴的方向flex-wrap：换行的方式flex-flow：为flex-direction和flex-wrap的简写形式，默认为：row nowrapjust-content：在主轴上的对齐方式（eg 水平）align-items：在交叉轴上的对齐方式（eg 垂直）align-content：多根轴线的对齐方式，若只有一根轴线，不起作用 作用于子容器的属性：order：排列顺序，数值越小，排列越靠前flex-grow：放大比例，默认为0，不放大&emsp;&emsp;&emsp;&emsp;&emsp;若所有项目该值都为1，表示等分&emsp;&emsp;&emsp;&emsp;&emsp;若有一个是2，其他的都为1 ，前者占据的剩余空间将比其他项多一倍flex-shrink：缩小比例，默认为1 ，即空间不足，项目将缩小&emsp;&emsp;&emsp;&emsp;&emsp;若所有项目该值为1 ，当空间不足时，将等比例缩小&emsp;&emsp;&emsp;&emsp;&emsp;若有一个是0，其他的都为1，则空间不足时，前者不缩小flex-basis：在分配多余空间之前，项目占据的主轴空间flex：flex-grow, flex-shrink 和 flex-basis的缩写，有auto(1 1 auto)和none(0 0 auto)快捷键align-self：允许单个项目有与其他小哀公母不一样的对齐方式，可覆盖align-items属性 遇坑计设置了flex-grow元素的子级宽度问题基础总结：","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/categories/基础知识/"}],"tags":[{"name":"css3","slug":"css3","permalink":"http://yoursite.com/tags/css3/"}]},{"title":"canvas系列之小球的碰撞运动","slug":"[Canvas] canvas系列之小球的碰撞运动","date":"2018-07-16T08:13:45.000Z","updated":"2018-10-15T06:19:49.000Z","comments":true,"path":"2018/07/16/[Canvas] canvas系列之小球的碰撞运动/","link":"","permalink":"http://yoursite.com/2018/07/16/[Canvas] canvas系列之小球的碰撞运动/","excerpt":"","text":"&emsp;之前分享过一次canvas的技术","categories":[{"name":"Canvas","slug":"Canvas","permalink":"http://yoursite.com/categories/Canvas/"}],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/tags/canvas/"}]}]}